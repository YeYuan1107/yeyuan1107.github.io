<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Java常用类 | YBLOG</title>

<link rel="shortcut icon" href="https://yeyuan1107.github.io/favicon.ico?v=1657077232781">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://yeyuan1107.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
        <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script> 
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            YBLOG
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1657077232781"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java常用类
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-11-15 ·
                    </time>
                    
                        <a href="https://yeyuan1107.github.io/tag/wZpx5Scef/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <p><a name="axrXZ"></a></p>
<h1 id="字符串相关的类">字符串相关的类</h1>
<p><a name="VaVY3"></a></p>
<h2 id="string类">String类</h2>
<ol>
<li>String类：代表字符串。Java程序中的所有字符串字面值都作为此类的实例实现</li>
<li>String类是一个final类，代表不可变的字符序列，不能被继承</li>
<li>字符串是常量，用双引号引起来表示，他们的值在创建之后不能更改</li>
<li>String对象的字符内容是存储在一个字符数组value[]中的</li>
<li>String实现了Serializable接口：表示字符串事支持序列化的</li>
<li>String实现了comparable接口：表示字符串可以比较大小</li>
<li>String内部定义了final char[] value用于存储字符串数据，数组及数组内容均不可变</li>
</ol>
<pre><code class="language-java">public final class String
	implements java.io.Serializable, Comparable&lt;String&gt;, CharSeqence{
	// The value is used for character storage
	private final char value[];
	//Cache the hash code for the String. Default to 0
	private int hash;
}
</code></pre>
<p><a name="IjgdW"></a></p>
<h3 id="不可变性">不可变性</h3>
<ol>
<li>不同字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有value进行赋值，即不更改原地址上的内容，重新开辟一块内存赋值，地址指向新开辟的内存</li>
<li>当现有的字符串进行连接操作时，也需要指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>当调用String的修改方法replace()修改制定的字符或字符串时，也必须重新指定内存区域赋值<br>
<a name="EEvzP"></a></li>
</ol>
<h3 id="创建方式">创建方式</h3>
<pre><code class="language-java">String str = &quot;hello&quot;;
//相当于this.value = new char[0]
String str = new String();
//相当于this.value = original.value
String str = new String(String original);
//相当于this.value = Arrays.copyOf(value, value.length)
String str = new String(char[] a);

String str = new String(char[] a, int startIndex, int count);
</code></pre>
<p><a name="BN44m"></a></p>
<h3 id="内存解析">内存解析</h3>
<p>当String使用字面量的定义方式如：String xxx = &quot;abc&quot; (&quot;abc&quot;声明在字符串常量池)当等号右侧内容相同时，不同的String对象指向的是同一个地址，字符串敞亮池中不会存放相同内容的字符串<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801764479-19465b01-04db-4683-b4de-c5629187a4eb-20220312141123800-20220312152126923.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801790517-58cc60ed-cb7c-4295-a094-f59499b1d57e-20220312141123824-20220312152126941.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801796005-a65c9be5-a384-4ca1-999e-5ab1ea5fcdaa-20220312141123852-20220312152126958.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801800402-df94cc07-dc62-4dc8-99f4-ecdc5b3a9a0f-20220312141123884-20220312152126994.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801805518-7d22ecf9-0226-48a2-bdd0-6a90952fcc85-20220312141123934-20220312152127019.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801810648-fe864e2d-8e66-4ea7-83ed-a43199da6eac-20220312141124199-20220312152127297.png" alt="image.png" loading="lazy"></p>
<pre><code class="language-java">//在字符串常量池中创建了一个字面量为&quot;a&quot;的字符串
String s1 = &quot;a&quot;;
//实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1 +&quot;b&quot;即&quot;ab&quot;。
//只要其中一个是变量，结果就在堆中，+=也是该情况。
//如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。
//如果这样的操作放到循环中，会极大影响程序的性能
s1 = s1 + &quot;b&quot;;
//直接在字符串常量池中创建一个字面量为&quot;ab&quot;的字符串
String s2 = &quot;ab&quot;;
//s3指向字符串常量池中已经创建的&quot;ab&quot;的字符串
String s3 = &quot;a&quot; + &quot;b&quot;;
//堆空间的s1对象在调用intern()之后，会将常量池中已经存在的&quot;ab&quot;字符串赋值给s4
String s4 = s1.intern();
</code></pre>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645801930464-b5ab25bd-1b02-4423-8d9b-ba91b54f8804-20220312141124239-20220312152127344.png" alt="image.png" loading="lazy"><br>
<a name="YplOQ"></a></p>
<h3 id="string常用方法">String常用方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int length()</td>
<td>返回字符串的长度:return value.length</td>
</tr>
<tr>
<td>char charAt(int index)</td>
<td>返回某索引处的字符:return value[index]</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断是否是空字符串:return value.length==0</td>
</tr>
<tr>
<td>String toLowerCase()</td>
<td>使用默认语言环境,将String中的所有字符转换为小写</td>
</tr>
<tr>
<td>String toUpperCase()</td>
<td>使用默认语言环境,将String中的所有字符转换为大写</td>
</tr>
<tr>
<td>String trim()</td>
<td>返回字符串的副本忽略前导空白和尾部空白</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>比较字符串的内容是否相同</td>
</tr>
<tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>与 equals 方法类似忽略大小写</td>
</tr>
<tr>
<td>String concat(String str)</td>
<td>将指定字符串连接到此字符串的结尾，等价于用&quot;+&quot;</td>
</tr>
<tr>
<td>int compareTo(String anotherString)</td>
<td>比较两个字符串的大小,&gt;0当前对象大，否则当前对象小</td>
</tr>
<tr>
<td>String substring(int beginIndex)</td>
<td>返回一个新的字符串它是此字符串的从beginIndex开始截取到最后的一个子字符串。</td>
</tr>
<tr>
<td>String substring(int beginIndex, int endIndex)</td>
<td>返回一个新字符串它是此字符串从 beginIndex开始截取到endIndex(不包含)的一个子字符串。</td>
</tr>
<tr>
<td>boolean endsWith(String suffix)</td>
<td>测试此字符串是否以指定的后缀结束</td>
</tr>
<tr>
<td>boolean startsWith(String prefix)</td>
<td>测试此字符串是否以指定的前缀开始</td>
</tr>
<tr>
<td>boolean startsWith(String prefix, int offset)</td>
<td>测试此字符串从指定索引开始的子字符串是否以指定前缀开始</td>
</tr>
<tr>
<td>boolean contains(CharSequence s)</td>
<td>当且仅当此字符串包含指定的char值序列时，返回true</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>返回指定子字符串在此字符串中第一次出现处的索引</td>
</tr>
<tr>
<td>int indexOf(String str, int fromIndex)</td>
<td>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>返回指定子字符串在此字符串中最右边出现处的索引</td>
</tr>
<tr>
<td>int lastIndexOf(String str, int fromIndex)</td>
<td>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</td>
</tr>
<tr>
<td></td>
<td>indexOf 和 lastIndexOf 方法如果未找到都是返回 1</td>
</tr>
<tr>
<td>String replace(char oldChar, char newChar)</td>
<td>返回一个新的字符串它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</td>
</tr>
<tr>
<td>String replace(CharSequence target, CharSequence replacement)</td>
<td>使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</td>
</tr>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串</td>
</tr>
<tr>
<td>String replaceFirst(String regex, String replacement)</td>
<td>使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>boolean matches(String regex)</td>
<td>告知此字符串是否匹配给定的正则表达式</td>
</tr>
<tr>
<td>String[] split(String regex)</td>
<td>根据给定正则表达式的匹配拆分此字符串</td>
</tr>
<tr>
<td>String[] split(String regex, int limit)</td>
<td>根据匹配给定的正则表达式来拆分此字符串 最多不超过limit个如果超过了剩下的全部都放到最后一个元素中</td>
</tr>
<tr>
<td>包装类.parseXxx(String str)</td>
<td>将字符串转为基本数据类型、包装类</td>
</tr>
<tr>
<td>String.valueOf(xxx)</td>
<td>将包装类、基本数据类型转为字符串</td>
</tr>
<tr>
<td>new String(char[] xxx)</td>
<td>将字符数组转化为字符串</td>
</tr>
<tr>
<td>new String(char[] xxx, int offset, int length)</td>
<td>将字符数组从offset开始，长度为length，转化为字符串</td>
</tr>
<tr>
<td>str.toCharArray()</td>
<td>将字符串转化为字符数组</td>
</tr>
<tr>
<td>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</td>
<td>提供了将指定索引范围内的字符串存放到数组中的方法</td>
</tr>
<tr>
<td>String(byte[] xxx)</td>
<td>通过平台默认字符集解码制定的byte数组，构造一个新的String</td>
</tr>
<tr>
<td>String(byte[] xxx, int offset, int length)</td>
<td>从offset开始长度为length个字节构造一个字符串对象</td>
</tr>
<tr>
<td>String(byte[] xxx, charsetName</td>
<td>按照指定字符集解码字节数组</td>
</tr>
<tr>
<td>public byte[] getBytes()</td>
<td>按照平台默认字符集将String编码为byte数组</td>
</tr>
<tr>
<td>public byte[] getBytes(String charsetName)</td>
<td>使用指定的字符集，将此String编码到byte序列，并将结果存储到新的byte数组</td>
</tr>
</tbody>
</table>
<p><a name="o8Y5w"></a></p>
<h2 id="stringbuffer和stringbuilder">StringBuffer和StringBuilder</h2>
<p>不同点：</p>
<ol>
<li>StringBuffer：线程安全，效率偏低</li>
<li>StringBuilder：线程不安全，效率更高，JDK1.5中新增</li>
</ol>
<p>相同点：</p>
<ol>
<li>父类相同均为AbstractStringBuilder</li>
<li>均为可变字符串</li>
<li>底层均为字符数组char[]</li>
</ol>
<p><a name="UjdTg"></a></p>
<h3 id="与string区别">与String区别</h3>
<ol>
<li>与String类不同，其对象必须使用构造器生成，有三个构造器
<ul>
<li>StringBuffer(), StringBuilder()：初始容量为16的字符串缓冲区</li>
<li>StringBuffer(int size), StringBuilder(int size)：构造指定容量的字符串缓冲区</li>
<li>StringBuffer(String str), StringBuilder(String str)：将内容初始化为指定字符串内容，字符数组长度为str.length + 16
<ul>
<li>构造器中 str 如果等于null那么抛出空指针异常</li>
</ul>
</li>
<li>如果要添加的数据底层数组装不下，那就要扩容底层数组，一般扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新数组中<br>
<a name="d44qz"></a></li>
</ul>
</li>
</ol>
<h3 id="常用方法">常用方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringBuffer append(xxx)</td>
<td>提供了很多的 append() 方法用于进行字符串拼接，如果xxx为null那么在字符串中增加&quot;null&quot;</td>
</tr>
<tr>
<td>StringBuffer delete(int start,int end)</td>
<td>删除指定位置的内容，左闭右开</td>
</tr>
<tr>
<td>StringBuffer replace(int start, int end, String str)</td>
<td>把[start,end)位置替换为str</td>
</tr>
<tr>
<td>StringBuffer insert(int offset, xxx)</td>
<td>在指定位置插入xxx</td>
</tr>
<tr>
<td>StringBuffer reverse()</td>
<td>把当前字符序列逆转</td>
</tr>
<tr>
<td>public int indexOf (String str)</td>
<td></td>
</tr>
<tr>
<td>public String substring (int start,int end)</td>
<td></td>
</tr>
<tr>
<td>public int length()</td>
<td></td>
</tr>
<tr>
<td>public char charAt (int n)</td>
<td></td>
</tr>
<tr>
<td>public void setCharAt (int n ,char ch)</td>
<td></td>
</tr>
</tbody>
</table>
<p><a name="CiYGD"></a></p>
<h1 id="日期时间api">日期时间API</h1>
<p><a name="KoEYd"></a></p>
<h2 id="jdk80之前日期时间api">JDK8.0之前日期时间API</h2>
<figure data-type="image" tabindex="1"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646058566758-36744630-1f77-4fe8-a9b0-4e9f857169c9-20220312141124528-20220312152127636.png" alt="image.png" loading="lazy"></figure>
<ol>
<li>java.lang.System类<br />System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。此方法适用于计算时间差。</li>
<li>java.util.Date类<br />表示特定的瞬间，精确到毫秒
<ol>
<li>构造器
<ul>
<li>Date()：使用无参构造器创建的对象可以获取本地当前时间</li>
<li>Date(long date)：创建指定毫秒数的一个对象</li>
</ul>
</li>
<li>常用方法
<ul>
<li>getTime()：返回自1970年1月1日00:00:00 GMT 以来次Date对象表示的毫秒数</li>
<li>toString()：把此Date对象转换为以下形式的String：dow mon dd hh:mm:ss zzz yyy其中：dow是星期，zzz是时间标准</li>
</ul>
</li>
</ol>
</li>
<li>java.sql.Date
<ul>
<li>该类为java.util.Date类的子类，对应数据库中日期变量</li>
<li>构造器
<ul>
<li>new Date(long date)：用指定毫秒数构建对象</li>
</ul>
</li>
<li>方法
<ul>
<li>toString()只输出年月日</li>
</ul>
</li>
<li>将java.util.Date类转化为java.sql.Date类</li>
</ul>
</li>
</ol>
<pre><code class="language-java">//方式一
Date date1 = new java.sql.Date(long time);
java.sql.Date date2 = (java.sql.Date)date1;
//方式二
Date date3 = new Date();
java.sql.Date date4 = new java.sql.Date(date3.getTime());
</code></pre>
<ol start="4">
<li>java.text.SimpleDateFormat类
<ul>
<li>Date类的API不易于国际化，大部分被废弃了，该类是一个不与语言环境有关的方式来格式化和解析日期的具体类</li>
<li>它允许进行格式化：日期 -&gt; 文本、解析：文本 -&gt; 日期</li>
<li>格式化：
<ul>
<li>SimpleDateFormat()：默认的模式和语言环境创建对象</li>
<li>public SimpleDateFormat(String pattern)：该构造方法可以使用参数pattern指定的格式创建一个对象，该对象调用public String format(Date date)：方法格式化时间对象date
<ul>
<li>pattern示例：yyyy(4位年份)-MM(2位月份)-dd(2位日期) hh(2位小时):mm(2位分钟):ss(2位秒)</li>
</ul>
</li>
</ul>
</li>
<li>解析：
<ul>
<li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期</li>
</ul>
</li>
</ul>
</li>
<li>java.util.Calendar类
<ul>
<li>Calendar类是一个抽象基类，主要用于完成日期字段之间相互操作的功能<br />获取Calendar类的方法:
<ul>
<li>使用Calendar.getInstance()方法，返回GregorianCalendar对象</li>
<li>调用他的子类GregorianCalendar的构造器</li>
</ul>
</li>
<li>常用方法
<ul>
<li>public int get(int field)方法来取得想要的时间信息，比如YEAR、MONTH、DAY_OF_WEEK 、HOUR_OF_DAY、MINUTE、SECOND
<ul>
<li>获取月份时：一月是0，二月是1...</li>
<li>获取星期时：周日是1，周一是2...</li>
</ul>
</li>
<li>public void set(int field, int value)：更改对应field属性</li>
<li>public void add(int field, int amount)：在field属性上加amount</li>
<li>public final Date getTime()：日历类 -&gt; Date类</li>
<li>public final void setTime(Date date)：Date类 -&gt; 日历类<br>
<a name="TIH0S"></a></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="jdk8中的新日期api">JDK8中的新日期API</h2>
<p>Calendar类的缺点：</p>
<ol>
<li>可变性：像日期和时间这样的类应该是不可变的</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都从0开始</li>
<li>格式化：格式化只对Date有用，Calendar则不行</li>
<li>不是线程安全的不能处理闰秒<br>
<a name="SdskX"></a></li>
</ol>
<h3 id="javatime-api">java.time API</h3>
<ol>
<li>LocalDate类(本地日期)</li>
<li>LocalTime类(本地时间)</li>
<li>LocalDateTime类(本地日期时间)</li>
<li>ZonedDateTime类(时区)</li>
<li>Duration类(持续时间)<br>
<a name="RAZu1"></a></li>
</ol>
<h3 id="javatime-包含值对象的基础包">java.time 包含值对象的基础包</h3>
<p>java.time.chrono 提供对不同的日历系统的访问<br>
<a name="xRzHV"></a></p>
<h4 id="javatimeformat-格式化和解析时间和日期">java.time.format 格式化和解析时间和日期</h4>
<p>java.time.temporal 包含底层框架和扩展类型<br />java.time.zone 包含时区支持的类</p>
<p><a name="imuf9"></a></p>
<h3 id="localdate-localtime-localdatetime类">LocalDate LocalTime LocalDateTime类</h3>
<p>这几个类是较为重要的几个类，他们的实例是不可变的对象，分别表示用ISO-8601日历系统的日期、时间、日期和时间。</p>
<ul>
<li>LocalDate代表ISO格式(yyyy-MM-dd)的日期，可以存储生日、纪念日等日期</li>
<li>LocalTime表示一个时间，而不是日期</li>
<li><strong>LocalDateTime</strong>是用来表示日期和时间的，这是一个最常用的类之一</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>now() /* now(ZoneId zone)</td>
<td>静态方法根据当前时间<strong>创建对象/指定时区的对象</strong></td>
</tr>
<tr>
<td>of()</td>
<td>静态方法根据指定日期时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth()/getDayOfYear()</td>
<td>获得月份天数(1-31)/获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份(返回一个 Month 枚举值)</td>
</tr>
<tr>
<td>getMonthValue()/getYear()</td>
<td>获得月份(1-12)/获得年份</td>
</tr>
<tr>
<td>getHour()/getMinute()/getSecond()</td>
<td>获得当前对象对应的小时、分钟 、秒</td>
</tr>
<tr>
<td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td>
<td>将月份天数、年份天数 、月份 、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td>plusDays(), plusWeeks(),plusMonths(), plusYears(),plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>minusMonths()/minusDays()/minusYears()/minusHours()</td>
<td>从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
</tbody>
</table>
<p><a name="B1ynp"></a></p>
<h3 id="instant">Instant</h3>
<p>在处理时间和日期的时候，我们通常会想到年月日时分秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。 在 UNIX 中，这个数从 1970 年开始，以秒为的单位；同样的，在 Java 中，也是从 1970 年开始，但以毫秒为单位。java.time 包通过值类型 Instant 提供机器视图，不提供处理人类意义上的时间单位。 Instant 表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲， 它只是简单的表示自 1970 年 1 月 1 日 0 时 0 分 0 秒（ UTC ）开始的秒数。 因为 java.time 包是基于纳秒计算的，所以 Instant 的精度可以达到纳秒级。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>now()</td>
<td>静态方法返回默认 UTC 时区的 Instant 类的对象</td>
</tr>
<tr>
<td>ofEpochMilli (long epochMilli)</td>
<td>静态方法返回在 1970-01-01 00:00:00 基础上加上指定毫秒数之后的 Instant 类的对象</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>结合即时的偏移来创建一个OffsetDateTime</td>
</tr>
<tr>
<td>toEpochMilli()</td>
<td>返回1970-01-01 00:00:00 到当前时间的毫秒数即为时间戳，时间戳是指格林威治时间1970-01-01 00:00:00 北京时间 1970-01-01 08:00:00 起至现在的总秒数。</td>
</tr>
</tbody>
</table>
<p><a name="VIKDn"></a></p>
<h3 id="javatimeformatdatetimeformatter">java.time.format.DateTimeFormatter</h3>
<p>该类提供了三种格式化方法</p>
<ul>
<li>预定义的标准格式:
<ul>
<li>ISO_LOCAL_DATE_TIME</li>
<li>ISO_LOCAL_DATE</li>
<li>ISO_LOCAL_TIME</li>
</ul>
</li>
<li>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;)</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ofPattern(String pattern)</td>
<td>静态方法返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td>format(TemporalAccessort)</td>
<td>格式化一个日期、 时间返回字符串</td>
</tr>
<tr>
<td>parse(CharSequence text)</td>
<td>将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody>
</table>
<p><a name="Puc4m"></a></p>
<h3 id="其他api">其他API</h3>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646059456935-408e926a-b35d-45f0-af54-87d20d57dd01-20220312141124639-20220312152127699.png" alt="image.png" loading="lazy"><br>
<a name="cDXFQ"></a></p>
<h3 id="转换">转换</h3>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646059478815-a4c23b6d-d296-4126-898e-e8cc578f42b2-20220312141124713-20220312152127993.png" alt="image.png" loading="lazy"><br>
<a name="arFuJ"></a></p>
<h1 id="java比较器">Java比较器</h1>
<p>java.lang.Comparable与java.util.Comparator两个接口实现对象的比较<br>
<a name="ASZHJ"></a></p>
<h2 id="自然排序javalangcomparable">自然排序java.lang.Comparable</h2>
<p>Comparable 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序 。</p>
<ul>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小 。 如果当前对象 this 大于形参对象 obj 则返回正整数，如果当前对象 this 小于形参对象 obj 则返回负整数，如果当前对象 this 等于形参对象 obj 则返回零 。</li>
<li>实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort 进行自动排序(<strong>从小到大</strong>)。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器 。</li>
<li>对于类 C 的每一个 e1 和 e2 来说，当且仅当e1.compareTo(e2) == 0与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致 。 建议（虽然不是必需的）最好使自然排序与 equals 一致。<br>
<a name="SOAMF"></a></li>
</ul>
<h2 id="定制排序javautilcomparator">定制排序java.util.Comparator</h2>
<ul>
<li>当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序强行对多个对象进行整体排序的比较。</li>
<li>重写 compare(Object o1,Object o2) 方法，比较 o1 和 o2 的大小： 如果方法返回正整数，则表示 o1 大于 o2 ；如果返回 0 ，表示相等；返回负整数，表示o1 小于 o2 。</li>
<li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）从而允许在排序顺序上实现精确控制 。</li>
<li>还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序</li>
</ul>
<pre><code class="language-java">Arrays.sort(Object[] arr, new comparator{
	public int compare(Object o1, Object o2){
		//升序：当o1&gt;o2时返回正数
		//降序：当o1&gt;o2时返回负数
		方法体;
	}
});
</code></pre>
<p><a name="AiAIm"></a></p>
<h1 id="system类">System类</h1>
<ul>
<li>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包 。</li>
<li>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的 成员变量和成员方法都是 static 的， 所以也可以很方便的进行调用 。</li>
<li>成员变量：System 类内部包含 in 、 out 和 err 三个成员变量，分别代表标准输入流(键盘输入) ，标准输出流(显示器)和标准错误输出流(显示器)。</li>
<li>成员方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>native long currentTimeMillis()</td>
<td>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和 GMT 时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</td>
</tr>
<tr>
<td>void exit(int status)</td>
<td>该方法的作用是退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。 使用该方法可以在图形界面编程中实现程序的退出功能等 。</td>
</tr>
<tr>
<td>void gc()</td>
<td>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</td>
</tr>
<tr>
<td>String getProperty(String key)</td>
<td>该方法的作用是获得系统中属性名为 key 的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</td>
</tr>
</tbody>
</table>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646059817477-863d5082-1809-4a50-83fa-17f9efdad7df-20220312141124746-20220312152128007.png" alt="image.png" loading="lazy"><br>
<a name="gIYl3"></a></p>
<h1 id="math类">Math类</h1>
<p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为<strong>double 型</strong>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs</td>
<td>绝对值</td>
</tr>
<tr>
<td>acos,asin,atan,cos,sin,tan</td>
<td>三角函数</td>
</tr>
<tr>
<td>sqrt</td>
<td>平方根</td>
</tr>
<tr>
<td>pow(double a,doble b)</td>
<td>a的b次幂(2的n次幂可以通过左移n-1位完成)</td>
</tr>
<tr>
<td>log</td>
<td>自然对数</td>
</tr>
<tr>
<td>exp</td>
<td>e为底指数</td>
</tr>
<tr>
<td>max(double a,double b)</td>
<td>最大值</td>
</tr>
<tr>
<td>min(double a,double b)</td>
<td>最小值</td>
</tr>
<tr>
<td>random()</td>
<td>返回 0.0 到 1.0 的随机数</td>
</tr>
<tr>
<td>long round(double a)</td>
<td>double型数据a转换为 long 型（四舍五入）</td>
</tr>
<tr>
<td>toDegrees(double angrad)</td>
<td>弧度 -&gt; 角度</td>
</tr>
<tr>
<td>toRadians(double angdeg)</td>
<td>角度 -&gt; 弧度</td>
</tr>
</tbody>
</table>
<p><a name="FigtV"></a></p>
<h1 id="biginteger和bigdecimal">BigInteger和BigDecimal</h1>
<p><a name="KPfs1"></a></p>
<h2 id="biginteger">BigInteger</h2>
<p>java.math 包的 BigInteger 可以表示<strong>不可变的任意精度的整数</strong> 。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外， BigInteger 还提供以下运算：模算术、 GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
<ul>
<li>构造器:<br />BigInteger(String val) 根据字符串构建 BigInteger 对象</li>
<li>常用方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigInteger abs ()</td>
<td>返回此 BigInteger 的绝对值的 BigInteger。</td>
</tr>
<tr>
<td>BigInteger add(BigInteger val)</td>
<td>返回其值为 (this + val) 的 BigInteger</td>
</tr>
<tr>
<td>BigInteger subtract(BigInteger val)</td>
<td>返回其值为 (this - val) 的 BigInteger</td>
</tr>
<tr>
<td>BigInteger multiply (BigInteger val)</td>
<td>返回其值为 (this * val) 的 BigInteger</td>
</tr>
<tr>
<td>BigInteger divide (BigInteger val)</td>
<td>返回其值为 (this / val) 的 BigInteger，整数相除只保留整数部分</td>
</tr>
<tr>
<td>BigInteger remainder (BigInteger val)</td>
<td>返回其值为 (this % val) 的 BigInteger</td>
</tr>
<tr>
<td>BigInteger [] divideAndRemainder (BigInteger val)</td>
<td>返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组</td>
</tr>
<tr>
<td>BigInteger pow (int exponent)</td>
<td>返回其值为 (this^exponent ) 的 BigInteger</td>
</tr>
</tbody>
</table>
<p><a name="CkjpY"></a></p>
<h2 id="bigdecimal类">BigDecimal类</h2>
<p>一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类 。BigDecimal 类支持**不可变的、任意精度的有符号十进制定点数 **。</p>
<ul>
<li>构造器:
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal (String val)</li>
</ul>
</li>
<li>常用方法:</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>public BigDecimal add (BigDecimal augend)</td>
<td>相加</td>
</tr>
<tr>
<td>public BigDecimal subtract (BigDecimal subtrahend)</td>
<td>相减</td>
</tr>
<tr>
<td>public BigDecimal multiply (BigDecimal multiplicand)</td>
<td>乘法</td>
</tr>
<tr>
<td>public BigDecimal divide (BigDecimal divisor, int scale, int roundingMode)</td>
<td>除法</td>
</tr>
</tbody>
</table>
<p><a name="rYWIT"></a></p>
<h1 id="枚举类">枚举类</h1>
<p><a name="swORn"></a></p>
<h2 id="枚举类的使用">枚举类的使用</h2>
<p>类的对象只能有有限个，例如星期、性别、季节等，当需要定义一组常量时，强烈建议使用枚举类<br>
<a name="VJCM8"></a></p>
<h2 id="枚举类定义">枚举类定义</h2>
<ul>
<li>JDK1.5之前需要自定义枚举类
<ol>
<li>声明对象的属性，private final修饰</li>
<li>私有化类的构造器，并给属性初始化</li>
<li>提供当前枚举类的多个对象，public static final修饰<code>public static final xxx = new Xxx()</code></li>
<li>其他需求：获取对象属性的getter()和toString()方法</li>
</ol>
</li>
<li>JDK1.5及之后Enum关键字来定义枚举类
<ol>
<li>提供当前枚举类对象，用&quot;,&quot;隔开对象，最后一个对象用&quot;;&quot;结尾，系统自动添加public static final修饰，必须在枚举类的第一行声明枚举类对象</li>
<li>声明属性</li>
<li>私有化构造器</li>
<li>默认toString()打印对象名<br />枚举类只有一个对象，则可以作为一种单例模式的实现方式</li>
</ol>
</li>
</ul>
<p>enum默认继承于java.lang.Enum所以不能再继承其他类，JDK1.5中可以在switch表达式中使用Enum定义的枚举类对象作为表达式，case子句可以直接使用枚举值的名字，无需添加枚举类作为限定<br>
<a name="YD8MB"></a></p>
<h2 id="枚举类主要方法">枚举类主要方法</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>toString</strong></td>
<td>得到当前枚举常量的名称</td>
</tr>
<tr>
<td><strong>valueOf(String str)</strong></td>
<td>返回枚举类中对象名是str的对象</td>
</tr>
<tr>
<td><strong>values()</strong></td>
<td>返回枚举类的对象数组</td>
</tr>
<tr>
<td>equals()</td>
<td>在枚举类中可以直接使用&quot;&quot;来比较两个枚举类是否相同，Enum提供这个equals方法，也是直接用&quot;<br />&quot;实现的，它的存在是为了在Set、List和Map中使用，equals()是不可变的</td>
</tr>
<tr>
<td>hashCode</td>
<td>Enum()实现了hashCode()来与equals()保持一致，也不可变</td>
</tr>
<tr>
<td>getDeclaringClass</td>
<td>得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型</td>
</tr>
<tr>
<td>name</td>
<td>得到当前枚举常量的名称，建议优先使用toString()</td>
</tr>
<tr>
<td>ordinal</td>
<td>得到当前枚举常量的次序</td>
</tr>
<tr>
<td>compareTo</td>
<td>枚举类型实现了comparable接口，这样可以比较两个枚举常量的大小</td>
</tr>
<tr>
<td>clone</td>
<td>枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()</td>
</tr>
</tbody>
</table>
<p><a name="ZGCDu"></a></p>
<h2 id="枚举类实现接口">枚举类实现接口</h2>
<ol>
<li>Enum 类名 implements 接口名 接着实现对应方法</li>
<li>让枚举类中的对象分别实现抽象方法</li>
</ol>
<pre><code class="language-java">对象名(){
    重写方法;
}

interface info{
	void show();
}
//枚举类
enum Season1  implements info{
	SPRING(&quot;春天&quot;, &quot;春暖花开&quot;){
	public void show() {
		System.out.println(&quot;春天在哪里？&quot;);
	}
	},
	SUMMER(&quot;夏天&quot;, &quot;夏日炎炎&quot;)
	{
		public void show() {
			System.out.println(&quot;生如夏花&quot;);
		}
	}	,
	AUTUTO(&quot;秋天&quot;, &quot;硕果累累&quot;)
	{
		public void show() {
			System.out.println(&quot;秋天是用来分手的季节&quot;);
		}
	},
	WINTER(&quot;冬天&quot;, &quot;白雪皑皑&quot;)
	{
		public void show() {
			System.out.println(&quot;冬天里的一把火&quot;);
		}
	};
	
	//1.提供类的属性，声明为private final
	private final String seasonName;
	private final String seasonDesc;
	//2.声明为final的属性，在构造器中初始化
	private Season1(String seasonName,String seasonDesc) {
		this.seasonName = seasonName;
		this.seasonDesc = seasonDesc;
	}
	//3.通过公共的方法来调用属性
	public final String getSeasonName() {
		return seasonName;
	}
	public final String getSeasonDesc() {
		return seasonDesc;
	}
	
	@Override
	public String toString() {
		return &quot;Season [seasonName=&quot; + seasonName + &quot;, seasonDesc=&quot; + seasonDesc + &quot;]&quot;;
	}
}
</code></pre>
<p><a name="oSL9O"></a></p>
<h1 id="注解">注解</h1>
<p><a name="AjH7T"></a></p>
<h2 id="简介">简介</h2>
<p>JDK1.5开始支持</p>
<ul>
<li>注解(Annotation)：其实就是代码里的特殊标记，这些标记可以在编译，类加载运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在原文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</li>
<li>注解可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的&quot;name = value&quot;对中</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的Bean和切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等</li>
<li>框架 = 注解 + 反射 + 设计模式<br>
<a name="KUVjY"></a></li>
</ul>
<h2 id="常见annotation实例">常见Annotation实例</h2>
<p><a name="jV9Ze"></a></p>
<h3 id="实例一生成文档的相关注解">实例一：生成文档的相关注解</h3>
<p>@author：标明开发该类模块的作者 多个作者之间使用分割<br />@version：标明该类模块的版本<br />@see：参考转向也就是相关主题<br />@since：从哪个版本开始增加的<br />@param：对方法中某参数的说明 如果没有参数就不能写<br />@return：对方法返回值的说明 如果方法的返回值类型是 void 就不能写<br />@exception：对方法可能抛出的异常进行说明 如果方法没有用 throws 显式抛出的异常就不能写其中：@param @return 和 @exception 这三个标记都是只用于方法的 。<br />@param的格式要求：@param 形参名 形参类型 形参说明<br />@return的格式要求：@return 返回值类型 返回值说明<br />@exception的格式要求：@exception 异常类型 异常说明<br />@param和 @exception 可以并列多个<br>
<a name="yEQZ4"></a></p>
<h3 id="实例二在编译时进行格式检查">实例二：在编译时进行格式检查</h3>
<p>@Override: 限定重写父类方法 , 该注解只能 用于方法<br />@Deprecated : 用于表示所修饰的元素类 , 方法等已过时。通常是因为所修饰的结构危险或存在更好的选择<br />@SuppressWarnings : 抑制编译器警告<br>
<a name="RunjG"></a></p>
<h3 id="实例三跟踪代码依赖性实现替代配置文件功能">实例三：跟踪代码依赖性，实现替代配置文件功能</h3>
<p>Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中部署</p>
<pre><code class="language-java">@WebServlet(&quot;/login&quot;)
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L；
	protected void doGet(HttpServletRequest request , HttpServletResponse response) throws ServletException, IOException{}
	protected void doPost(HttpServletRequest request , HttpServletResponse response) throws ServletException, IOException {
		doGet(request , response);
	}
}
</code></pre>
<p>旧版web.xml文件</p>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;
	&lt;url-pattern &gt;/login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p><a name="IITiD"></a></p>
<h2 id="自定义annotation">自定义Annotation</h2>
<ul>
<li>定义新的 Annotation类型使用@interface关键字</li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。 我们称为配置参数。类型只能是八种基本数据类型、String 类型、Class 类型、enum 类型、Annotation 类型以上所有类型的数组 。</li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值 指定成员变量的初始值可使用 default 关键字</li>
<li>如果只有一个参数成员建议使用参数名为value</li>
<li>如果定义的注解含有配置参数那么使用时必须指定参数值除非它有默认值。格式是&quot;参数名=参数值&quot;如果只有一个参数成员且名称为value可以省略&quot;value=&quot;</li>
<li>没有成员定义的 Annotation 称为标记包含成员变量的 Annotation 称为元数据 Annotation</li>
<li>注意：自定义注解必须配上注解的信息处理流程才有意义 。</li>
</ul>
<pre><code class="language-java">@MyAnnotation(value=&quot;尚硅谷&quot;)
public class MyAnnotationTest {
	public static void main(String[] args ){
		Class clazz = MyAnnotationTest.class
		Annotation a = clazz.getAnnotation(MyAnnotation.class);
		MyAnnotation m = (MyAnnotation) a;
		String info = m.value();
		System.out.println(info);
	}
}
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.PARAMETER})
@interface MyAnnotation{	
	String value() default &quot;&quot;;
}
</code></pre>
<p><a name="mX1LV"></a></p>
<h2 id="jdk中的元注解">JDK中的元注解</h2>
<p>JDK的元Annotation用于修饰其他Annotation定义<br />JDK5.0提供了4个标准的meta-annotation类型，分别为：</p>
<ul>
<li><strong>Retention</strong>:只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期@Retention包含一个RetentionPolicy类型的成员变量，使用时必须为该value成员变量指定值
<ul>
<li>RetentionPolicy.SOURCE：在源文件中有效(即源文件保留)，编译器直接丢弃这种策略的注解</li>
<li>RetentionPolicy.CLASS：在class文件中有效(即class保留)，当运行Java程序时，JVM不会保留注解，这是默认值</li>
<li>RetentionPolicy.RUNTIME：：在运行时有效(即运行时保留)，当运行Java程序时，JVM会保留住时，程序可以通过反射获取该注解</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646061037824-eeae0cf5-9e2e-4caa-a076-0e43b485ff1f-20220312141124790-20220312152128036.png" alt="image.png" loading="lazy"></figure>
<ul>
<li><strong>Target</strong>：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量
<ul>
<li>ElementType.CONSTRUCTOR：用于描述构造器</li>
<li>ElementType.FIELD：用于描述域</li>
<li>ElementType.LOCAL_VARIABLE：用于描述局部变量</li>
<li>ElementType.METHOD：用于描述方法</li>
<li>ElementType.PACKAGE：用于描述包</li>
<li>ElementType.PARAMETER：用于描述参数</li>
<li>ElementType.TYPE：用于描述类、接口(包括注解类型)或enum声明</li>
</ul>
</li>
<li>Documented：用于指定被该元Annotation修饰的Annotation类将被Javadoc工具提取成文档。默认情况下，javadoc是不包括注解的
<ul>
<li>定义为Documented的注解必须设置Retention值位RUNTIME</li>
</ul>
</li>
<li>Inherited：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解
<ul>
<li>比如把标有@Inherited注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解</li>
<li>实际应用中使用较少<br>
<a name="sSHTR"></a></li>
</ul>
</li>
</ul>
<h2 id="通过反射获取注解信息">通过反射获取注解信息</h2>
<ul>
<li>JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口 , 该接口代表程序中可以接受注解的程序元素</li>
<li>当一个 Annotation 类型被定义为运行时 Annotation后 , 该注解才是运行时可见 , 当class文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取</li>
<li>程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646061094114-b0da31e8-0854-4e5a-b349-4b4d1788b298-20220312141124830-20220312152128072.png" alt="image.png" loading="lazy"><br>
<a name="PpXzs"></a></p>
<h2 id="jdk80中新特性">JDK8.0中新特性</h2>
<p><a name="uBPzT"></a></p>
<h3 id="jdk80之前">JDK8.0之前</h3>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646061154933-2f0cdd6d-946f-45f6-9da7-7e443e2fadaf-20220312141124860-20220312152128097.png" alt="image.png" loading="lazy"><br>
<a name="hiDQD"></a></p>
<h3 id="jdk80及之后">JDK8.0及之后</h3>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646061159411-9d7ea6af-7f16-4c75-848b-220d9e3561f0-20220312141124891-20220312152128112.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646061164527-2e1095ff-f3de-4ba8-a1b1-5c6d4b723050-20220312141124915-20220312152128157.png" alt="image.png" loading="lazy"><br>
<a name="lOLRZ"></a></p>
<h3 id="类型注解">类型注解</h3>
<p>JDK1.8 之后，关于元注解 <a href="/Target">@Target </a> 的参数类型ElementType枚举值多了两个：TYPE_PARAMETER, TYPE_USE。</p>
<ul>
<li>在 Java 8 之前 注解只能是在声明的地方所使用 Java 8 开始 注解可以应用在任何地方</li>
<li>ElementType TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中如泛型声明 。</li>
<li>ElementType TYPE_USE 表示该注解能写在使用类型的任何语句中 。</li>
</ul>
<p>TYPE_PARAMETER</p>
<pre><code class="language-java">public class TestTypeDefine&lt;@TypeDefine() U&gt;{
	private U u;
	public &lt;@TypeDefine() T&gt; void test(T t){
		
	}
}
@Target({ElementType.TYPE_PARAMETER})
@interface TypeDefine{
}
</code></pre>
<p>TYPE_USE</p>
<pre><code class="language-java">@MyAnnotation
public class AnnotationTest&lt;U&gt; {
	@MyAnnotation
	private String name;
	public static void main(String[] args){
		AnnotationTest&lt;@MyAnnotation String&gt; t = null;
		int a = (@MyAnnotation int) 2L;
		@MyAnnotation
		int b = 10;
	}
	public static &lt;@MyAnnotation T&gt; void method(T t){
	}
	public static void test(@MyAnnotation String arg) throws @MyAnnotation Exception{
	}
}
@Target(ElementType.TYPE_USE)
@interface MyAnnotation{
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://yeyuan1107.github.io/post/java-duo-xian-cheng/" class="post-title gt-a-link">
                    Java多线程
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://yeyuan1107.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>

<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Java8新特性 | YBLOG</title>

<link rel="shortcut icon" href="https://yeyuan1107.github.io/favicon.ico?v=1657077232781">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://yeyuan1107.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
        <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script> 
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            YBLOG
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1657077232781"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java8新特性
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-12-03 ·
                    </time>
                    
                        <a href="https://yeyuan1107.github.io/tag/wZpx5Scef/" class="post-tags">
                            # Java
                        </a>
                    
                </div>
                <div class="post-content">
                    <p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Java8%E6%96%B0%E7%89%B9%E6%80%A7.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=rmlRE&amp;originHeight=786&amp;originWidth=1391&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br>
<a name="sq1OB"></a></p>
<h1 id="lambda表达式">Lambda表达式</h1>
<p>Lambda是一种匿名函数，我们可以吧Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简介、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。本质上是一个接口的实例，且该接口应为函数式接口<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=X0SW6&amp;originHeight=611&amp;originWidth=1089&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br>
<a name="zKeh9"></a></p>
<h2 id="语法格式">语法格式</h2>
<p>-&gt;：lambda操作符或箭头操作符<br />-&gt;左边：lambda的形参列表，其实就是抽象方法的形参列表，类型可以省略<br />-&gt;右边：lambda体，其实就是重写的抽象方法的方法体<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Lambda%E6%A0%BC%E5%BC%8F-1.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=oWsbD&amp;originHeight=633&amp;originWidth=1321&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Lambda%E6%A0%BC%E5%BC%8F-2.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=QuenH&amp;originHeight=660&amp;originWidth=1358&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br />上述Lambda表达式中的参数类型都是由编译器推断得出的。Lambda表达式中无需指定类型，程序依然可以编译，这是因为javac根据程序的上下文，在后台推断出了参数的类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的&quot;类型推断&quot;<br>
<a name="KdiLM"></a></p>
<h1 id="函数式接口">函数式接口</h1>
<ul>
<li>只包含一个抽象方法的接口，称为函数式接口</li>
<li>可以在一个接口上使用@FunctionalInterface注解，这样做可以检查它是否是一个函数式接口。同时javadoc也会包含一条生命，说明这个接口是一个函数式接口</li>
<li>你可以通过Lambda表达式来创建该接口的对象(若Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明)</li>
<li>java.util.function包下定义了Java8的丰富的函数式接口<br>
<a name="vCcIC"></a></li>
</ul>
<h2 id="java内置四大核心函数式接口">Java内置四大核心函数式接口</h2>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>Consumer<T>消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T 的对象应用操作，包含方法: void accept(T t)</td>
</tr>
<tr>
<td>Supplier<T>供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T 的对象，包含方法: T get()</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法: R apply(T t)</td>
</tr>
<tr>
<td>Predicate<T>断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法: boolean test(T t)</td>
</tr>
</tbody>
</table>
<p><a name="KvzwN"></a></p>
<h2 id="其他接口">其他接口</h2>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=ocPDU&amp;originHeight=748&amp;originWidth=1372&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br>
<a name="cOADw"></a></p>
<h1 id="方法引用">方法引用</h1>
<ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li>
<li>方法引用可以看作是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的语法糖</li>
<li><strong>实现接口的抽象方法的参数列表喝返回值类型，必须与方法引用的方法的参数列表喝返回值类型保持一致</strong></li>
<li>格式：<code>类名(或对象名)::方法名</code>
<ul>
<li>对象::非静态方法名</li>
<li>类::静态方法名
<ul>
<li>上述两种要求<strong>实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表喝返回值类型保持一致</strong></li>
</ul>
</li>
<li><strong>类::非静态方法名</strong>
<ul>
<li>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数时)：使用该格式。第一个参数所属类::方法名。比如<code>BiPredicate&lt;String, String&gt; bp = (x,y) -&gt; x.equals(y)</code>使用<code>BiPredicate&lt;String, String&gt; bp = String::equals</code><br>
<a name="Q1T7h"></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="构造器引用">构造器引用</h1>
<p>格式：ClassName::new</p>
<ul>
<li>与函数式接口相结合，自动与函数式接口中方法兼容。</li>
<li>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=wgB6M&amp;originHeight=258&amp;originWidth=1462&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br>
<a name="Lt3zJ"></a></p>
<h1 id="数组引用">数组引用</h1>
<p>格式：type[]::new</p>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=izWLH&amp;originHeight=275&amp;originWidth=1344&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br>
<a name="RGhLs"></a></p>
<h1 id="stream-api">Stream API</h1>
<ul>
<li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到 Java 中。这是目前为止对 Java 类库最好的补充，因为 Stream API 可以极大提供 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之， Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
<li>Stream 和 Collection 集合的区别： Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。 前者是主要面向内存，存储在内存中，后者主要是面向 CPU ，通过 CPU 实现计算。</li>
<li><strong>Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列</strong>
<ul>
<li>Stream自己不会存储元素</li>
<li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</li>
<li>Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行<br>
<a name="g6aIc"></a></li>
</ul>
</li>
</ul>
<h2 id="stream操作的三个步骤">Stream操作的三个步骤</h2>
<ol>
<li>创建Stream：一个数据源，获取一个流</li>
<li>中间操作：一个中间操作链，对数据源的数据进行处理</li>
<li>终止操作(终端操作)：一旦执行终止操作，就执行中间操作脸，并产生结果。之后不会再被使用<br>
<a name="N4STY"></a></li>
</ol>
<h3 id="创建">创建</h3>
<ol>
<li>
<p>方式一：通过集合<br />Java8中的Collection接口被扩展，提供了两个获取流的方法</p>
<ul>
<li>default Stream<E> stream()：返回一个顺序流</li>
<li>default Stream<E> parallelStream()：返回一个并行流</li>
<li><code>集合名.stream()</code>或<code>集合名.parallelStream()</code></li>
</ul>
</li>
<li>
<p>方式二：通过数组<br />Java8中的Arrays的静态方法stream()可以获取数据流</p>
<ul>
<li>static <T> Stream<T> stream(T[] array)：返回一个流</li>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
<li><code>Arrays.stream(数组名)</code></li>
</ul>
</li>
<li>
<p>方式三：通过Stream的of()<br />可以调用Stream类静态方法of()，通过显示值创建一个流。他可以接收任意数量的参数</p>
<ul>
<li>public static<T> Stream<T> of(T...values)：返回一个流</li>
<li><code>Stream.of(数值一, 数值二, ..., 数值n)</code></li>
</ul>
</li>
<li>
<p>方式四：创建无限流<br />可以使用静态方法iterate()和generate()创建无限流</p>
<ul>
<li>迭代：public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</li>
<li>生成：public static<T> Stream<T> generate(Supplier<T> s)</li>
</ul>
</li>
</ol>
<pre><code class="language-java">public void test4() {
	//迭代
	//public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)
	Stream&lt;Integer&gt; stream = Stream.iterate(0, x-&gt; x +2);
	stream.limit(10).forEach(System.out::println);
	//生成
	//public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
	Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);
	stream1.limit(10).forEach(System.out::println);
}
</code></pre>
<p><a name="k30k4"></a></p>
<h3 id="中间操作">中间操作</h3>
<p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为&quot;惰性求值&quot;</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>筛选与切片</td>
<td></td>
</tr>
<tr>
<td>filter(Predicate p)</td>
<td>接收Lambda 从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与 limit(n) 互补</td>
</tr>
<tr>
<td>映射</td>
<td></td>
</tr>
<tr>
<td><strong>map(Function f)</strong></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td><strong>flatMap(Function f)</strong></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
<tr>
<td>排序</td>
<td></td>
</tr>
<tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody>
</table>
<p><a name="tLBPz"></a></p>
<h3 id="终止操作">终止操作</h3>
<ul>
<li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如： List 、 Integer ，甚至是 void 。</li>
<li>流进行了终止操作后，不能再次使用。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>匹配与查找</td>
<td></td>
</tr>
<tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch (Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
<tr>
<td>归约</td>
<td></td>
</tr>
<tr>
<td>reduce(T iden, BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值。返回 T，iden为初始值</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
<tr>
<td>收集</td>
<td></td>
</tr>
<tr>
<td>collect(Collector c)</td>
<td>将流转换为其他形式。接收一个Collector接口的实现，用于给 Stream 中元素做汇总的方法。Collector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。另外，Collectors实用类提供了很多静态方法，可以方便地创建常见的收集器类型</td>
</tr>
</tbody>
</table>
<p><a name="uAaOy"></a></p>
<h4 id="collectors">Collectors</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Collectors-20220312152856830.png" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Collectors-1-20220312152856879.png" alt="" loading="lazy"><br>
<a name="XznS0"></a></p>
<h1 id="optional类">Optional类</h1>
<p>为了解决空指针异常而引入的一个容器</p>
<ul>
<li>Optional<T> 类 (java.util.Optional) 是一个容器类 它可以保存类型 T 的值， 代表这个值存在 。或者仅仅保存 null ，表示这个值不存在 。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且 可以避免空指针异常 。</li>
<li>Optional 类的 Javadoc 描述如下：这是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true ，调用 get() 方法会返回该对象。<br>
<a name="vnyU9"></a></li>
</ul>
<h2 id="optional类方法">Optional类方法</h2>
<ul>
<li>Optional 提供很多有用的方法，这样我们就不用显式进行空值检测 。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建 Optional 类对象的方法</td>
<td></td>
</tr>
<tr>
<td>Optional.of(T t)</td>
<td>创建一个 Optional 实例， t 必须非空</td>
</tr>
<tr>
<td>Optional.empty()</td>
<td>创建一个空的 Optional 实例</td>
</tr>
<tr>
<td>Optional.ofNullable(T t)</td>
<td>t 可以为 null</td>
</tr>
<tr>
<td>判断 Optional 容器中是否包含对象</td>
<td></td>
</tr>
<tr>
<td>boolean isPresent()</td>
<td>判断是否包含对象</td>
</tr>
<tr>
<td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td>
<td>如果有值，就执行 Consumer接口的实现代码，并且该值会作为参数传给它。</td>
</tr>
<tr>
<td>获取 Optional 容器的对象</td>
<td></td>
</tr>
<tr>
<td>T get()</td>
<td>如果调用对象包含值，返回该值，否则抛异常</td>
</tr>
<tr>
<td>T orElse(T other)</td>
<td>如果有值则将其返回，否则返回指定的 other 对象。</td>
</tr>
<tr>
<td>T orElseGet(Supplier&lt;? extends T&gt; other)</td>
<td>如果有值则将其返回，否则返回由Supplier 接口实现提供的对象。</td>
</tr>
<tr>
<td>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</td>
<td>如果有值则将其返回，否则抛出由 Supplier 接口实现提供的异常。</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">@Test
public void test1() {
	Boy b = new Boy(&quot;张三&quot;);
	Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGirlFriend());
	//如果女朋友存在就打印女朋友的信息
	opt.ifPresent(System.out::println);
}
@Test
public void test2() {
	Boy b = new Boy(&quot;张三&quot;);
	Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGirlFriend());
	//如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了
	Girl girl = opt.orElse(new Girl(&quot;嫦娥&quot;));
	System.out.println(&quot;他的女朋友是:&quot;+ girl.getName());
}
@Test
public void test3(){
	Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;,8888));
	//判断 opt 中员工对象是否满足条件，如果满足就保留，否则返回空
	Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;10000);
	System.out.println(emp);
}
@Test
public void test4(){
	Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;, 8888));
	//如果 opt 中员工对象不为空，就涨薪 10%
	Optional&lt;Employee&gt; emp = opt.map(e -&gt;e.setSalary(e.getSalary()%1.1); return e;});
	System.out.println(emp);
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://yeyuan1107.github.io/post/java-fan-she/" class="post-title gt-a-link">
                    Java反射
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://yeyuan1107.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>

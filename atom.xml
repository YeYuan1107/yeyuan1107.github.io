<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yeyuan1107.github.io</id>
    <title>YBLOG</title>
    <updated>2022-07-06T03:14:16.031Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yeyuan1107.github.io"/>
    <link rel="self" href="https://yeyuan1107.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yeyuan1107.github.io/images/avatar.png</logo>
    <icon>https://yeyuan1107.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, YBLOG</rights>
    <entry>
        <title type="html"><![CDATA[常见排序算法（下）]]></title>
        <id>https://yeyuan1107.github.io/post/chang-jian-pai-xu-suan-fa-xia/</id>
        <link href="https://yeyuan1107.github.io/post/chang-jian-pai-xu-suan-fa-xia/">
        </link>
        <updated>2022-06-28T06:39:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计数排序">计数排序</h1>
<ul>
<li>准备待排序的数组中最大-max和最小-min的元素，准备一个长度为（max-min+1）辅助计数数组help。</li>
<li>分配:统计原数组中值为arr[i]的元素出现的次数，存入辅助计数数组对应arr[i]-min的索引位置处。</li>
<li>收集: 收集:根据辅助数组的反向从index=0开始填充目标数组。循环判断辅助数组索引为i的元素值help[i]是否&gt;0，如果是，则原数组arr[index++]=i + min</li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        // stream 获取最大最小值方法
        int max = Arrays.stream(nums).max().getAsInt();
        int min = Arrays.stream(nums).min().getAsInt();
        int[] support = new int[max - min + 1];
        for(int num : nums){
            support[num - min]++;
        }
        int index = 0;
        for(int i = 0 ; i &lt; support.length ; i++){
            int times = support[i];
            while(times-- &gt; 0){
                nums[index++] = i + min;
            }
        }
        return nums;
    }
}
</code></pre>
<h1 id="桶排序">桶排序</h1>
<p>桶排序（Bucket sort）又被称为箱排序。前面讲的计数排序，最大值和最小值相差多少就准备多少个桶，试想如果最大值和最小值相差过大的话，会造成桶的数量过多，空间复杂度大幅度提升。计数排序不再适用，此时可以采用桶排序。<br>
稳定性：桶排序是否稳定取决于每个桶采用的排序算法，因为桶排序可以做到稳定，所以桶排序是稳定的排序算法。<br>
桶排序详细过程如下：</p>
<ul>
<li>准备待排序的数组中最大-max和最小-min的元素，准备一个桶容器，每个桶里放的元素用list存储，因为每个桶存放元素的数量是不固定的。桶的数量为k=(max-min)/arr.length+1。</li>
<li>遍历数组 arr，按一定的映射规则（这类似于哈希表）计算每个元素放的桶位置，并将待排序元素划分到不同的桶。</li>
<li>每个桶各自排序，一般采用快速排序。</li>
<li>顺序遍历桶集合，把排序好的元素回写进原数组。</li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        int max = Arrays.stream(nums).max().getAsInt();
        int min = Arrays.stream(nums).min().getAsInt();
        // 计算桶数组的长度
        int bucketNums = (max - min) / nums.length + 1;
        List&lt;Integer&gt;[] buckets = new List[bucketNums];
        // 计算每个桶的装载范围
        int bucketRange = (max - min + 1) / bucketNums;
        for(int i = 0 ; i &lt; buckets.length ; i++){
            buckets[i] = new ArrayList&lt;&gt;();
        }
        for(int num : nums){
            // 计算当前数值应该放入到哪个桶中
            int index = (num - min) / (bucketRange + 1);
            buckets[index].add(num);
        }
        int index = 0;
        for(List&lt;Integer&gt; list : buckets){
            Collections.sort(list);
            for (Integer integer : list) {
                nums[index++] = integer;
            }
        }
        return nums;

    }
}
</code></pre>
<h1 id="基数排序">基数排序</h1>
<ul>
<li>有负数不行</li>
<li>将所有待排序非负整数统一为位数相同的整数，位数较少的前面补零。一般用10进制，也可以用16进制甚至2进制，所有的前提是能够找到最大值，得到最长的位数，设k进制下最长为位数为d。实际上相同位数上的值就是要比较的多个键。</li>
<li>对相同的位数上的数值按照大小进行稳定排序（因为稳定排序能够将上一次排序的成果保留下来。例如十位数的排序过程能保留个位数的排序成果，百位数的排序过程能保留十位数的排序成果）。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。
<ul>
<li>MSD：先从高位开始进行排序，在每个关键字上，可采用计数排序。</li>
<li>LSD：先从低位开始进行排序，在每个关键字上，可采用桶排序。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Solution {
    int[] digit;
    public int[] sortArray(int[] nums) {
        int[] help = new int[10];
        int[] temp = new int[nums.length];
        int max = Arrays.stream(nums).max().getAsInt();
        int len = String.valueOf(max).length();
        digit = new int[len];
        digit[0] = 1;
        for(int i = 1 ; i &lt; len ; i++){
            digit[i] = digit[i - 1] * 10;
        }
        for(int k = 1 ; k &lt;= len ; k++){
            Arrays.fill(help, 0);
            for(int num : nums){
                help[getNum(num, k)]++;
            }
            // 通过help数组直接找到对应的index
            for(int i = 1; i &lt; help.length ; i++){
                help[i] += help[i - 1];
            }
            // 一定要从后向前遍历，保证相对顺序不变
            for(int i = nums.length - 1 ; i &gt;= 0 ; i--){
                temp[help[getNum(nums[i], k)] - 1] = nums[i];
                help[getNum(nums[i], k)]--;
            }
            for(int i = 0 ; i &lt; nums.length ; i++){
                nums[i] = temp[i];
            }

        }
        return nums;


    }

    /**
     * 用于计算num从低到高低k位的数值
     * @param num
     * @param k
     * @return k位数值
     */
    public int getNum(int num, int k){
        return (num / digit[k - 1]) % 10;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见排序算法（上）]]></title>
        <id>https://yeyuan1107.github.io/post/chang-jian-pai-xu-suan-fa-shang/</id>
        <link href="https://yeyuan1107.github.io/post/chang-jian-pai-xu-suan-fa-shang/">
        </link>
        <updated>2022-06-28T02:38:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文章总结了七种比较排序算法</p>
</blockquote>
<h1 id="冒泡排序">冒泡排序</h1>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
<li><code>O(n2)</code></li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        for(int i = 0 ; i &lt; len - 1 ; i++){
            boolean flag = true;
            for(int j = 0 ; j &lt; len - 1 - i ; j++){
                if(nums[j] &gt; nums[j + 1]){
                    swap(nums, j, j+1);
                    flag = false;
                }
            }
            if (flag) break;
        }
        return nums;
    }

    public void swap(int[] nums, int left, int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}

</code></pre>
<h1 id="选择排序">选择排序</h1>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
<li><code>O(n2)</code></li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        for(int i = 0 ; i &lt; len - 1 ; i++){
            int index = i;
            for(int j = i + 1 ; j &lt; len ; j++){
                if(nums[j] &lt; nums[index]){
                    index = j;
                }
            }
            swap(nums, i, index);
        }
        return nums;
    }

    public void swap(int[] nums, int left, int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
</code></pre>
<h1 id="插入排序">插入排序</h1>
<ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
<li><code>O(n2)</code></li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        for(int i = 0 ; i &lt; len ; i++){
            int temp = nums[i];
            int j = i - 1;
            while(j &gt;= 0 &amp;&amp; nums[j] &gt; temp){
                nums[j + 1] = nums[j];
                j--;
            }
            nums[j + 1] = temp;
        }
        return nums;
    }
}
</code></pre>
<h1 id="希尔排序">希尔排序</h1>
<ul>
<li>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序。</li>
</ul>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        int temp;
        for(int step = len / 2 ; step &gt;= 1 ; step /= 2){
            for(int i = step ; i &lt; len ; i++){
                temp = nums[i];
                int j = i - step;
                while(j &gt;= 0 &amp;&amp; nums[j] &gt; temp){
                    nums[j + step] = nums[j];
                    j -= step;
                }
                nums[j + step] = temp;
            }
        }
        return nums;
    }
}
</code></pre>
<h1 id="归并排序">归并排序</h1>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        return mergeSort(nums, 0, nums.length);
    }

    public int[] mergeSort(int[] nums, int begin, int end){
        if(begin &gt;= end) return new int[0];
        if(begin + 1 == end) return new int[]{nums[begin]};
        int mid = (end + begin) &gt;&gt; 1;
        int[] left = mergeSort(nums, begin, mid);
        int[] right = mergeSort(nums, mid, end);
        int[] ans = new int[end - begin];
        int index = 0, lPointer = 0, rPointer = 0;
        while(lPointer &lt; left.length || rPointer &lt; right.length){
            if(lPointer &gt;= left.length){
                ans[index++] = right[rPointer++];
            }else if(rPointer &gt;= right.length){
                ans[index++] = left[lPointer++];
            }else{
                if(left[lPointer] &gt; right[rPointer]){
                    ans[index++] = right[rPointer++];
                }else{
                    ans[index++] = left[lPointer++];
                }
            }
        }
        return ans;
    }
}
</code></pre>
<h1 id="快速排序">快速排序</h1>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length);
        return nums;
    }

    public void quickSort(int[] nums, int begin, int end){
        if(begin &gt;= end) return;
        if(begin + 1 == end) return;
        // 随机选取一个值作为基准值
        int index = new Random().nextInt(end - begin) + begin;
        swap(nums, begin, index);
        int cur = begin;
        // 比基准值小的放到数组的左边，大的放到右边
        for(int i = begin ; i &lt; end ; i++){
            if(nums[i] &lt;= nums[begin]){
                swap(nums, cur, i);
                cur++;
            }
        }
        swap(nums, begin, cur - 1);
        // 分开排序
        quickSort(nums, begin, cur - 1);
        quickSort(nums, cur, end);

    }

    public void swap(int[] nums, int left, int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
</code></pre>
<h1 id="堆排序">堆排序</h1>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        for(int i = (nums.length - 2) / 2 ; i &gt;= 0 ; i--){
            buildBigHeap(nums, i, nums.length);
        }
        for(int i = nums.length - 1 ; i &gt;= 0 ; i--){
            swap(nums, 0, i);
            buildBigHeap(nums, 0, i);
        }
        return nums;
    }

    public void buildBigHeap(int[] nums, int begin, int end){
        int childIndex;
        for(int i = begin ; i * 2 + 1 &lt; end ; i = childIndex){
            childIndex = i * 2 + 1;
            if(childIndex + 1 &lt; end &amp;&amp; nums[childIndex] &lt; nums[childIndex + 1]){
                childIndex += 1;
            }
            if(nums[childIndex] &gt; nums[i]){
                swap(nums, i, childIndex);
            }else{
                break;
            }
        }
    }

    public void swap(int[] nums, int left, int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
</code></pre>
<ul>
<li>堆的下沉和上浮方法，上浮方法用于插入建堆，下沉用于直接建堆</li>
</ul>
<pre><code class="language-java">
public void sink(int[] nums, int begin, int end){
    int childIndex;
    for(int i = begin ; i * 2 + 1 &lt; end ; i = childIndex){
        childIndex = i * 2 + 1;
        if(childIndex + 1 &lt; end &amp;&amp; nums[childIndex] &lt; nums[childIndex + 1]){
            childIndex += 1;
        }
        if(nums[childIndex] &gt; nums[i]){
            swap(nums, i, childIndex);
        }else{
            break;
        }
    }
}

public void flow(int[] nums, int num, int end){
    nums[end] = num;
    int parentIndex;
    for(int i = end ; (i - 1) / 2 &gt;= 0 ; i = parentIndex){
        parentIndex = (i - 1) / 2;
        if(nums[parentIndex] &lt; nums[i]) {
            swap(nums, parentIndex, i);
        }else{
            break;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JMM内存模型]]></title>
        <id>https://yeyuan1107.github.io/post/jmm-nei-cun-mo-xing/</id>
        <link href="https://yeyuan1107.github.io/post/jmm-nei-cun-mo-xing/">
        </link>
        <updated>2022-02-27T13:10:43.000Z</updated>
        <content type="html"><![CDATA[<p><a name="anXft"></a></p>
<h2 id="解决方法">解决方法</h2>
<p><code>sychronized(同步关键字)</code><br />语法</p>
<pre><code class="language-java">synchronized( 对象 ) { 
    要作为原子操作代码
}
</code></pre>
<p>用<code>synchronized</code>解决并发问题</p>
<pre><code class="language-java">static int i = 0;
static Object obj = new Object();
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -&gt; {
        for (int j = 0; j &lt; 5000; j++) {
            synchronized (obj) {
                i++; }
        }
    });
    Thread t2 = new Thread(() -&gt; {
        for (int j = 0; j &lt; 5000; j++) {
            synchronized (obj) {
                i--;
            } 
        }
    });
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    System.out.println(i);
}
</code></pre>
<p>如何理解呢:你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。 <br />当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行count++ 代码。 <br />这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。<br />当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才 可以进入 obj 房间，反锁住门，执行它的 count-- 代码。</p>
<blockquote>
<p>注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对 象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p>
</blockquote>
<ul>
<li>每个类对象都有一个Monitor区，只有在使用<code>synchronized关键字</code>才生效</li>
<li>Owner表示Monitor的所有者，同一时刻只能有一个线程成为Owner
<ul>
<li>当一个线程t1到达，发现Owner为空的，那么该线程就会成为Owner，并且执行<code>monitorenter</code>会对Monitor进行锁定</li>
<li>当一个线程t2到达，发现Owner不为空，且锁定了Monitor，进入EntryList进行等待(阻塞)</li>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646032230273-20f9d2d1-9562-4b2c-a452-6a885fedc887-20220312195457419.png" alt="image.png" loading="lazy"></li>
<li>当t1执行完毕，执行<code>monitorexit</code>，通知EntryList中正在等待的线程，可以来争抢成为新的Owner</li>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646032367951-68e98a2f-4b68-47a1-a257-f20767f9c163-20220312195457498.png" alt="image.png" loading="lazy"></li>
</ul>
</li>
<li>EntryList</li>
<li>WaitSet<br>
<a name="GEFc1"></a></li>
</ul>
<h1 id="可见性">可见性</h1>
<p><a name="FIv42"></a></p>
<h2 id="退不出的循环">退不出的循环</h2>
<p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止:</p>
<pre><code class="language-java">static boolean run = true;

public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(()-&gt;{
        while(run){
            // ....
        } 
    });
	t.start();
    
    Thread.sleep(1000);
	run = false; // 线程t不会如预想的停下来 
}
</code></pre>
<p>为什么呢，分析一下可知</p>
<ol>
<li>初始状态，t线程刚开始从主内存读取了run的值到工作内存，每次循环都需要从主内存中读一次run的值</li>
</ol>
<figure data-type="image" tabindex="3"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646027955406-6a6e180a-fa53-4662-a8ef-820e819eac89-20220312195457562.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li>
</ol>
<figure data-type="image" tabindex="4"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646027980654-54ff16b5-66c5-4779-b3bc-9947169666f7-20220312195457623.png" alt="image.png" loading="lazy"></figure>
<ol start="3">
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646028003664-3197ca78-0ff7-4943-8f1c-f6b1449b5471-20220312195457757.png" alt="image.png" loading="lazy"><br>
<a name="fzTwg"></a></p>
<h2 id="解决方法-2">解决方法</h2>
<p><code>volatile (易变关键字)</code><br />它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到 主存中获取它的值，线程操作 volatile 变量都是直接操作主存<br>
<a name="vL7kO"></a></p>
<h2 id="可见性-2">可见性</h2>
<p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况: <br />上例从字节码理解是这样的:</p>
<pre><code>getstatic			run //线程t获取runtrue
getstatic			run //线程t获取runtrue
getstatic			run //线程t获取runtrue
getstatic			run //线程t获取runtrue
putstatic			run // 线程 main 修改 run 为 false， 仅此一次
getstatic			run // 线程 t 获取 run false
</code></pre>
<p>比较一下之前我们将线程安全时举的例子:两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错</p>
<pre><code>// 假设i的初始值为0
getstatic				i // 线程1-获取静态变量i的值 线程内i=0
getstatic				i // 线程2-获取静态变量i的值 线程内i=0
iconst_1					// 线程1-准备常量1
iadd							// 线程1-自增 线程内i=1
putstatic				i // 线程1-将修改后的值存入静态变量i 静态变量i=1
iconst_1					// 线程2-准备常量1
isub							// 线程2-自减 线程内i=-1
putstatic				i // 线程2-将修改后的值存入静态变量i 静态变量i=-1
</code></pre>
<blockquote>
<p>注意<br>
synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized是属于重量级操作，性能相对更低</p>
<p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了<br>
println中有synchronized关键字，强制当前线程从主存中读取值而不是从告诉缓存中</p>
</blockquote>
<p><a name="Z6Nwy"></a></p>
<h1 id="有序性">有序性</h1>
<p><a name="GIZIJ"></a></p>
<h2 id="诡异的结果">诡异的结果</h2>
<pre><code class="language-java">int num = 0;
boolean ready = false;
// 线程1 执行此方法
public void actor1(I_Result r) {
    if(ready) {
        //r1用来保存结果
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    } 
}

// 线程2 执行此方法
public void actor2(I_Result r) {
	num = 2;
    ready = true;
}
</code></pre>
<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种?<br />有同学这么分析<br />情况1:线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1<br />情况2:线程2 先执行 num = 2，但没来得及执行 ready = true，线程1执行，还是进入 else 分支，结果为1<br />情况3:线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4(因为 num 已经执行过了)<br />但我告诉你，结果还有可能是 0 😁😁😁，信不信吧!<br />这种情况下是:线程2 执行 ready = true，切换到线程1，进入if分支，相加为0，再切回线程2执行num = 2<br />相信很多人已经晕了 😵😵😵</p>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现:<br />借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<pre><code>mvn archetype:generate  -DinteractiveMode=false -
DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-
archetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0
</code></pre>
<p>创建maven项目，提供如下测试类</p>
<pre><code class="language-java">@JCStressTest
//检查感兴趣的结果
@Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)
@State
public class ConcurrencyTest {
    int num = 0;
    boolean ready = false;
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        } 
    }
	@Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
</code></pre>
<p>执行</p>
<pre><code>mvn clean install
java -jar target/jcstress.jar
</code></pre>
<p>会输出我们感兴趣的结果</p>
<pre><code>*** INTERESTING tests
  Some interesting behaviors observed. This is for the plain curiosity.
  2 matching test results.
      [OK] test.ConcurrencyTest
    (JVM args: [-XX:-TieredCompilation])
 Observed state   Occurrences              Expectation  Interpretation
  						0         1,729   ACCEPTABLE_INTERESTING  !!!!
             	1    42,617,915								ACCEPTABLE  ok
             	4     5,146,627								ACCEPTABLE  ok
    [OK] test.ConcurrencyTest
  (JVM args: [])
Observed state   Occurrences							Expectation  Interpretation
             0         1,652   ACCEPTABLE_INTERESTING  !!!!
             1    46,460,657               ACCEPTABLE  ok
             4     4,571,072               ACCEPTABLE  ok
</code></pre>
<p>可以看到，出现结果为 0 的情况有 1729 次，虽然次数相对很少，但毕竟是出现了。<br>
<a name="lZYvh"></a></p>
<h2 id="解决">解决</h2>
<p>volatile 修饰的变量，可以禁用指令重排</p>
<pre><code class="language-java">@JCStressTest
@Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)
@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)
@State
public class ConcurrencyTest {
    int num = 0;
    volatile boolean ready = false;
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        } 
    }
    
	@Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
</code></pre>
<p>结果为</p>
<pre><code>*** INTERESTING tests
  Some interesting behaviors observed. This is for the plain curiosity.
  0 matching test results.
</code></pre>
<p><a name="wGXgF"></a></p>
<h3 id="有序性理解">有序性理解</h3>
<p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p>
<pre><code class="language-java">static int i;
static int j;
// 在某个线程内执行如下赋值操作 
i = ...; // 较为耗时的操作
j = ...;
</code></pre>
<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行 时，既可以是</p>
<pre><code class="language-java">i = ...; // 较为耗时的操作 
j = ...;
</code></pre>
<p>也可以是</p>
<pre><code class="language-java">j = ...;
i = ...; // 较为耗时的操作
</code></pre>
<p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性，例如著名的 double-checked locking 模式实现单例</p>
<pre><code class="language-java">public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    public static Singleton getInstance() {
		// 实例没创建，才会进入内部的 synchronized代码块 
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                // 也许有其它线程已经创建实例，所以再判断一次 
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            } 
        }
        return INSTANCE;
    }
}
</code></pre>
<p>以上实现的特点是</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的， INSTANCE = new Singleton() 对应的字节码为:</p>
<pre><code>0: new           #2						// class cn/itcast/jvm/t4/Singleton
3: dup
4: invokespecial #3						// Method &quot;&lt;init&gt;&quot;:()V
7: putstatic     #4						// Field INSTANCE:Lcn/itcast/jvm/t4/Singleton;
</code></pre>
<p>其中4 7 两步的顺序不是固定的，也许 jvm 会优化为:先将引用地址赋值给 INSTANCE 变量后，再执行 构造方法，如果两个线程 t1，t2 按如下时间序列执行:</p>
<pre><code>时间1 t1 线程执行到 INSTANCE = new Singleton();
时间2 t1 线程分配空间，为Singleton对象生成了引用地址(0 处)
时间3 t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE != null(7 处)
时间4 t2 线程进入getInstance() 方法，发现 INSTANCE != null(synchronized块外)，直接 返回 INSTANCE
时间5 t1 线程执行Singleton的构造方法(4 处)
</code></pre>
<p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例<br />对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才 会真正有效<br>
<a name="ac7Rj"></a></p>
<h2 id="happens-before">happens-before</h2>
<p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结， 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<ul>
<li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li>
</ul>
<pre><code class="language-java">static int x;
static Object m = new Object();
new Thread(()-&gt;{
    synchronized(m) {
		x = 10; 
    }
},&quot;t1&quot;).start();

new Thread(()-&gt;{
    synchronized(m) {
        System.out.println(x);
    }
},&quot;t2&quot;).start();
</code></pre>
<ul>
<li>线程对volatile变量的写，对接下来其他线程对该变量的读可见</li>
</ul>
<pre><code class="language-java">volatile static int x;
new Thread(()-&gt;{
    x = 10;
},&quot;t1&quot;).start();
new Thread(()-&gt;{
    System.out.println(x);
},&quot;t2&quot;).start();
</code></pre>
<ul>
<li>线程start前对变量的写，对该线程开始后对该变量的读可见</li>
</ul>
<pre><code class="language-java">static int x;
x = 10;
new Thread(()-&gt;{
    System.out.println(x);
},&quot;t2&quot;).start();
</code></pre>
<ul>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见(比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束)</li>
</ul>
<pre><code class="language-java">static int x;
Thread t1 = new Thread(()-&gt;{
    x = 10;
},&quot;t1&quot;);
t1.start();

t1.join();
System.out.println(x);
</code></pre>
<ul>
<li>线程 t1 打断 t2(interrupt)前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见(通 过t2.interrupted 或 t2.isInterrupted)</li>
</ul>
<pre><code class="language-java">static int x;
public static void main(String[] args) {
    Thread t2 = new Thread(()-&gt;{
        while(true) {
            if(Thread.currentThread().isInterrupted()) {
                System.out.println(x);
				break; 
            }
        } 
    },&quot;t2&quot;);
	t2.start();
    
    new Thread(()-&gt;{
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
		x = 10;
        t2.interrupt();
    },&quot;t1&quot;).start();
    while(!t2.isInterrupted()) {
        Thread.yield();
    }
    System.out.println(x);
}
</code></pre>
<ul>
<li>对变量默认值(0，false，null)的写，对其它线程对该变量的读可见</li>
<li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z</li>
</ul>
<blockquote>
<p>变量都是指成员变量或静态成员变量<br>
参考: 第17页</p>
</blockquote>
<p><a name="pnhX8"></a></p>
<h1 id="cas与原子类">CAS与原子类</h1>
<p><a name="uALee"></a></p>
<h2 id="cas">CAS</h2>
<p>CAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 +1 操作:</p>
<pre><code class="language-java">// 需要不断尝试 
while(true) {
    int 旧值 = 共享变量 ; // 比如拿到了当前值 0
    int 结果 = 旧值 +1;// 在旧值 0 的基础上增加 1 ，正确结果是 1
    /*
    这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候 
    compareAndSwap 返回 false，重新尝试，直到:
    compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰
    */
    if( compareAndSwap ( 旧值, 结果 )) { 
        // 成功，退出循环
    } 
}
</code></pre>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进 行线程安全保护的一个例子</p>
<pre><code class="language-java">import sun.misc.Unsafe;
import java.lang.reflect.Field;
public class TestCAS {
    public static void main(String[] args) throws InterruptedException {
        DataContainer dc = new DataContainer();
        int count = 5;
        Thread t1 = new Thread(() -&gt; {
    		for (int i = 0; i &lt; count; i++) {
                dc.increase();
            }
        });
        t1.start();
        t1.join();
        System.out.println(dc.getData());
    }
}

class DataContainer {
    private volatile int data;
    static final Unsafe unsafe;
    static final long DATA_OFFSET;
	static { 
        try {
            // Unsafe 对象不能直接调用，只能通过反射获得
            Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); 
            theUnsafe.setAccessible(true);
            unsafe = (Unsafe) theUnsafe.get(null);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new Error(e);
        } try {
            // data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性
            DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(&quot;data&quot;));
        } catch (NoSuchFieldException e) {
            throw new Error(e);
        } 
    }
    
    public void increase() {
        int oldValue;
        while(true) {
            // 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解
            oldValue = data;
            // cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false
            if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue + 1)){
                return; 
            }
        }
    }
    
    public void decrease() {
    	int oldValue;
        while(true){
            oldValue = data;
    		if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue - 1)){
                return;
            }
        }
    }
    public int getData() {
        return data;
    } 
}
</code></pre>
<p><a name="amqXK"></a></p>
<h2 id="乐观锁与悲观锁">乐观锁与悲观锁</h2>
<ul>
<li>CAS 是基于乐观锁的思想:最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。</li>
<li>synchronized 是基于悲观锁的思想:最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。<br>
<a name="yAZIy"></a></li>
</ul>
<h2 id="原子操作类">原子操作类</h2>
<p>juc(java.util.concurrent)中提供了原子操作类，可以提供线程安全的操作，例如:AtomicInteger、<br />AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。 可以使用 AtomicInteger 改写之前的例子:</p>
<pre><code class="language-java">// 创建原子整数对象
private static AtomicInteger i = new AtomicInteger(0);
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -&gt; {
        for (int j = 0; j &lt; 5000; j++) { 
            i.getAndIncrement(); // 获取并且自增 i++
            //i.incrementAndGet(); // 自增并且获取 ++i
        } 
    });
    Thread t2 = new Thread(() -&gt; {
        for (int j = 0; j &lt; 5000; j++) {
            i.getAndDecrement(); // 获取并且自减 i-- 
        }
    });
    
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    System.out.println(i);
}
</code></pre>
<p><a name="liIpj"></a></p>
<h1 id="sychronized优化">sychronized优化</h1>
<p>Java HotSpot虚拟机中，每个对象都有对象头(包括 class 指针和 Mark Word)。Mark Word 平时存储这个对象的<code>哈希码、分代年龄(从幸存区晋升到老年代会用到)</code>，当加锁时，这些信息就根据情况被替换为<code>标记位(锁的类型)</code>、<code>线程锁记录指针</code>、<code>重量级锁指针</code>、<code>线程ID</code>等内容<br>
<a name="KYHSb"></a></p>
<h2 id="轻量级锁">轻量级锁</h2>
<p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化。这就好比:<br />学生(线程 A)用课本占座，上了半节课，出门了(CPU时间到)，回来一看，发现课本没变，说明没有竞争，继续上他的课。<br />如果这期间有其它学生(线程 B)来了，会告知(线程A)有并发访问，线程 A 随即升级为重量级锁(锁膨胀)， 进入重量级锁的流程。<br />而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来 <br />假设有两个方法同步块，利用同一个对象加锁</p>
<pre><code class="language-java">static Object obj = new Object();
public static void method1() {
    synchronized( obj ) { 
        // 同步块 A
        method2(); 
    }
}
public static void method2() {
	synchronized( obj ) { 
        // 同步块 B
    } 
}
</code></pre>
<p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p>
<ul>
<li>如果加锁MarkWord中的内容需要发生改变，需要把原来的内容保存起来</li>
<li>加锁时将锁记录地址给MarkWord</li>
<li>等解锁后，需要把原来的内容还给MarkWord</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646029795880-2166b3ce-3e43-4645-bc27-c0943ede2098-20220312195457959.png" alt="image.png" loading="lazy"><br>
<a name="GVmLp"></a></p>
<h2 id="锁膨胀">锁膨胀</h2>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁(有竞争)，这时需要进行锁膨胀，将轻量级锁变为重量级锁。<br />线程一解锁失败，是为了告诉线程一现在是一个重量级锁，需要按照重量级锁的方式来解锁<br />MarkWord中增加重量级锁，是为了唤醒阻塞中的线程</p>
<pre><code class="language-java">static Object obj = new Object();
public static void method1() {
    synchronized( obj ) { 
        // 同步块
    } 
}
</code></pre>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646029841309-0a32d3b3-ef4f-4408-8fa7-eee7e9b2e834-20220312195458112.png" alt="image.png" loading="lazy"><br>
<a name="bir5r"></a></p>
<h2 id="重量锁">重量锁</h2>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功(即这时候持锁线程已经退<br />出了同步块，释放了锁)，这时当前线程就可以避免阻塞。<br />在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次;反之，就少自旋甚至不自旋，总之，比较智能。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>好比等红灯时汽车是不是熄火，不熄火相当于自旋(等待时间短了划算)，熄火了相当于阻塞(等待时间长了划算)</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p>自旋重试成功的情况<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646029915647-8fd9e65d-8b3f-4e7f-a652-624e33f238bc-20220312195458194.png" alt="image.png" loading="lazy"><br />自旋重试失败的情况<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1646030033037-30d2cfb0-3494-4d8a-b26c-bdfb1ed8f1dc-20220312195458290.png" alt="image.png" loading="lazy"><br>
<a name="YdRr4"></a></p>
<h2 id="偏向锁">偏向锁</h2>
<p>轻量级锁在没有竞争时(就自己这个线程)，每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化:只有第一次使用 CAS 将线程 ID设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.</p>
<ul>
<li>变为重量级锁时需要撤销偏向锁，撤销偏向锁需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停(STW)</li>
<li>访问对象的 hashCode 也会撤销偏向锁
<ul>
<li>当一个对象已经计算过identity hash code(未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值)，它就无法进入偏向锁状态；</li>
<li>当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li>
<li>重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。</li>
</ul>
</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 重偏向会重置对象的 Thread ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li>
</ul>
<p>可以参考这篇论文:<a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-</a> 149958.pdf</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<pre><code class="language-java">static Object obj = new Object();
public static void method1() {
    synchronized( obj ) { // 同步块 A
    	method2(); 
    }
}

public static void method2() {
    synchronized( obj ) { 
        // 同步块 B
    }
}
</code></pre>
<p>![image.png](https://cdn.nlark.com/yuque/0/2022/png/26092193/1646030118607-c926f2b8-b980-4c23-a77f-eec29106c721.png#clientId=ufbb25c08-b6bc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=u81a5b064&amp;margin=[object Object]&amp;name=image.png&amp;originHeight=498&amp;originWidth=994&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82025&amp;status=done&amp;style=none&amp;taskId=u3c8466fd-b12d-42c7-a3c6-0f8793c0408&amp;title=&amp;width=497)<br>
<a name="coHn0"></a></p>
<h2 id="其他优化">其他优化</h2>
<p><a name="EsZnY"></a></p>
<h3 id="1-减少上锁时间">1. 减少上锁时间</h3>
<p>同步代码块中尽量短(减少线程交错时间，尽量保持为轻量级锁)<br>
<a name="qFcfJ"></a></p>
<h3 id="2-减少锁的粒度">2. 减少锁的粒度</h3>
<p>将一个锁拆分为多个锁提高并发度，例如:</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li>
<li>LinkedBlockingQueue入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高<br>
<a name="UacE1"></a></li>
</ul>
<h3 id="3-锁粗化">3. 锁粗化</h3>
<p>多次循环进入同步块不如同步块内多次循环<br />另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次(因为都是对同一个对象加锁， 没必要重入多次)</p>
<pre><code class="language-java">new StringBuffer().append(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;);
</code></pre>
<p><a name="bIIL2"></a></p>
<h3 id="4-锁消除">4. 锁消除</h3>
<p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。<br>
<a name="ARsKw"></a></p>
<h3 id="5-读写分离">5. 读写分离</h3>
<p>CopyOnWriteArrayList<br />CopyOnWriteSet<br>
<a name="SOKfG"></a></p>
<h3 id="参考">参考</h3>
<p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a> <br /><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luojinping.com/2015/07/09/java锁优化/</a><br /><a href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/java-se-16-synchronized</a> <br /><a href="https://www.jianshu.com/p/9932047a89be">https://www.jianshu.com/p/9932047a89be</a> <br /><a href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblogs.com/sheeva/p/6366782.html</a> <a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM类加载与字节码技术]]></title>
        <id>https://yeyuan1107.github.io/post/jvm-lei-jia-zai-yu-zi-jie-ma-ji-zhu/</id>
        <link href="https://yeyuan1107.github.io/post/jvm-lei-jia-zai-yu-zi-jie-ma-ji-zhu/">
        </link>
        <updated>2022-02-25T13:15:08.000Z</updated>
        <content type="html"><![CDATA[<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645779030862-32d83d43-fcdf-4762-aa93-7629d55c548c-20220312195348264.png" alt="image.png" loading="lazy"><br>
<a name="Zuwyg"></a></p>
<h1 id="类文件结构">类文件结构</h1>
<pre><code class="language-java">package com.yuanye.jvm

public class HelloWorld{
	public static void main(String[] args){
    	System.out.println(&quot;hello world&quot;);
    }
}
</code></pre>
<p>执行javac -parameters -d . HelloWorld.java</p>
<pre><code>[root@localhost ~]# od -t xC HelloWorld.class
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07
0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29
0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e
0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63
0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01
0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63
0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f
0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16
0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72
0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13
0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69
0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61
0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46
0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64
0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e
0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64
0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74
0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c
0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61
0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61
0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f
0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72
0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76
0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d
0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a
0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b
0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01
0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01
0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00
0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00
0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00
0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00
0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a
0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b
0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00
0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00
0001120 00 00 02 00 14
</code></pre>
<p>根据JVM规范，类文件结构如下<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645779563499-251206a7-2758-4eb9-b0b0-d1d12671f40d-20220312195348551.png" alt="image.png" loading="lazy"><br />左侧u4、u2代表字节数<br /><a href="https://www.cnblogs.com/lilei94/p/9744331.html">字节码详解</a><br>
<a name="svSrl"></a></p>
<h2 id="魔数magic">魔数(magic)</h2>
<p>u4，四个字节表示<br />0-3字节，表示它是否是<code>class</code>类型的文件<br />0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09<br>
<a name="f7NiP"></a></p>
<h2 id="版本">版本</h2>
<p>4-7字节，表示类的版本<br />0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09<br>
<a name="s1DwY"></a></p>
<h2 id="常量池">常量池</h2>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645838051228-413019fc-91ea-431e-9fa7-ab1fb341e88f-20220312195348588.png" alt="image.png" loading="lazy"><br />8-9字节，表示常量池长度，0023(35)表示常量池有#1-#34项，注意#0项不计入，也没有值<br />0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p>第#1项0a(根据常量池)表示一个Method信息，0006和0015表示它引用了常量池中#6和#21项，来获取这个方法的所属类和方法名<br />0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<p>第#2项09表示一个Field信息，0016和0017表示它引用了常量池中#22和#23来获得这个成员变量的所属类和成员变量名<br />0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09<br />0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p>
<p>第#3项 08 表示一个字符串常量名称，0018表示它引用了常量池中 #24 项 <br />0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p>
<p>第#4项 0a 表示一个 Method 信息，0019和 001a表示它引用了常量池中 #25 和 #26 项来获得这个方法的所属类和方法名<br />0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p>
<p>第#5项 07 表示一个 Class 信息，00 1b表示它引用了常量池中 #27 项 <br />0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</p>
<p>第#6项 07 表示一个 Class 信息，00 1c表示它引用了常量池中 #28 项<br />0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 <br />0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<p>第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 <init> 】<br />0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</p>
<p>第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 <br />0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p>
<p>第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】 <br />0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</p>
<p>第#10项 01 表示一个 utf8 串，00 0f(15) 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】<br />0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e <br />0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</p>
<p>第#11项 01 表示一个 utf8 串，00 12(18) 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】<br />0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 <br />0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</p>
<p>第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】 <br />0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 <br />0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</p>
<p>第#13项 01 表示一个 utf8 串，00 1d(29) 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】 <br />0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 <br />0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f<br />0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p>
<p>第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】<br />0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</p>
<p>第#15项 01 表示一个 utf8 串，00 16(22) 表示长度，是【([Ljava/lang/String;)V】其实就是参数为<br />字符串数组，无返回值<br />0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 <br />0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 <br />0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p>
<p>第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】 <br />0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</p>
<p>第#17项 01 表示一个 utf8 串，00 13(19) 表示长度，是【[Ljava/lang/String;】<br />0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 <br />0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 <br />0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</p>
<p>第#18项 01 表示一个 utf8 串，00 10(16) 表示长度，是【MethodParameters】 <br />0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 <br />0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</p>
<p>第#19项 01 表示一个 utf8 串，00 0a(10) 表示长度，是【SourceFile】 <br />0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 <br />0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</p>
<p>第#20项 01 表示一个 utf8 串，00 0f(15) 表示长度，是【HelloWorld.java】 <br />0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64<br />0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p>
<p>第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项<br />0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p>
<p>第#22项 07 表示一个 Class 信息，00 1d(29) 引用了常量池中 #29 项 <br />0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</p>
<p>第#23项 0c 表示一个 【名+类型】，00 1e(30) 00 1f (31)引用了常量池中 #30 #31 两项 <br />0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e <br />0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p>
<p>第#24项 01 表示一个 utf8 串，00 0f(15) 表示长度，是【hello world】 <br />0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</p>
<p>第#25项 07 表示一个 Class 信息，00 20(32) 引用了常量池中 #32 项 <br />0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p>
<p>第#26项 0c 表示一个 【名+类型】，00 21(33) 00 22(34)引用了常量池中 #33 #34 两项 <br />0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</p>
<p>第#27项 01 表示一个 utf8 串，00 1b(27) 表示长度，是【cn/itcast/jvm/t5/HelloWorld】 <br />0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 <br />0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c <br />0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</p>
<p>第#28项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/Object】 <br />0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 <br />0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</p>
<p>第#29项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/System】 <br />0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 <br />0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</p>
<p>第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】 <br />0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f <br />0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</p>
<p>第#31项 01 表示一个 utf8 串，00 15(21) 表示长度，是【Ljava/io/PrintStream;】<br />0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 <br />0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</p>
<p>第#32项 01 表示一个 utf8 串，00 13(19) 表示长度，是【java/io/PrintStream】 <br />0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 <br />0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</p>
<p>第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】 <br />0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</p>
<p>第#34项 01 表示一个 utf8 串，00 15(21) 表示长度，是【(Ljava/lang/String;)V】 <br />0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a <br />0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b <br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p>
<p><a name="XlFVJ"></a></p>
<h2 id="访问标识与继承信息">访问标识与继承信息</h2>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645839399281-6ed242cb-32e5-43ee-9636-a93f3318421f-20220312195348880.png" alt="image.png" loading="lazy"><br />21 表示该 class 是一个类，公共的 <br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 <br />05 表示根据常量池中 #5 找到本类全限定名 <br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 <br />06 表示根据常量池中 #6 找到父类全限定名 <br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 <br />01 表示接口的数量，本类为 0 <br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p>
<p><a name="saSre"></a></p>
<h2 id="field信息">FIeld信息</h2>
<p>表示成员变量数量，本类为0<br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645840710764-56f251c7-5bb3-4404-be50-b5253f350531-20220312195348925.png" alt="image.png" loading="lazy"><br>
<a name="Rc4FG"></a></p>
<h3 id="method信息">Method信息</h3>
<p>表示方法数量，本类为 2 <br />0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 <br />一个方法由 访问修饰符，名称，参数描述，方法属性(代码)数量，方法属性组成</p>
<ul>
<li>红色代表访问修饰符(本类中是 public)</li>
<li>蓝色代表引用了常量池 #07 项作为方法名称</li>
<li>绿色代表引用了常量池 #08 项作为方法参数描述</li>
<li>黄色代表方法属性数量，本方法是 1</li>
<li>红色代表方法属性
<ul>
<li>00 09 表示引用了常量池 #09 项，发现是【Code】属性</li>
<li>00 00 00 2f 表示此属性的长度是 47</li>
<li>00 01 表示【操作数栈】最大深度</li>
<li>00 01 表示【局部变量表】最大槽(slot)数</li>
<li>00 00 00 05 表示字节码长度，本例是 5</li>
<li>2a b7 00 01 b1 是字节码指令</li>
<li>00 00 00 02 表示方法细节属性数量，本例是 2</li>
<li>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性
<ul>
<li>00 00 00 06 表示此属性的总长度，本例是 6</li>
<li>00 01 表示【LineNumberTable】长度</li>
<li>00 00 表示【字节码】行号</li>
<li>00 04 表示【java 源码】行号</li>
</ul>
</li>
<li>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性
<ul>
<li>00 00 00 0c 表示此属性的总长度，本例是 12</li>
<li>00 01 表示【LocalVariableTable】长度</li>
<li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li>
<li>00 05 表示局部变量覆盖的范围长度</li>
<li>00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】</li>
<li>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是 【Lcn/itcast/jvm/t5/HelloWorld;】</li>
<li>00 00 表示局部变量占有的槽位(slot)编号，本例是 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 <br />0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 <br />0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 <br />0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 <br />0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</p>
<ul>
<li>红色代表访问修饰符(本类中是 public static)</li>
<li>蓝色代表引用了常量池 #14 项作为方法名称</li>
<li>绿色代表引用了常量池 #15 项作为方法参数描述</li>
<li>黄色代表方法属性数量，本方法是 2</li>
<li>红色代表方法属性(属性1)
<ul>
<li>00 09 表示引用了常量池 #09 项，发现是【Code】属性</li>
<li>00 00 00 37 表示此属性的长度是 55</li>
<li>00 02 表示【操作数栈】最大深度</li>
<li>00 01 表示【局部变量表】最大槽(slot)数</li>
<li>00 00 00 05 表示字节码长度，本例是 9</li>
<li>b2 00 02 12 03 b6 00 04 b1 是字节码指令</li>
<li>00 00 00 02 表示方法细节属性数量，本例是 2</li>
<li>00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性
<ul>
<li>00 00 00 0a 表示此属性的总长度，本例是 10</li>
<li>00 02 表示【LineNumberTable】长度</li>
<li>00 00 表示【字节码】行号 00 06 表示【java 源码】行号</li>
<li>00 08 表示【字节码】行号 00 07 表示【java 源码】行号</li>
</ul>
</li>
<li>00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性
<ul>
<li>00 00 00 0c 表示此属性的总长度，本例是 12</li>
<li>00 01 表示【LocalVariableTable】长度</li>
<li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li>
<li>00 09 表示局部变量覆盖的范围长度</li>
<li>00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】</li>
<li>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】</li>
<li>00 00 表示局部变量占有的槽位(slot)编号，本例是 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 <br />0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 <br />0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a <br />0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b <br />0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</p>
<p>红色代表方法属性(属性2)</p>
<ul>
<li>00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性
<ul>
<li>00 00 00 05 表示此属性的总长度，本例是 5</li>
<li>01 参数数量</li>
<li>00 10 表示引用了常量池 #16 项，是【args】</li>
<li>00 00 访问修饰符</li>
</ul>
</li>
</ul>
<p>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 <br />0001120 00 00 02 00 14</p>
<p><a name="HwW77"></a></p>
<h2 id="附加属性">附加属性</h2>
<ul>
<li>00 01 表示附加属性数量</li>
<li>00 13 表示引用了常量池 #19 项，即【SourceFile】</li>
<li>00 00 00 02 表示此属性的长度</li>
<li>00 14 表示引用了常量池 #20 项，即【HelloWorld.java】</li>
</ul>
<p>0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 <br />0001120 00 00 02 00 14</p>
<p><a name="Jiypc"></a></p>
<h2 id="参考文档">参考文档</h2>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<p><a name="lNVGb"></a></p>
<h1 id="字节码指令">字节码指令</h1>
<p><a name="CMU6r"></a></p>
<h2 id="入门">入门</h2>
<p>接着上一节，研究一下两组字节码指令，一个是<br /><code>public cn.itcast.jvm.t5.HelloWorld();</code>构造方法的字节码指令</p>
<pre><code>2a b7 00 01 b1
</code></pre>
<ol>
<li>2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</li>
<li>b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</li>
<li>00 01 引用常量池中 #1 项，即【 Method java/lang/Object.&quot;&quot;😦)V 】</li>
<li>b1 表示返回</li>
</ol>
<p>另一个是<code>public static void main(java.lang.String[]);</code>主方法的字节码指令</p>
<pre><code>b2 00 02 12 03 b6 00 04 b1
</code></pre>
<ol>
<li>b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？</li>
<li>00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li>
<li>12 =&gt; ldc 加载参数，哪个参数呢？</li>
<li>03 引用常量池中 #3 项，即 【String hello world】</li>
<li>b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？</li>
<li>00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】</li>
<li>b1 表示返回<br>
<a name="i6fDr"></a></li>
</ol>
<h3 id="参考">参考</h3>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a><br>
<a name="D0qmV"></a></p>
<h2 id="javap工具">javap工具</h2>
<p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件</p>
<pre><code>Classfile /Users/yy/projects/IdeaProjects/Leetcode/out/production/Leetcode/com/yuanye/jvm/HelloWorld.class
  Last modified 2022年2月25日; size 562 bytes
  MD5 checksum 68406ec2a8c4f60b7d40f3d3138c8146
  Compiled from &quot;HelloWorld.java&quot;
public class com.yuanye.jvm.HelloWorld
  minor version: 0
  major version: 55
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #5                          // com/yuanye/jvm/HelloWorld
  super_class: #6                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #23            // HelloWorld
   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #26            // com/yuanye/jvm/HelloWorld
   #6 = Class              #27            // java/lang/Object
   #7 = Utf8               &lt;init&gt;
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/yuanye/jvm/HelloWorld;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
  #16 = Utf8               args
  #17 = Utf8               [Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               HelloWorld.java
  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V
  #21 = Class              #28            // java/lang/System
  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
  #23 = Utf8               HelloWorld
  #24 = Class              #31            // java/io/PrintStream
  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
  #26 = Utf8               com/yuanye/jvm/HelloWorld
  #27 = Utf8               java/lang/Object
  #28 = Utf8               java/lang/System
  #29 = Utf8               out
  #30 = Utf8               Ljava/io/PrintStream;
  #31 = Utf8               java/io/PrintStream
  #32 = Utf8               println
  #33 = Utf8               (Ljava/lang/String;)V
{
  public com.yuanye.jvm.HelloWorld();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/yuanye/jvm/HelloWorld;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String HelloWorld
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 6: 0
        line 7: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
}
</code></pre>
<p><a name="OubPu"></a></p>
<h2 id="图解方法执行流程">图解方法执行流程</h2>
<p><a name="DyqF3"></a></p>
<h3 id="原始java代码">原始java代码</h3>
<pre><code class="language-java">package cn.itcast.jvm.t3.bytecode;

/** 
 * 演示 字节码指令 和 操作数栈、常量池的关系
 */ 
public class Demo3_1 { 
    public static void main(String[] args) {
        int a = 10;
        int b = Short.MAX_VALUE + 1;
        int c = a + b;
        System.out.println(c);
    }
}
</code></pre>
<p><a name="QzE6u"></a></p>
<h3 id="编译后的字节码文件">编译后的字节码文件</h3>
<pre><code>[root@localhost ~]# javap -v Demo3_1.class
Classfile /root/Demo3_1.class
  	Last modified Jul 7, 2019; size 665 bytes
  	MD5 checksum a2c29a22421e218d4924d31e6990cfc5
  	Compiled from &quot;Demo3_1.java&quot;
public class cn.itcast.jvm.t3.bytecode.Demo3_1
  	minor version: 0
  	major version: 52
  	flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   	#1 = Methodref					#7.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   	#2 = Class							#27            // java/lang/Short
   	#3 = Integer						32768
   	#4 = Fieldref						#28.#29        //
java/lang/System.out:Ljava/io/PrintStream;
		#5 = Methodref					#30.#31        // java/io/PrintStream.println:(I)V
 		#6 = Class							#32            // cn/itcast/jvm/t3/bytecode/Demo3_1
 		#7 = Class							#33            // java/lang/Object
 		#8 = Utf8								&lt;init&gt;
 		#9 = Utf8								()V
		#10 = Utf8							Code
		#11 = Utf8							LineNumberTable
		#12 = Utf8							LocalVariableTable
		#13 = Utf8							this
		#14 = Utf8							Lcn/itcast/jvm/t3/bytecode/Demo3_1;
		#15 = Utf8							main
		#16 = Utf8							([Ljava/lang/String;)V
		#17 = Utf8							args
		#18 = Utf8							[Ljava/lang/String;
		#19 = Utf8							a
		#20 = Utf8							I
		#21 = Utf8							b
		#22 = Utf8							c
		#23 = Utf8							MethodParameters
		#24 = Utf8							SourceFile
		#25 = Utf8							Demo3_1.java
		#26 = NameAndType				#8:#9          // &quot;&lt;init&gt;&quot;:()V
		#27 = Utf8							java/lang/Short
		#28 = Class							#34            // java/lang/System
		#29 = NameAndType				#35:#36        // out:Ljava/io/PrintStream;
		#30 = Class							#37            // java/io/PrintStream
		#31 = NameAndType				#38:#39        // println:(I)V
		#32 = Utf8							cn/itcast/jvm/t3/bytecode/Demo3_1
		#33 = Utf8							java/lang/Object
		#34 = Utf8							java/lang/System
		#35 = Utf8							out
		#36 = Utf8							Ljava/io/PrintStream;
		#37 = Utf8							java/io/PrintStream
		#38 = Utf8							println
		#39 = Utf8							(I)V
{
  public cn.itcast.jvm.t3.bytecode.Demo3_1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1					// Method java/lang/Object.&quot;
         0: aload_0
         1: invokespecial #1						
&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
      	Start  Length  Slot  Name   Signature
          	0       5     0  this   Lcn/itcast/jvm/t3/bytecode/Demo3_1;
public static void main(java.lang.String[]);
  descriptor: ([Ljava/lang/String;)V
  flags: ACC_PUBLIC, ACC_STATIC
  Code:
		stack=2, locals=4, args_size=1
   		0: bipush        	10
   		2: istore_1				
      3: ldc						#3										// int 32768
   		5: istore_2
   		6: iload_1
   		7: iload_2
   		8: iadd
			9: istore_3
			10: getstatic			#4										// Field
java/lang/System.out:Ljava/io/PrintStream;
			13: iload_3
     	14: invokevirtual #5										// Method
java/io/PrintStream.println:(I)V
      17: return
     LineNumberTable:
      line 8: 0
      line 9: 3
			line 10: 6
      line 11: 10
      line 12: 17
     LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      18     0  args   [Ljava/lang/String;
            3      15     1     a   I
            6      12     2     b   I
           10       8     3     c   I
    MethodParameters:
				Name 												Flags
				args 
}
</code></pre>
<p><a name="VfBYq"></a></p>
<h3 id="常量池载入运行时常量池">常量池载入运行时常量池</h3>
<ul>
<li>当java代码被执行时，由jvm的类加载器对main()方法所在的类进行类加载(将.class文件的字节数据读取到内存中)</li>
<li>将常量池的数据会放入到运行时常量池中，运行时常量池属于方法区</li>
<li>比较小的数字并不存在常量池中，与方法的字节码存放在一起。一旦数字超过了short类型的最大值，就存放在常量池中</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645845825715-9770beef-8a62-4af4-8886-a9be7816c00d-20220312195349217.png" alt="image.png" loading="lazy"><br>
<a name="leilE"></a></p>
<h3 id="方法字节码载入方法区">方法字节码载入方法区</h3>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645846131904-b5f3e282-f51f-475b-9395-4c17d3e9465a-20220312195349267.png" alt="image.png" loading="lazy"><br>
<a name="iQpWs"></a></p>
<h3 id="main线程开始运行分配栈帧内存">main线程开始运行，分配栈帧内存</h3>
<ul>
<li>绿色代表局部变量标，蓝色表示操作数栈</li>
<li>stack表示操作数栈深度，locals表示局部变量表长度</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645846162873-430f7574-fb8f-47ff-a75a-6da88970b9e5-20220312195349549.png" alt="image.png" loading="lazy"><br>
<a name="BjE8m"></a></p>
<h3 id="执行引擎开始执行字节码">执行引擎开始执行字节码</h3>
<p><a name="DLL1T"></a></p>
<h4 id="bipush-10">bipush 10</h4>
<ul>
<li>将一个byte压入操作数栈(其长度会补齐4个字节)，类似的指令还有
<ul>
<li>sipush将一个short压入操作数栈(其长度会补齐4个字节)</li>
<li>ldc将一个int压入操作数栈</li>
<li>ldc2_w将一个long压入操作数栈(分两次压入，因为long是8个字节)</li>
<li>这里小的数字都是和字节码指令存在一起，超过short范围的数字存入了常量池</li>
</ul>
</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850434229-e3e1c66a-2ea9-44b8-9c04-c326a16ecda4-20220312195349830.png" alt="image.png" loading="lazy"><br>
<a name="IqbI9"></a></p>
<h4 id="istore_1">istore_1</h4>
<ul>
<li>将操作数栈顶数据弹出，存入局部变量表的slot 1</li>
<li>对应java代码中<code>a=10;</code></li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850624004-8b563621-74b5-492f-b34b-b170d1453dd6-20220312195350225.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850652813-4d8baee7-565a-46c1-a2d3-0ecf0b1c3a36-20220312195350307.png" alt="image.png" loading="lazy"><br>
<a name="aFH5R"></a></p>
<h4 id="ldc3">ldc#3</h4>
<ul>
<li>从常量池加载#3数据到操作数栈</li>
<li>注意 Short.MAX_VALUE是32767，所以32768=Short.MAX_VALUE+1实际是在编译期间计算好的</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850787229-dde4352a-ca73-40c2-b069-d178473a0a3f-20220312195350571.png" alt="image.png" loading="lazy"><br>
<a name="bplmV"></a></p>
<h4 id="istore-2">istore 2</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850818540-25488cbe-4136-43be-b40e-3d4d5014273e-20220312195350861.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850830550-86bbe5ff-d634-48b0-b618-0eb2af3a778d-20220312195351171.png" alt="image.png" loading="lazy"><br>
<a name="G8A1L"></a></p>
<h4 id="iload-1">iload 1</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850860003-8aa26fe5-12cd-46ba-9810-4661eb8fae21-20220312195351493.png" alt="image.png" loading="lazy"><br>
<a name="wr0nQ"></a></p>
<h4 id="iload-2">iload 2</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850879972-3fb306c0-bef3-4797-be02-c4cd2ff8e391-20220312195351914.png" alt="image.png" loading="lazy"><br>
<a name="UT7L4"></a></p>
<h4 id="iadd">iadd</h4>
<ul>
<li>运算需要在操作数栈中运行，所以需要加载到栈中</li>
<li>iadd弹出两个结果进行运算，将结果压入到操作数栈中</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645850958769-c20fe0ad-215e-4591-b434-4ee454e50069-20220312195352025.png" alt="image.png" loading="lazy"><br>
<a name="hjkrl"></a></p>
<h4 id="istore-3">istore 3</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645851296331-99d1ca1f-0084-4589-af79-77545e50ee2f-20220312195352323.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645851426930-26c390c8-1514-4e60-93d7-e2981920be0d-20220312195352705.png" alt="image.png" loading="lazy"><br>
<a name="O65wJ"></a></p>
<h4 id="getstatic-41">getstatic #41</h4>
<ul>
<li>getstatic到常量池中找到成员变量的引用</li>
<li>成员变量存放在堆中，通过常量池找到堆中的成员变量</li>
<li>然后将成员变量的引用放入到操作数栈中</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645851522360-db9438ff-a721-40ce-8737-fa2876843094-20220312195353114.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645851694474-b5c51e5b-2070-479f-8ffe-fa71d3bddaf9-20220312195353247.png" alt="image.png" loading="lazy"><br>
<a name="BMF67"></a></p>
<h4 id="iload3">iload3</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645851730146-3901f6c6-61ef-4a92-a327-9a7fc4c0880d-20220312195353567.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645851752394-8df2533f-5bf4-4aa8-ba73-839d1b6a3cca-20220312195353874.png" alt="image.png" loading="lazy"><br>
<a name="uWhXa"></a></p>
<h4 id="invokevirtual-5">invokevirtual #5</h4>
<ul>
<li>找到常量池#5项</li>
<li>定位到方法区java/io/PrintStream.println:(I)V方法</li>
<li>生成新的栈帧(分配locals、stack等)</li>
<li>传递参数，执行新栈帧中的字节码</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645852515253-d79039fd-2e0c-47bf-a5db-365002ace170-20220312195354460.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>执行完毕弹出栈帧</li>
<li>清除main操作数栈内容</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645852591763-d2a434a0-78f9-4f00-9cda-c6ae2ea3ffed-20220312195354564.png" alt="image.png" loading="lazy"><br>
<a name="IGKMF"></a></p>
<h4 id="return">return</h4>
<ul>
<li>完成main方法调用，弹出main栈帧</li>
<li>程序结束<br>
<a name="JEQEn"></a></li>
</ul>
<h3 id="自增运算图解a-a">自增运算图解(a++, ++a)</h3>
<ul>
<li>注意iinc指令是直接在局部变量slot上进行运算
<ul>
<li>第一个参数是对哪个slot做自增，第二个参数为自增多少</li>
</ul>
</li>
<li>a++和++a的区别是先执行iload还是先执行iinc</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645852894998-2d29f519-d608-4406-990d-e1c358b4e4e5-20220312195354823.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645852954122-6ee13d04-74ae-4c6c-91d4-3d2f52bc8827-20220312195355103.png" alt="image.png" loading="lazy"><br>
<a name="ybIXB"></a></p>
<h4 id="a">a++</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645853023370-29d29c2d-b35d-40b3-a487-448f445bb548-20220312195355186.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645853146454-088af3e2-7e44-4193-acc2-66e395400c89-20220312195355451.png" alt="image.png" loading="lazy"><br>
<a name="X5zxI"></a></p>
<h4 id="a-2">++a</h4>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645853129168-47251ae1-9647-4541-93c2-b88c65c2b05e-20220312195355733.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645853535988-843af1c8-0d68-4fde-a778-b951a81b9531-20220312195355829.png" alt="image.png" loading="lazy"><br>
<a name="k84hl"></a></p>
<h2 id="条件判断指令">条件判断指令</h2>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645855218703-d9247847-190c-41ef-aa98-22cc662a7a86-20220312195355888.png" alt="image.png" loading="lazy"><br>
<a name="ixepn"></a></p>
<h3 id="几点说明">几点说明</h3>
<ul>
<li>byte，short，char都会按int比较，因为操作数栈都是4</li>
<li>goto用来进行跳转到指定行号的字节码<br>
<a name="tEK73"></a></li>
</ul>
<h3 id="源码">源码</h3>
<pre><code class="language-java">public class Demo3_3 {
    public static void main(String[] args) {
        int a = 0;
        if(a == 0) {
            a = 10;
        } else {
            a = 20; 
        }
    }
}
</code></pre>
<p><a name="AcPw2"></a></p>
<h4 id="字节码">字节码</h4>
<ul>
<li>iconst_0得到一个0的常量从<code>-1-5</code>之间的数用iconst</li>
</ul>
<pre><code> 0: iconst_0
 1: istore_1
 2: iload_1
 3: ifne          12
 6: bipush        10
 8: istore_1
 9: goto          15
12: bipush        20
14: istore_1
15: return
</code></pre>
<blockquote>
<p>思考<br>
细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎 么办?<br>
参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p>
</blockquote>
<p><a name="v7Bsr"></a></p>
<h2 id="循环控制执行">循环控制执行</h2>
<p>其实循环控制还是条件判断中的那些指令<br>
<a name="qe7Qz"></a></p>
<h3 id="while源代码">While源代码</h3>
<pre><code class="language-java">public class Demo3_4 {
    public static void main(String[] args) {
        int a = 0;
        while (a &lt; 10) {
            a++; 
        }
    } 
}
</code></pre>
<p><a name="dZM49"></a></p>
<h4 id="while对应字节码">While对应字节码</h4>
<pre><code> 0: iconst_0
 1: istore_1
 2: iload_1
 3: bipush			10
 5: if_icmpge		14
 8: iinc				1, 1
11: goto				2
14: return
</code></pre>
<p><a name="Q7l6W"></a></p>
<h3 id="do-while源代码">Do while源代码</h3>
<pre><code class="language-java">public class Demo3_5 {
    public static void main(String[] args) {
        int a = 0; 
        do {
            a++;
        } while (a &lt; 10);
    }
}
</code></pre>
<p><a name="WnKUb"></a></p>
<h4 id="do-while字节码">Do while字节码</h4>
<pre><code>0: iconst_0 
1: istore_1 		
2: iinc					1, 1
5: iload_1 
6: bipush				10
8: if_icmplt		2
11: return
</code></pre>
<p><a name="OyVS9"></a></p>
<h3 id="for循环源代码">For循环源代码</h3>
<pre><code class="language-java">public class Demo3_6 {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
        }
    }
}
</code></pre>
<p><a name="dvjzY"></a></p>
<h4 id="for循环字节码">For循环字节码</h4>
<pre><code> 0: iconst_0
 1: istore_1
 2: iload_1
 3: bipush				10
 5: if_icmpge			14
 8: iinc					1, 1
11: goto					2
14: return
</code></pre>
<blockquote>
<p>注意<br>
比较while和for的字节码，你发现他们是一模一样的，殊途同归</p>
</blockquote>
<p><a name="L3nYZ"></a></p>
<h3 id="练习">练习</h3>
<pre><code class="language-java">public class Demo3_6_1 {
    public static void main(String[] args) {
        int i = 0;
        int x = 0;
        while (i &lt; 10) {
			x = x++;//iload_x --&gt; iinc 1,1 --&gt; istore_x(存回去的x=0覆盖了自增后的x=1)
			i++; 
        }
		System.out.println(x); // 结果是 0 
    }
}
</code></pre>
<p><a name="yvQpL"></a></p>
<h2 id="构造器方法">构造器方法</h2>
<p><a name="Jf0W3"></a></p>
<h3 id="cinitv"><cinit>()V</h3>
<pre><code class="language-java">public class Demo3_8_1 {
    static int i = 10;
    
    static {
        i = 20;
    }
    
    static {
        i = 30;
    } 
}
</code></pre>
<p>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方 法 <code>&lt;cinit&gt;()V </code></p>
<pre><code> 0: bipush        10
 2: putstatic     #2				//Field i:I
 5: bipush        20
 7: putstatic     #2				//Field i:I
10: bipush        30
12: putstatic     #2				//Field i:I
15: return
</code></pre>
<p><code>&lt;cinit&gt;()V </code>方法会在类加载的初始化阶段被调用</p>
<blockquote>
<p>练习<br>
可以调整一下static变量和静态代码块的位置，观察字节码的改动</p>
</blockquote>
<p><a name="qbO71"></a></p>
<h3 id="initv"><init>()V</h3>
<pre><code class="language-java">public class Demo3_8_2 {
    private String a = &quot;s1&quot;;
    {
        b = 20;
    }
    private int b = 10;
    {
        a = &quot;s2&quot;;
    }
    public Demo3_8_2(String a, int b) {
        this.a = a;
        this.b = b; 
    }
    public static void main(String[] args) {
        Demo3_8_2 d = new Demo3_8_2(&quot;s3&quot;, 30);
        System.out.println(d.a);
        System.out.println(d.b);
    } 
}

</code></pre>
<p>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构 造方法内的代码总是在最后</p>
<ul>
<li>aload_0把this加载到栈</li>
<li>
<br />
</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645858529647-7b17bf1a-fc5a-498f-b072-84be9d54bb6d-20220312195356178.png" alt="image.png" loading="lazy"><br>
<a name="gKCP6"></a></p>
<h2 id="方法调用">方法调用</h2>
<p>看一下几种不同的方法调用对应的字节码指令</p>
<pre><code class="language-java">public class Demo3_9 {
    public Demo3_9() { }
    private void test1() { }
    private final void test2() { }
    public void test3() { }
    public static void test4() { }
    public static void main(String[] args) {
        Demo3_9 d = new Demo3_9();
        d.test1();
        d.test2();
    } 
}
</code></pre>
<pre><code> 0: new           #2						//class cn/itcast/jvm/t3/bytecode/Demo3_9
 3: dup
 4: invokespecial #3						//Method &quot;&lt;init&gt;&quot;:()V
 7: astore_1				
 8: aload_1	
 9: invokespecial #4						//Method test1:()V
12: aload_1
13: invokespecial #5						//Method test2:()V
16: aload_1
17: invokevirtual #6						//Method test3:()V
20: aload_1
21: pop
22: invokestatic  #7						//Method test4:()V
25: invokestatic  #7						//Method test4:()V
28: return
</code></pre>
<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 &quot;<init>&quot;😦)V (会消耗掉栈顶一个引用)，另一个要配合 astore_1 赋值给局部变量</li>
<li>最终方法(final)，私有方法(private)，构造方法都是由 invokespecial 指令来调用，属于静态绑定</li>
<li>普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态 ，具体方法需要在运行时确定</li>
<li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
<li>比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了，因此调用静态方法时不要使用对象调用，会产生两条无用的字节码指令，直接使用类来调用即可</li>
<li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法<br>
<a name="PJeyb"></a></li>
</ul>
<h2 id="多态的原理">多态的原理</h2>
<pre><code class="language-java">package cn.itcast.jvm.t3.bytecode;
import java.io.IOException;
/**
* 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩
* -XX:-UseCompressedOops -XX:-UseCompressedClassPointers */
public class Demo3_10 {
    public static void test(Animal animal) {
        animal.eat();
        System.out.println(animal.toString());
    }
    public static void main(String[] args) throws IOException {
        test(new Cat());
        test(new Dog());
        System.in.read();
    }
}

abstract class Animal {
    public abstract void eat();
    @Override
    public String toString() {
        return &quot;我是&quot; + this.getClass().getSimpleName();
    } 
}

class Dog extends Animal {
    @Override
    public void eat() { 
        System.out.println(&quot;啃骨头&quot;);
    } 
}

class Cat extends Animal {
    @Override
    public void eat() { 
        System.out.println(&quot;吃鱼&quot;);
    } 
}
</code></pre>
<p><a name="tepZO"></a></p>
<h3 id="运行代码">运行代码</h3>
<p>停在 System.in.read() 方法上，这时运行 jps 获取进程 id<br>
<a name="HljgA"></a></p>
<h3 id="运行hsdb工具">运行HSDB工具</h3>
<p>进入JDK安装目录，执行<br /><code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code><br>
<a name="xwoAc"></a></p>
<h3 id="查找某个对象">查找某个对象</h3>
<p>打开Tools --&gt; Find Object By Query<br />输入<code>select d from cn.itcast.jvm.t3.bytecode.Dog d</code>点击Execute执行<br /><code>d为指定的类型别名</code><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645860895070-01e16056-2661-4c77-b94f-b78417e1bcb6-20220312195356205.png" alt="image.png" loading="lazy"><br>
<a name="PW7mo"></a></p>
<h3 id="查看对象内存结构">查看对象内存结构</h3>
<p>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是<br />MarkWord，后 8 字节就是对象的 Class 指针 <br />但目前看不到它的实际地址<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645860939528-45eb91c6-9405-4f99-bc64-0f3b92bdcc1a-20220312195356237.png" alt="image.png" loading="lazy"><br>
<a name="HUtyi"></a></p>
<h3 id="查看对象class的内存地址">查看对象Class的内存地址</h3>
<p>通过windows --&gt; console 进入命令行模式，执行<br /><code>mem 0x00000001299b4978 2</code><br />mem有两个参数，参数1是对象地址，参数2是查看2行(即16字节)<br />结果中第二行 0x000000001b7d4028 即为 Class 的内存地址<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645861038408-47c8a77b-3a6e-4c74-90c4-47b4f70297bb-20220312195356282.png" alt="image.png" loading="lazy"><br>
<a name="ElR7V"></a></p>
<h3 id="查看类的vtable">查看类的vtable</h3>
<ul>
<li>方法1:Alt+R进入Inspector工具，输入刚才的Class内存地址，看到如下洁面</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645861093102-40364e6e-de00-44c6-80b3-92456584fc27-20220312195356598.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>方法2:或者 Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645861118051-a13134d1-6556-4219-b8ba-061ee6cf2a0f-20220312195356705.png" alt="image.png" loading="lazy"><br />无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法(多态相关的，final，static 不会列入)<br />那么这 6 个方法都是谁呢?从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到:</p>
<pre><code>0x000000001b7d4028
               1b8 +
---------------------
0x000000001b7d41e0
</code></pre>
<p>通过windows --&gt; console进入命令行模式，执行</p>
<pre><code>mem 0x000000001b7d41e0 6

0x000000001b7d41e0: 0x000000001b3d1b10
0x000000001b7d41e8: 0x000000001b3d15e8
0x000000001b7d41f0: 0x000000001b7d35e8
0x000000001b7d41f8: 0x000000001b3d1540
0x000000001b7d4200: 0x000000001b3d1678
0x000000001b7d4208: 0x000000001b7d3fa8
</code></pre>
<p>就得到了6个虚方法的入口<br>
<a name="Rvr9R"></a></p>
<h3 id="验证方法地址">验证方法地址</h3>
<p>通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知</p>
<pre><code>Dog - public void eat() @0x000000001b7d3fa8
Animal - public java.lang.String toString() @0x000000001b7d35e8;
Object - protected void finalize() @0x000000001b3d1b10;
Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8;
Object - public native int hashCode() @0x000000001b3d1540;
Object - protected native java.lang.Object clone() @0x000000001b3d1678;
</code></pre>
<p>对号入座，发现</p>
<ul>
<li>eat() 方法是 Dog 类自己的</li>
<li>toString() 方法是继承 Animal 类的</li>
<li>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的<br>
<a name="Gjh9x"></a></li>
</ul>
<h3 id="小结">小结</h3>
<p>当执行 invokevirtual 指令时，</p>
<ol>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 Class</li>
<li>Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码<br>
<a name="VcWXL"></a></li>
</ol>
<h2 id="异常处理">异常处理</h2>
<p><a name="XlU1a"></a></p>
<h3 id="try-catch">try-catch</h3>
<pre><code class="language-java">public class Demo3_11_1 {
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        }
    }
}
</code></pre>
<blockquote>
<p>注意<br>
为了抓住重点，下面的字节码省略了不重要的部分</p>
</blockquote>
<pre><code>public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=3, args_size=1
         0: iconst_0
         1: istore_1
         2: bipush        10
         4: istore_1
         5: goto          12
         8: astore_2
         9: bipush        20
11: istore_1
        12: return
      Exception table:
         from    to  target type
             2     5     8   Class java/lang/Exception
      LineNumberTable: ...
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            9       3     2     e   Ljava/lang/Exception;
            0      13     0  args   [Ljava/lang/String;
            2      11     1     i   I
      StackMapTable: ...
    MethodParameters: ...
}
</code></pre>
<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置<br>
<a name="RK1IO"></a></li>
</ul>
<h3 id="多个single-catch块的情况">多个single-catch块的情况</h3>
<pre><code class="language-java">public class Demo3_11_2 {
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (ArithmeticException e) {
            i = 30;
        } catch (NullPointerException e) {
            i = 40;
        } catch (Exception e) {
            i = 50; 
        }
    }
}
</code></pre>
<pre><code>public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=3, args_size=1
         0: iconst_0
         1: istore_1
         2: bipush        10
         4: istore_1
         5: goto          26
         8: astore_2
         9: bipush        30
        11: istore_1
        12: goto          26
        15: astore_2
        16: bipush        40
        18: istore_1
        19: goto          26
        22: astore_2
        23: bipush        50
        25: istore_1
        26: return
      Exception table:
         from    to  target type
258 2 5 15 2 5 22
LineNumberTable: ...
LocalVariableTable:
Class java/lang/ArithmeticException
Class java/lang/NullPointerException
Class java/lang/Exception
    Start  Length  Slot  Name   Signature
        9       3     2     e   Ljava/lang/ArithmeticException;
       16       3     2     e   Ljava/lang/NullPointerException;
       23       3     2     e   Ljava/lang/Exception;
        0      27     0  args   [Ljava/lang/String;
        2      25     1     i   I
  StackMapTable: ...
MethodParameters: ...
</code></pre>
<ul>
<li>因为异常出现时，只能进入Exception table中一个分支，所以局部变量表slot2位置被共用<br>
<a name="P5WAt"></a></li>
</ul>
<h3 id="multi-catch的情况">multi-catch的情况</h3>
<pre><code class="language-java">public class Demo3_11_3 {
    public static void main(String[] args) {
        try {
            Method test = Demo3_11_3.class.getMethod(&quot;test&quot;);
            test.invoke(null);
        } catch (NoSuchMethodException | 
                 IllegalAccessException |
                 InvocationTargetException e) {
            e.printStackTrace();
        } 
    }
    public static void test() {
        System.out.println(&quot;ok&quot;);
    } 
}
</code></pre>
<pre><code>public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: ldc           #2
         2: ldc           #3
         4: iconst_0
         5: anewarray     #4
         8: invokevirtual #5
        11: astore_1
        12: aload_1
        13: aconst_null
        14: iconst_0
        15: anewarray     #6
        18: invokevirtual #7
        21: pop
        22: goto          30
        25: astore_1
        26: aload_1
        27: invokevirtual #11 // e.printStackTrace:()V
        30: return
      Exception table:
         from    to  target type
       0    22    25
       0    22    25
       0    22    25
LineNumberTable: ...
LocalVariableTable:
Class java/lang/NoSuchMethodException
Class java/lang/IllegalAccessException
Class java/lang/reflect/InvocationTargetException
    Start  Length  Slot  Name   Signature
       12      10     1  test   Ljava/lang/reflect/Method;
       26       4     1     e   Ljava/lang/ReflectiveOperationException;
        0      31     0  args   [Ljava/lang/String;
  StackMapTable: ...
MethodParameters: ...
</code></pre>
<p><a name="x1uES"></a></p>
<h3 id="finally">finally</h3>
<pre><code class="language-java">public class Demo3_11_4 {
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        } finally {
            i = 30;
        } 
    }
}
</code></pre>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645863188002-c36058a0-22f9-4098-b174-d256178f659d-20220312195357006.png" alt="image.png" loading="lazy"><br />可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程<br>
<a name="VVP60"></a></p>
<h4 id="finally面试题">finally面试题</h4>
<p><a name="g4F1n"></a></p>
<h5 id="finally出现了return">finally出现了return</h5>
<pre><code class="language-java">public class Demo3_12_2 {
    public static void main(String[] args) {
        int result = test();
        System.out.println(result);
    }
    public static int test() {
        try {
            return 10;
        } finally {
            return 20; 
        }
    }
}
</code></pre>
<pre><code>public static int test();
  descriptor: ()I
  flags: ACC_PUBLIC, ACC_STATIC
  Code:
    stack=1, locals=2, args_size=0
    	0: bipush				10		//&lt;--10放入栈顶
			2: istore_0						//10--&gt;slot0(从栈顶移除了)
			3: bipush				20    //&lt;--20放入栈顶
			5: ireturn						//返回栈顶 int(20)
			6: astore_1						//catch any --&gt; slot 1
			7: bipush				20		//&lt;--20放入栈顶
			9: ireturn						//返回栈顶 int(20)
    Exception table
  from    to  target type
     0     3     6   any
	LineNumberTable: ...
	StackMapTable: ... 
</code></pre>
<ul>
<li>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们:如果在 finally 中出现了 return，会吞掉异常😱😱😱，可以试一下下面的代码</li>
</ul>
<pre><code class="language-java">public class Demo3_12_1 {
    public static void main(String[] args) {
        int result = test();
        System.out.println(result);
    }
    public static int test() {
        try {
            int i = 1/0;
    		return 10;
		} finally {
            return 20; 
        }
    }
}
</code></pre>
<p><a name="B7qd6"></a></p>
<h4 id="finally对返回值的影响">finally对返回值的影响</h4>
<pre><code class="language-java">public class Demo3_12_2 {
    public static void main(String[] args) {
        int result = test();
        System.out.println(result);
    }
    public static int test() {
        int i = 10;
        try {
            return i;
        } finally {
            i = 20;
        } 
    }
}
</code></pre>
<pre><code>public static int test();
  descriptor: ()I
  flags: ACC_PUBLIC, ACC_STATIC
  Code:
    stack=1, locals=3, args_size=0
    	0: bipush				10		// &lt;- 10 放入栈顶
			2: istore_0						// 10-&gt;i
			3: iload_0						// &lt;- i(10)
			4: istore_1						// 10 -&gt; slot 1，暂存至 slot 1，目的是为了固定返回值
			5: bipush				20		// &lt;- 20 放入栈顶
			7: istore_0						// 20-&gt;i
			8: iload_1						// &lt;- slot 1(10) 载入 slot 1 暂存的值
			9: ireturn						// 返回栈顶的 int(10)
      10: astore_2
  		11: bipush    	20
  		13: istore_0
  		14: aload_2
  		15: athrow
    Exception table:
   	from    to  target type
       3     5    10   any
		LineNumberTable: ...
		LocalVariableTable:
  	Start  Length  Slot  Name   Signature
				3 			13 		0 		i 					I
    StackMapTable: ...
</code></pre>
<p><a name="ZHWkF"></a></p>
<h2 id="synchronized">synchronized</h2>
<pre><code class="language-java">public class Demo3_13 {
    public static void main(String[] args) {
        Object lock = new Object();
        synchronized (lock) {
            System.out.println(&quot;ok&quot;);
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645867124693-fa8cddde-949a-468d-88cc-d16f860c9d1e-20220312195357240.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>monitorenter加锁，monitorexit解锁</li>
</ul>
<blockquote>
<p>注意<br>
方法级别的synchronized不会在字节码指令中有所体现</p>
</blockquote>
<p><a name="K44Uv"></a></p>
<h1 id="编译期处理">编译期处理</h1>
<p>语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利(给糖吃嘛)<br />注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并 不是编译器还会转换出中间的 java 源码，切记。<br>
<a name="iBUE2"></a></p>
<h2 id="默认构造器">默认构造器</h2>
<pre><code class="language-java">public class Candy1 {
}
</code></pre>
<p><a name="ccKZe"></a></p>
<h3 id="编译成class后的代码">编译成class后的代码</h3>
<pre><code class="language-java">public class Candy1 {
	// 这个无参构造是编译器帮助我们加上的 
    public Candy1() {
		super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V
	} 
}
</code></pre>
<p><a name="Eo7mg"></a></p>
<h2 id="自动拆装箱">自动拆装箱</h2>
<p>这个特性是<code>JDK 5</code>开始加入的</p>
<pre><code class="language-java">public class Candy2 {
    public static void main(String[] args) {
		Integer x = 1;
		int y = x; 
    }
}
</code></pre>
<p>这段代码在<code>JDK 5</code>之前是无法编译通过的，必须改写为:</p>
<pre><code class="language-java">public class Candy2 {
    public static void main(String[] args) {
        Integer x = Integer.valueOf(1);
        int y = x.intValue();
    }
}
</code></pre>
<p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换(尤其是集合类中操作的都是 包装类型)，因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 <code>代码片段1</code> 都会在编译阶段被转换为 <code>代码片段2</code><br>
<a name="lG6Ur"></a></p>
<h2 id="泛型集合取值">泛型集合取值</h2>
<p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 <code>泛型擦除</code> 的动作，即泛型信息<br />在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理:</p>
<pre><code class="language-java">public class Candy3 {
    public static void main(String[] args) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(10); // 实际调用的是 List.add(Object e)
        Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);
    }
}
</code></pre>
<p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作</p>
<pre><code class="language-java">// 需要将 Object 转为 Integer 
Integer x = (Integer)list.get(0);
</code></pre>
<p>如果前面的x变量类型修改为int基本类型那么最终生成的字节码是</p>
<pre><code class="language-java">// 需要将 Object 转为 Integer, 并执行拆箱操作 
int x = ((Integer)list.get(0)).intValue();
</code></pre>
<p>擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息</p>
<pre><code>LocalVariableTable:
  Start  Length  Slot  Name   Signature
  		0      32     0  args   [Ljava/lang/String;
      8      24     1  list   Ljava/util/List;
LocalVariableTypeTable:
  Start  Length  Slot  Name   Signature
      8      24     1  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;
</code></pre>
<p>使用反射，仍然能够获得这些信息</p>
<pre><code class="language-java">public Set&lt;Integer&gt; test(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map) {
}
</code></pre>
<pre><code class="language-java">Method test = Candy3.class.getMethod(&quot;test&quot;, List.class, Map.class);
Type[] types = test.getGenericParameterTypes();
for (Type type : types) {
    if (type instanceof ParameterizedType) {
        ParameterizedType parameterizedType = (ParameterizedType) type; 
        System.out.println(&quot;原始类型 - &quot; + parameterizedType.getRawType()); 
        Type[] arguments = parameterizedType.getActualTypeArguments(); 
        for (int i = 0; i &lt; arguments.length; i++) {
            System.out.printf(&quot;泛型参数[%d] - %s\n&quot;, i, arguments[i]); 
        }
    }
}
</code></pre>
<pre><code class="language-java">//输出结果
原始类型 - interface java.util.List 
泛型参数[0] - class java.lang.String 
原始类型 - interface java.util.Map 
泛型参数[0] - class java.lang.Integer 
泛型参数[1] - class java.lang.Object
</code></pre>
<p><a name="HUhIk"></a></p>
<h2 id="可变参数">可变参数</h2>
<p>可变参数也是JDK 5开始加入的新特性</p>
<pre><code class="language-java">public class Candy4 {
    public static void foo(String... args) {
		String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
        foo(&quot;hello&quot;, &quot;world&quot;);
	} 
}
</code></pre>
<p>可变参数 String... args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同样 java 编译器会在编译期间将上述代码变换为:</p>
<pre><code class="language-java">public class Candy4 {
    public static void foo(String[] args) {
		String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
        foo(new String[]{&quot;hello&quot;, &quot;world&quot;});
	} 
}
</code></pre>
<blockquote>
<p>注意<br>
如果调用了foo()则等价代码为foo(new String[]{})，创建了一个空的数组，而不会传递null进去</p>
</blockquote>
<p><a name="tDpcp"></a></p>
<h2 id="foreach循环">foreach循环</h2>
<p>仍是JDK5开始引入的语法糖，<br>
<a name="N939v"></a></p>
<h3 id="数组的循环">数组的循环：</h3>
<pre><code class="language-java">public class Candy5_1 {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5}; // 数组赋初值的简化写法也是语法糖哦 
        for (int e : array) {
            System.out.println(e);
        }
    }
}
</code></pre>
<p>会被编译器转换为</p>
<pre><code class="language-java">public class Candy5_1 {
    public Candy5_1() {
    }
    public static void main(String[] args) {
        int[] array = new int[]{1, 2, 3, 4, 5};
        for(int i = 0; i &lt; array.length; ++i) {
            int e = array[i];
            System.out.println(e);
        }
    }
}
</code></pre>
<p><a name="lD1Zs"></a></p>
<h3 id="集合的循环">集合的循环</h3>
<pre><code class="language-java">public class Candy5_2 {
    public static void main(String[] args) {
        List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5);
        for (Integer i : list) {
            System.out.println(i);
        }
    }
}
</code></pre>
<p>实际被编译器转换为对迭代器的调用</p>
<pre><code class="language-java">public class Candy5_2 {
   public Candy5_2() {
   }
   public static void main(String[] args) {
       List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
       Iterator iter = list.iterator();
       while(iter.hasNext()) {
           Integer e = (Integer)iter.next();
           System.out.println(e);
       }
   }
}
</code></pre>
<blockquote>
<p>注意<br>
foreach循环写法，能够配合数组，以及所有实现了iterable接口的集合类一起食用，其中Iterable用来获取集合的迭代器</p>
</blockquote>
<p><a name="fzgxG"></a></p>
<h2 id="switch字符串">switch字符串</h2>
<p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖</p>
<pre><code class="language-java">public class Candy6_1 {
    public static void choose(String str) {
        switch (str) {
            case &quot;hello&quot;: {
                System.out.println(&quot;h&quot;);
				break; 
            }
            case &quot;world&quot;: {
                System.out.println(&quot;w&quot;);
                break;
			} 
        }
    } 
}
</code></pre>
<blockquote>
<p>注意<br>
switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清楚</p>
</blockquote>
<pre><code class="language-java">public class Candy6_1 {
    public Candy6_1() {
    }
    public static void choose(String str) {
		byte x = -1; 
        switch(str.hashCode()) {
            case 99162322: // hello 的 hashCode
                if (str.equals(&quot;hello&quot;)) {
                    x = 0; 
                }
				break;
            case 113318802: // world 的 hashCode
                if (str.equals(&quot;world&quot;)) {
                    x = 1;
                } 
        }
		switch(x) {
            case 0:
                System.out.println(&quot;h&quot;);
                break;
            case 1:
                System.out.println(&quot;w&quot;);
        }
    }
}
</code></pre>
<p>可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。<br />为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢?<br />hashCode 是为了提高效率，减少可 能的比较;<br />而 equals 是为了防止 hashCode 冲突，例如 BM 和 C. 这两个字符串的hashCode值都是2123 ，如果有如下代码:</p>
<pre><code class="language-java">public class Candy6_2 {
    public static void choose(String str) {
        switch (str) {
            case &quot;BM&quot;: {
                System.out.println(&quot;h&quot;);
                break; 
            }
            case &quot;C.&quot;: {
                System.out.println(&quot;w&quot;);
                break;
            } 
        }
    } 
}
</code></pre>
<p>会被编译器转换为</p>
<pre><code class="language-java">public class Candy6_2 {
    public Candy6_2() {
    }
    public static void choose(String str) {
        byte x = -1;
		switch(str.hashCode()) {
            case 2123: // hashCode 值可能相同，需要进一步用 equals 比较
            if (str.equals(&quot;C.&quot;)){
                x = 1;
            } else if (str.equals(&quot;BM&quot;)) {
                x = 0;
            } default:
                switch(x) {
                    case 0:
                        System.out.println(&quot;h&quot;);
                        break;
                    case 1:
                        System.out.println(&quot;w&quot;);
                }
        }
    }
}
</code></pre>
<p><a name="UyRSa"></a></p>
<h2 id="switch枚举">switch枚举</h2>
<p>switch枚举的例子，原始代码：</p>
<pre><code class="language-java">enum Sex {
    MALE, FEMALE
}
</code></pre>
<pre><code class="language-java">public class Candy7 {
    public static void foo(Sex sex) {
        switch (sex) {
            case MALE:
                System.out.println(&quot;男&quot;); 
                break; 
            case FEMALE:
                System.out.println(&quot;女&quot;); 
                break;
        }
    }
}
</code></pre>
<p>转换后代码</p>
<pre><code class="language-java">public class Candy7 {
    /**
    * 定义一个合成类(仅 jvm 使用，对我们不可见)
    * 用来映射枚举的 ordinal 与数组元素的关系
    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始
    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1 
    */
    static class $MAP {
        // 数组大小即为枚举元素个数，里面存储case用来对比的数字 
        static int[] map = new int[2];
        static {
            map[Sex.MALE.ordinal()] = 1;
            map[Sex.FEMALE.ordinal()] = 2;
        }
    }
    
    public static void foo(Sex sex) {
        int x = $MAP.map[sex.ordinal()];
        switch (x) {
            case 1: 
                System.out.println(&quot;男&quot;); 
                break;
            case 2:
                System.out.println(&quot;女&quot;); 
                break;
        }
    }
}
</code></pre>
<p><a name="E7zMF"></a></p>
<h2 id="枚举类">枚举类</h2>
<p>JDK 7 新增了枚举类，以前面的性别枚举为例:</p>
<pre><code class="language-java">enum Sex {
    MALE, FEMALE
}
</code></pre>
<p>转换后代码</p>
<pre><code class="language-java">public final class Sex extends Enum&lt;Sex&gt; {
    public static final Sex MALE;
    public static final Sex FEMALE;
    private static final Sex[] $VALUES;
    static {
        MALE = new Sex(&quot;MALE&quot;, 0);
        FEMALE = new Sex(&quot;FEMALE&quot;, 1);
        $VALUES = new Sex[]{MALE, FEMALE};
    }
    /**
     * Sole constructor.  Programmers cannot invoke this constructor.
     * It is for use by code emitted by the compiler in response to
     * enum type declarations.
     *
     * @param name    - The name of this enum constant, which is the identifier
     *                used to declare it.
     * @param ordinal - The ordinal of this enumeration constant (its position
     *                in the enum declaration, where the initial constant is assigned 
     */
    private Sex(String name, int ordinal) {
        super(name, ordinal);
    }
    public static Sex[] values() {
        return $VALUES.clone();
    }
    public static Sex valueOf(String name) {
        return Enum.valueOf(Sex.class, name);
    } 
}
</code></pre>
<p><a name="qwEYk"></a></p>
<h2 id="try-with-resources">try-with-resources</h2>
<p>JDK 7开始新增了对需要关闭的资源处理的特殊语法try-with-resources:</p>
<pre><code class="language-java">try(资源变量 = 创建资源对象){ 
    
} catch( ) {
    
}
</code></pre>
<p>其中资源对象需要实现<code>AutoCloseable</code>接口，例如<code>InputStream、OutStream、Connection、Statement、ResultSet</code>等接口都实现了<code>AutoCloseable</code>使用<code>try-with-resources</code>可以不用写finally语法块，编译器会帮助生成关闭资源代码</p>
<pre><code class="language-java">public class Candy9 {
    public static void main(String[] args) {
        try(InputStream is = new FileInputStream(&quot;d:\\1.txt&quot;)) {
            System.out.println(is);
        } catch (IOException e) {
            e.printStackTrace();
        } 
    }
}
</code></pre>
<p>会被转换为</p>
<pre><code class="language-java">public class Candy9 {
    public Candy9() {
    }
    public static void main(String[] args) {
        try {
            InputStream is = new FileInputStream(&quot;d:\\1.txt&quot;);
            Throwable t = null;
            try {
                System.out.println(is);
            } catch (Throwable e1) {
                // t 是我们代码出现的异常 
                t = e1;
                throw e1;
            } finally {
                // 判断了资源不为空 
                if (is != null) {
                	// 如果我们代码有异常 
                    if (t != null) {
                        try {
                            is.close();
                        } catch (Throwable e2) {
                            // 如果 close 出现异常，作为被压制异常添加 
                            t.addSuppressed(e2);
                        }
                    } else {
                        // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e
                        is.close();
                    }
                } 
            }
        } catch (IOException e) {
            e.printStackTrace();
        } 
    }
}
</code></pre>
<p>为什么要设计一个<code>addSuppressed(Throwable e)</code>(添加被压制异常)的方法：</p>
<ul>
<li>是为了防止异常信息的丢失(想想 <code>try-with-resources</code> 生成的 fianlly 中如果抛出了异常)</li>
</ul>
<pre><code class="language-java">public class Test6 {
    public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            int i = 1/0;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
class MyResource implements AutoCloseable {
    public void close() throws Exception {
        throw new Exception(&quot;close 异常&quot;); 
    }
}
</code></pre>
<p>输出：</p>
<pre><code>java.lang.ArithmeticException: / by zero
at test.Test6.main(Test6.java:7) Suppressed: java.lang.Exception: close 异常
        at test.MyResource.close(Test6.java:18)
        at test.Test6.main(Test6.java:6)
</code></pre>
<p>如以上代码所示，两个异常信息都不会丢失<br>
<a name="uSvAb"></a></p>
<h2 id="方法重写时的桥接方法">方法重写时的桥接方法</h2>
<p>我们都知道，方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是夫类返回值的子类</li>
</ul>
<pre><code class="language-java">class A {
    public Number m() {
        return 1; 
    }
}

class B extends A {
    @Override
    // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 
    public Integer m() {
        return 2; 
    }
}
</code></pre>
<p>对于子类，java编译器会做如下处理</p>
<pre><code class="language-java">class B extends A {
    public Integer m() {
        return 2; 
    }
    // 此方法才是真正重写了父类 public Number m() 方法 
    public synthetic bridge Number m() {
        // 调用 public Integer m()
        return m(); 
    }
}
</code></pre>
<p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证</p>
<pre><code class="language-java">for (Method m : B.class.getDeclaredMethods()) {
    System.out.println(m);
}
</code></pre>
<pre><code class="language-java">public java.lang.Integer test.candy.B.m()
public java.lang.Number test.candy.B.m()
</code></pre>
<p><a name="BB6iR"></a></p>
<h2 id="匿名内部类">匿名内部类</h2>
<pre><code class="language-java">public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;ok&quot;);
            } 
        };
    } 
}
</code></pre>
<p>转换后的代码</p>
<pre><code class="language-java">// 额外生成的类
final class Candy11$1 implements Runnable {
    Candy11$1() {
    }
    public void run() {
        System.out.println(&quot;ok&quot;);
    }
}

public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Candy11$1();
    }
}
</code></pre>
<p>引用局部变量的匿名内部类，源代码：</p>
<pre><code class="language-java">public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;ok:&quot; + x);
            } 
        };
    } 
}
</code></pre>
<p>转换后的代码</p>
<pre><code class="language-java">// 额外生成的类
final class Candy11$1 implements Runnable {
    int val$x;
    Candy11$1(int x) {
        this.val$x = x;
    }
    public void run() {
        System.out.println(&quot;ok:&quot; + this.val$x);
    } 
}

public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Candy11$1(x);
    }
} 
</code></pre>
<blockquote>
<p>注意<br>
这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的:因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">的</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">1 对象的 val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>x 属性，所以 x 不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化</p>
</blockquote>
<p><a name="qbnE6"></a></p>
<h1 id="类加载阶段">类加载阶段</h1>
<p><a name="LjtrV"></a></p>
<h2 id="加载">加载</h2>
<ul>
<li>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有:
<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用</li>
<li>_super 即父类</li>
<li>_fields 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法表</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
</ul>
<blockquote>
<p>注意<br>
instanceKlass这样的【元数据】是存储在方法区(1.8后的元空间内)，但_java_mirror是存储在堆中的<br>
可以通过HSDB工具来查看</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645887896636-54eb1b6f-2abc-4a08-9b68-699d374b2b65-20220312195357603.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>Person.class有instanceKlass的地址信息，_java_mirror中有Person.class的地址信息</li>
<li>对象实例化后，有一个对象头，其中包含了class地址，如果想获取class信息那就会根据对象头中的class地址来获取person.class再间接到元空间找到instanceKlass，从元空间中找method等信息<br>
<a name="XqSCX"></a></li>
</ul>
<h2 id="链接">链接</h2>
<p><a name="Cf47b"></a></p>
<h3 id="验证">验证</h3>
<p>验证类是否符合JVM规范，安全性检查<br />用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p>
<pre><code>E:\git\jvm\out\production\jvm&gt;java cn.itcast.jvm.t5.HelloWorld
Error: A JNI error has occurred, please check your installation and try again
Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value
3405691578 in class file cn/itcast/jvm/t5/HelloWorld
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
				at java.security.AccessController.doPrivileged(Native Method)
				at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
				at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
				at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
				at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
				at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)
</code></pre>
<p><a name="YNnzr"></a></p>
<h3 id="准备">准备</h3>
<ul>
<li>为 static 变量分配空间，设置默认值
<ul>
<li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾</li>
<li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成<br>
<a name="khjyD"></a></li>
</ul>
</li>
</ul>
<h3 id="解析">解析</h3>
<p>将常量池中的符号引用解析为直接引用(直接引用可以知道在内存中的位置)</p>
<pre><code class="language-java">package cn.itcast.jvm.t3.load;
/**
* 解析的含义 */
public class Load2 {
    public static void main(String[] args) throws ClassNotFoundException,
IOException {
    	ClassLoader classloader = Load2.class.getClassLoader();
    	// loadClass 方法不会导致类的解析和初始化
    	Class&lt;?&gt; c = classloader.loadClass(&quot;cn.itcast.jvm.t3.load.C&quot;);
    	
    	//会进行类的解析和初始化
    	// new C();

    	System.in.read();
    }
}

class C {
    D d = new D();
}

class D { 

}
</code></pre>
<p><a name="WeYIm"></a></p>
<h2 id="初始化">初始化</h2>
<p><cinit>()V方法<br />初始化即调用<code>&lt;cinit&gt;()V方法</code>，虚拟机会保证这个类的【构造方法】的线程安全<br>
<a name="mn12B"></a></p>
<h3 id="发生的时机">发生的时机</h3>
<ul>
<li>概括得说，类初始化是【懒惰的】
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时，会导致这个类的初始化</li>
<li>子类初始化，如果父类还没初始化，会引发父类的初始化</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
</li>
<li>不会导致类初始化的情况
<ul>
<li>访问类的 static final 静态常量(基本类型和字符串)不会触发初始化</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 loadClass 方法</li>
<li>Class.forName 的参数 2 为 false 时<br>
<a name="peYbL"></a></li>
</ul>
</li>
</ul>
<h3 id="实验">实验</h3>
<pre><code class="language-java">class A {
    static int a = 0;
    static {
        System.out.println(&quot;a init&quot;);
    }
}
class B extends A {
    final static double b = 5.0;
    static boolean c = false;
    static {
        System.out.println(&quot;b init&quot;);
    }
}
</code></pre>
<p>验证(实验时请先全部注释，每次只执行其中一个)</p>
<pre><code class="language-java">public class Load3 {
    static {
        System.out.println(&quot;main init&quot;);
    }
	public static void main(String[] args) throws ClassNotFoundException { 
        
        // 1. 静态常量(基本类型和字符串)不会触发初始化
		System.out.println(B.b);
		// 2. 类对象.class 不会触发初始化
		System.out.println(B.class);
		// 3. 创建该类的数组不会触发初始化
		System.out.println(new B[0]);
		// 4. 不会初始化类 B，但会加载 B、A
		ClassLoader cl = Thread.currentThread().getContextClassLoader();
        cl.loadClass(&quot;cn.itcast.jvm.t3.B&quot;);
		// 5. 不会初始化类 B，但会加载 B、A
		ClassLoader c2 = Thread.currentThread().getContextClassLoader(); 
        Class.forName(&quot;cn.itcast.jvm.t3.B&quot;, false, c2);
		// 1. 首次访问这个类的静态变量或静态方法时 
        System.out.println(A.a);
		// 2. 子类初始化，如果父类还没初始化，会引发 
        System.out.println(B.c);
		// 3. 子类访问父类静态变量，只触发父类初始化 
        System.out.println(B.a);
		// 4. 会初始化类 B，并先初始化类 A 
        Class.forName(&quot;cn.itcast.jvm.t3.B&quot;);
    }
}
</code></pre>
<p><a name="AmR2B"></a></p>
<h2 id="练习-2">练习</h2>
<p>从字节码分析，使用a，b，c这三个常量是否会导致E初始化</p>
<pre><code class="language-java">public class Load4 {
    public static void main(String[] args) {
        System.out.println(E.a);
        System.out.println(E.b);
        System.out.println(E.c);
    } 
}
class E {
    //不会
    public static final int a = 10;
    //不会
    public static final String b = &quot;hello&quot;;
    //会
    //Integer.valueOf(20)
    public static final Integer c = 20;
}
</code></pre>
<p>典型应用-完成懒惰初始化单例模式</p>
<pre><code class="language-java">public final class Singleton { 
    private Singleton() { }
    // 内部类中保存单例
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }
    //如果只调用外部类中的静态方法，会导致外部类的初始化，并不会导致内部类的初始化
	// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
</code></pre>
<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>初始化时的线程安全是有保障的<br>
<a name="mG2G8"></a></li>
</ul>
<h1 id="类加载器">类加载器</h1>
<p>以JDK8为例：</p>
<ul>
<li>类加载器各自加载对应位置的类</li>
<li>有层级关系，低级加载器加载类时会问上级加载器是否加载过该类(例如，Application ClassLoader询问Extension ClassLoader是否加载，然后Extension ClassLoader 询问 Bootstrap ClassLoader)</li>
<li>如果上级均未加载，那么才让低级加载器加载该类</li>
<li>这就是双亲委派模型</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645957908084-4f81f0be-a643-4df7-a3e8-bd1f81c40030-20220312195357653.png" alt="image.png" loading="lazy"><br>
<a name="XA4xA"></a></p>
<h2 id="启动类加载器bootstrap-classloader">启动类加载器(Bootstrap ClassLoader)</h2>
<p>用Bootstrap类加载器加载类</p>
<pre><code class="language-java">package cn.itcast.jvm.t3.load;
public class F {
    static {
        System.out.println(&quot;bootstrap F init&quot;);
    }
}
</code></pre>
<p>执行</p>
<pre><code class="language-java">package cn.itcast.jvm.t3.load;
public class Load5_1 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.F&quot;);
        //获取加载该类的类加载器
        System.out.println(aClass.getClassLoader());
    } 
}
</code></pre>
<p>输出</p>
<pre><code>E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5
bootstrap F init
null
</code></pre>
<ul>
<li>-Xbootclasspath表示设置bootclasspath</li>
<li>其中/a:.表示将当前目录追加至bootclasspath之后</li>
<li>可以用这个办法替换核心类
<ul>
<li><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code></li>
<li><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code> /a为后追加</li>
<li><code>java -Xbootclasspath/p:&lt;追加路径&gt;</code> /p为前追加，可以用来替换一些核心类<br>
<a name="VlKvq"></a></li>
</ul>
</li>
</ul>
<h2 id="扩展类加载器">扩展类加载器</h2>
<pre><code class="language-java">package cn.itcast.jvm.t3.load;
public class G {
    static {
        System.out.println(&quot;classpath G init&quot;);
    }
}
</code></pre>
<p>执行</p>
<pre><code class="language-java">public class Load5_2 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.G&quot;);
        System.out.println(aClass.getClassLoader());
    }
}
</code></pre>
<p>输出</p>
<pre><code>classpath G init
sun.misc.Launcher$AppClassLoader@18b4aac2
</code></pre>
<p>写一个同名的类</p>
<pre><code class="language-java">package cn.itcast.jvm.t3.load;
public class G {
    static {
        System.out.println(&quot;ext G init&quot;);
    }
}
</code></pre>
<p>打个jar包</p>
<pre><code>E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class
已添加清单
正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%)
</code></pre>
<p>将jar包拷贝到 JAVA_HOME/jre/lib/ext<br />重新执行Load5_2<br />输出</p>
<pre><code>ext G init
sun.misc.Launcher$ExtClassLoader@29453f44
</code></pre>
<p><a name="d6tvW"></a></p>
<h2 id="双亲委派模型">双亲委派模型</h2>
<p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p>
<ul>
<li>委派上级做类的加载</li>
<li>如果上级没有，那么由本级的类加载器加载</li>
</ul>
<blockquote>
<p>注意<br>
这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p>
</blockquote>
<pre><code class="language-java">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) { 
        // 1. 检查该类是否已经加载
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 2. 有上级的话，委派上级 
                    loadClass c = parent.loadClass(name, false);
                } else {
                    // 3. 如果没有上级了(ExtClassLoader)，则委派BootstrapClassLoader
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }
            if (c == null) {
                long t1 = System.nanoTime();
                // 4. 每一层找不到，调用 findClass 方法(每个类加载器自己扩展)来加载 
                c = findClass(name);
                // 5. 记录耗时 
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); 
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); 
                sun.misc.PerfCounter.getFindClasses().increment();
            } 
        }
        if (resolve) {
            resolveClass(c);
        }
        return c; 
    }
}
</code></pre>
<p>例如</p>
<pre><code class="language-java">public class Load5_3 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class&lt;?&gt; aClass = Load5_3.class.getClassLoader()
            .loadClass(&quot;cn.itcast.jvm.t3.load.H&quot;);
        System.out.println(aClass.getClassLoader());
    } 
}
</code></pre>
<p>执行流程为</p>
<pre><code>1. sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有
2. sun.misc.Launcher$AppClassLoader // 2 处，委派上级
   sun.misc.Launcher$ExtClassLoader.loadClass()
3. sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有
4. sun.misc.Launcher$ExtClassLoader // 3 处，没有上级了，则委派 BootstrapClassLoader查找
5. BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有
6. sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在
	 JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader
	 的 // 2 处
7. 继续执行到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在
	 classpath 下查找，找到了
</code></pre>
<p><a name="MfxPE"></a></p>
<h2 id="线程上下文类加载器">线程上下文类加载器</h2>
<p>我们在使用JDBC时，都需要加载Driver驱动，但是，不写</p>
<pre><code class="language-java">Class.forName(&quot;com.mysql.jdbc.Driver&quot;)
</code></pre>
<p>也是可以让<code>com.mysql.jdbc.Driver</code>正确加载的</p>
<pre><code class="language-java">public class DriverManager {
// 注册驱动的集合
private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers
        = new CopyOnWriteArrayList&lt;&gt;();
	// 初始化驱动 
    static {
        loadInitialDrivers();
        println(&quot;JDBC DriverManager initialized&quot;);
    }
</code></pre>
<p>先不看别的，看看DriverManager的类加载器</p>
<pre><code class="language-java">System.out.println(DriverManager.class.getClassLoader());
</code></pre>
<p>打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢?<br />继续看loadInitialDrivers()方法</p>
<pre><code class="language-java">private static void loadInitialDrivers() {
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;(){
            public String run() {
                return System.getProperty(&quot;jdbc.drivers&quot;);
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }
    // 1)使用 ServiceLoader 机制加载驱动，即 SPI 
    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
        public Void run() {
            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();
            try{
                while(driversIterator.hasNext()) {
                    //也破坏了双亲委派模型
                    driversIterator.next();
                }
            } catch(Throwable t) {
                // Do nothing
            }
            return null;
        }
    });
    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);
    // 2)使用 jdbc.drivers 定义的驱动名加载驱动
    if (drivers == null || drivers.equals(&quot;&quot;)) {
        return; 
    }
    String[] driversList = drivers.split(&quot;:&quot;);
    println(&quot;number of Drivers:&quot; + driversList.length);
    for (String aDriver : driversList) {
        try {
            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);
            // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 
            Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());
        } catch (Exception ex) {
            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);
        } 
    } 
}
</code></pre>
<ul>
<li>先看 2)发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载，打破了双亲委派模型</li>
<li>再看 1)它就是大名鼎鼎的 Service Provider Interface (SPI) 约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名为文件名，文件内容是实现类名称</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645962350246-d25040bf-1b06-4517-9270-0a555a778d88-20220312195357777.png" alt="image.png" loading="lazy"><br />这样就可以使用</p>
<pre><code class="language-java">//找到接口的所有实现类
ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class); 
Iterator&lt;接口类型&gt; iter = allImpls.iterator();
while(iter.hasNext()) {
    //每次调用了迭代器，就可以返回实现类的实例
    iter.next();
}
</code></pre>
<p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想:</p>
<ul>
<li>JDBC</li>
<li>Servlet 初始化器</li>
<li>Spring 容器</li>
<li>Dubbo(对 SPI 进行了扩展)</li>
</ul>
<p>接着看 ServiceLoader.load 方法:</p>
<pre><code class="language-java">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
	// 获取线程上下文类加载器(默认就是应用程序类加载器)
    // 在线程启动时，jvm会把应用程序类加载器复制给当前线程
	ClassLoader cl = Thread.currentThread().getContextClassLoader(); 
    return ServiceLoader.load(service, cl);
}
</code></pre>
<p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中:</p>
<pre><code class="language-java">private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&lt;?&gt; c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {&quot;Provider &quot; + cn + &quot; not found&quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service, 
             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
    } try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
             x);
    }
    throw new Error();          // This cannot happen
}
</code></pre>
<p><a name="Ym5It"></a></p>
<h2 id="自定义类加载器">自定义类加载器</h2>
<p>什么时候需要自定义类加载器</p>
<ol>
<li>想加载非classpath随意路径中的类文件</li>
<li>都是通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于tomcat容器</li>
</ol>
<p>步骤：</p>
<ol>
<li>继承 ClassLoader 父类</li>
<li>要遵从双亲委派机制，重写 findClass 方法
<ol>
<li>注意不是重写 loadClass 方法，否则不会走双亲委派机制</li>
</ol>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 defineClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ol>
<p>示例: <br />准备好两个类文件放入 E:\myclasspath，它实现了 java.util.Map 接口，可以先反编译看一下:<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645969043336-fdc5d884-e9c1-4eeb-9a8c-fb0b0db0094e-20220312195358048.png" alt="image.png" loading="lazy"></p>
<pre><code class="language-java">package cn.itcast.jvm.t3.load;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Load7 {
    public static void main(String[] args) throws Exception {
        MyClassLoader classLoader = new MyClassLoader();
        Class&lt;?&gt; c1 = classLoader.loadClass(&quot;MapImpl1&quot;);
        Class&lt;?&gt; c2 = classLoader.loadClass(&quot;MapImpl1&quot;);
        
        //true
        System.out.println(c1 == c2);

        MyClassLoader classLoader2 = new MyClassLoader();
        Class&lt;?&gt; c3 = classLoader2.loadClass(&quot;MapImpl1&quot;);
        
        //false，包名类名相同，且类加载器对象相同，才认为这是同一个类，不然认为是相互隔离的
        System.out.println(c1 == c3);

        c1.newInstance();
    }
}

//继承ClassLoader并重写findClass方法
class MyClassLoader extends ClassLoader {

    @Override // name 就是类名称
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        String path = &quot;e:\\myclasspath\\&quot; + name + &quot;.class&quot;;

        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Files.copy(Paths.get(path), os);

            // 得到字节数组
            byte[] bytes = os.toByteArray();

            // byte[] -&gt; *.class
            return defineClass(name, bytes, 0, bytes.length);

        } catch (IOException e) {
            e.printStackTrace();
            throw new ClassNotFoundException(&quot;类文件未找到&quot;, e);
        }
    }
}

</code></pre>
<p><a name="W2Wqr"></a></p>
<h1 id="运行期优化">运行期优化</h1>
<p><a name="RyZ3t"></a></p>
<h2 id="即时编译">即时编译</h2>
<p><a name="Nflf0"></a></p>
<h3 id="分层编译tieredcompilation">分层编译(TieredCompilation)</h3>
<pre><code class="language-java">public class JIT1 {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 200; i++) {
            long start = System.nanoTime();
            for (int j = 0; j &lt; 1000; j++) {
                new Object();
            }
            long end = System.nanoTime();
            System.out.printf(&quot;%d\t%d\n&quot;,i,(end - start));
        }
    }
}
</code></pre>
<pre><code>0   96426
1   52907
2   44800
3   119040
4   65280
5   47360
6   45226
7   47786
8   48640
9   60586
10  42667
11  48640
12  70400
13  49920
14  49493
15  45227
16  45653
17  60160
18  58880
19  46080
20  47787
21  49920
22  54187
23  57173
24  50346
25  52906
26  50346
27  47786
28  49920
29  64000
30  49067
31  63574
32  63147
33  56746
34  49494
35  64853
36  107520
37  46933
38  51627
39  45653
40  103680
41  51626
42  60160
43  49067
44  45653
45  49493
46  51626
47  49066
48  47360
49  50774
50  70827
51  64000
52  72107
53  49066
54  46080
55  44800
56  46507
57  73813
58  61013
59  57600
60  83200
61  7024204
62  49493
63  20907
64  20907
65  20053
66  20906
67  20907
68  21333
69  22187
70  20480
71  21760
72  19200
73  15360
74  18347
75  19627
76  17067
77  34134
78  19200
79  18347
80  17493
81  15360
82  18774
83  17067
84  21760
85  23467
86  17920
87  17920
88  18774
89  18773
90  19200
91  20053
92  18347
93  22187
94  17920
95  18774
96  19626
97  33280
98  20480
99  20480
100 18773
101 47786
102 17493
103 22614
104 64427
105 18347
106 19200
107 26027
108 21333
109 20480
110 24747
111 32426
112 21333
113 17920
114 17920
115 19200
116 18346
117 15360
118 24320
119 19200
120 20053
121 17920
122 18773
123 20053
124 18347
125 18347
126 22613
127 18773
128 19627
129 20053
130 20480
131 19627
132 20053
133 15360
134 136533
135 43093
136 853
137 853
138 853
139 853
140 854
141 853
142 853
143 853
144 853
145 853
146 853
147 854
148 853
149 853
150 854
151 853
152 853
153 853
154 1280
155 853
156 853
157 854
158 853
159 853
160 854
161 854
162 853
163 854
164 854
165 854
166 854
167 853
168 853
169 854
170 853
171 853
172 853
173 1280
174 853
175 1280
176 853
177 854
178 854
179 427
180 853
181 854
182 854
183 854
184 853
185 853
186 854
187 853
188 853
189 854
190 1280
191 853
192 853
193 853
194 853
195 854
196 853
197 853
198 853
199 854
</code></pre>
<p>原因是什么呢?<br />JVM 将执行状态分成了 5 个层次:</p>
<ul>
<li>0 层，解释执行(Interpreter)
<ul>
<li>字节码加载到虚拟机，解释器将字节码解释为机器码</li>
<li>字节码被反复调用，到达一定阈值，就会启用编译器进行编译执行</li>
</ul>
</li>
<li>1 层，使用 C1 即时编译器编译执行(不带 profiling)</li>
<li>2 层，使用 C1 即时编译器编译执行(带基本的 profiling)</li>
<li>3 层，使用 C1 即时编译器编译执行(带完全的 profiling)</li>
<li>4 层，使用 C2 即时编译器编译执行
<ul>
<li>比C1优化程度更高</li>
</ul>
</li>
</ul>
<blockquote>
<p>profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
</blockquote>
<p>即时编译器(JIT)与解释器的区别</p>
<ul>
<li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译</li>
<li>解释器是将字节码解释为针对所有平台都通用的机器码</li>
<li>JIT 会根据平台类型，生成平台特定的机器码</li>
</ul>
<p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运 行;另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1(提升5倍左右高) &lt; C2(提升10-100倍)，总的目标是发现热点代码(hotspot名称的由来)，并优化之</p>
<p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸(外层是否会用到该对象)。可以使用 -XX:- DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p>
<p>参考资料：<a href="https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4">https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4</a></p>
<p><a name="D6YlW"></a></p>
<h3 id="方法内联inlining">方法内联(Inlining)</h3>
<pre><code class="language-java">private static int square(final int i) {
    return i * i;
}
</code></pre>
<pre><code class="language-java">System.out.println(square(9));
</code></pre>
<p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置:</p>
<pre><code class="language-java">//System.out.println(square(9))进行方法内联后
//变为
System.out.println(9 * 9);
</code></pre>
<p>还能够进行常量折叠(constant folding)的优化</p>
<pre><code class="language-java">//9固定不变，可以进行常量折叠的优化
System.out.println(81);
</code></pre>
<p>实验：</p>
<pre><code class="language-java">public class JIT2 {
    // -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining (解锁隐藏参数)打印inlining 信息
    // -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining *表示报名，JIT2为类名然后为方法名
    // -XX:+PrintCompilation 打印编译信息
    public static void main(String[] args) {
        int x = 0;
        for (int i = 0; i &lt; 500; i++) {
            long start = System.nanoTime();
            for (int j = 0; j &lt; 1000; j++) {
                x = square(9);
            }
        	long end = System.nanoTime();
        	System.out.printf(&quot;%d\t%d\t%d\n&quot;,i,x,(end - start));
    	}
	}
    private static int square(final int i) {
        return i * i;
    } 
}
</code></pre>
<p><a name="y6x4j"></a></p>
<h3 id="字段优化">字段优化</h3>
<p>字段优化为对成员变量和静态成员变量进行优化<br />JMH基准测试请参考<a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a><br />创建maven工程，添加依赖如下</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
    &lt;version&gt;${jmh.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;
    &lt;version&gt;${jmh.version}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>编写基准测试代码</p>
<pre><code class="language-java">package test;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
// 热身，让程序预热一段时间，让JIT对其进行充分的优化
@Warmup(iterations = 2, time = 1)
// 进行几轮测试
@Measurement(iterations = 5, time = 1)
@State(Scope.Benchmark)
public class Benchmark1 {
    int[] elements = randomInts(1_000);
    private static int[] randomInts(int size) {
        Random random = ThreadLocalRandom.current();
        int[] values = new int[size];
        for (int i = 0; i &lt; size; i++) {
            values[i] = random.nextInt();
        }
        return values;
    }
    
	@Benchmark
    public void test1() {
        for (int i = 0; i &lt; elements.length; i++) {
            doSum(elements[i]);
        }
	}
    
	@Benchmark
    public void test2() {
        int[] local = this.elements;
        for (int i = 0; i &lt; local.length; i++) {
            doSum(local[i]);
        }
	}
    
	@Benchmark
    public void test3() {
        for (int element : elements) {
            doSum(element);
        }
    }
    
    static int sum = 0;
    
    // 控制是否进行内联
    @CompilerControl(CompilerControl.Mode.INLINE)
    static void doSum(int x) {
        sum += x; 
    }
    
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(Benchmark1.class.getSimpleName())
                .forks(1)
                .build();
        new Runner(opt).run();
    }
}
</code></pre>
<p>首先启用doSum的方法内联，测试结果如下(每秒吞吐量，分数越高越好)</p>
<pre><code>Benchmark              Mode  	Samples        Score  Score error  Units
t.Benchmark1.test1    thrpt					5  2420286.539   390747.467  ops/s
t.Benchmark1.test2    thrpt					5  2544313.594    91304.136  ops/s
t.Benchmark1.test3    thrpt					5  2469176.697   450570.647  ops/s
</code></pre>
<p>接下来禁用doSum方法内联</p>
<pre><code class="language-java">//禁用内联
@CompilerControl(CompilerControl.Mode.DONT_INLINE)
static void doSum(int x) {
    sum += x; 
}
</code></pre>
<p>测试结果如下</p>
<pre><code>Benchmark              Mode  	Samples       Score  Score error  Units
t.Benchmark1.test1    thrpt					5  296141.478    63649.220  ops/s
t.Benchmark1.test2    thrpt					5  371262.351    83890.984  ops/s
t.Benchmark1.test3    thrpt					5  368960.847    60163.391  ops/s
</code></pre>
<p>分析：<br />在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化: 如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子(伪代码):</p>
<pre><code class="language-java">@Benchmark
public void test1() {
    // elements.length 首次读取会缓存起来 -&gt; int[] local
    for (int i = 0; i &lt; elements.length; i++) { // 后续 999 次 求长度 &lt;- local
		sum += elements[i]; // 1000 次取下标 i 的元素 &lt;- local 
    }	
}
</code></pre>
<p>可以节省1999次Field读取操作<br />但如果doSum方法没有内联，则不会进行上面的优化</p>
<p>练习:在内联情况下将 elements 添加 volatile 修饰符，观察测试结果</p>
<p><a name="wGyBB"></a></p>
<h2 id="反射优化">反射优化</h2>
<pre><code class="language-java">package cn.itcast.jvm.t3.reflect;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class Reflect1 {
    public static void foo() {
        System.out.println(&quot;foo...&quot;);
    }
    public static void main(String[] args) throws Exception {
        Method foo = Reflect1.class.getMethod(&quot;foo&quot;);
        for (int i = 0; i &lt;= 16; i++) {
            System.out.printf(&quot;%d\t&quot;, i);
            foo.invoke(null);
        }
        System.in.read();
    }
}
</code></pre>
<p>foo.invoke前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<pre><code class="language-java">package sun.reflect;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import sun.reflect.misc.ReflectUtil;
class NativeMethodAccessorImpl extends MethodAccessorImpl {
    private final Method method;
    private DelegatingMethodAccessorImpl parent;
    private int numInvocations;
    NativeMethodAccessorImpl(Method method) {
        this.method = method;
	}
    public Object invoke(Object target, Object[] args) 
        throws IllegalArgumentException, InvocationTargetException {
        // inflationThreshold 膨胀阈值，默认 15
        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold()
            &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())){
            // 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右 
            MethodAccessorImpl generatedMethodAccessor =
                (MethodAccessorImpl)
                    (new MethodAccessorGenerator())
                        .generateMethod(
                            this.method.getDeclaringClass(),
                            this.method.getName(),
                            this.method.getParameterTypes(),
                            this.method.getReturnType(),
                            this.method.getExceptionTypes(),
                            this.method.getModifiers()
                        );
            this.parent.setDelegate(generatedMethodAccessor);
        }
        // 调用本地实现
    	return invoke0(this.method, target, args);
    }
    
    void setParent(DelegatingMethodAccessorImpl parent) {
        this.parent = parent;
    }
    private static nat ive Object invoke0(Method method, Object target, Object[] args);
}
</code></pre>
<p>当调用到第 16 次(从0开始算)时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1<br />可以使用阿里的 arthas 工具:</p>
<pre><code>java -jar arthas-boot.jar
[INFO] arthas-boot version: 3.1.1
[INFO] Found existing java process, please choose one and hit RETURN.
* [1]: 13065 cn.itcast.jvm.t3.reflect.Reflect1
</code></pre>
<p>选择1回车表示分析该进程</p>
<pre><code>1
[INFO] arthas home: /root/.arthas/lib/3.1.1/arthas
[INFO] Try to attach process 13065
[INFO] Attach process 13065 success.
[INFO] arthas-client connect 127.0.0.1 3658

wiki      https://alibaba.github.io/arthas
tutorials https://alibaba.github.io/arthas/arthas-tutorials
version   3.1.1
pid       13065
time      2019-06-10 12:23:54
</code></pre>
<p>在输入【jad+类名】来进行反编译</p>
<pre><code class="language-java">$ jad sun.reflect.GeneratedMethodAccessor1
ClassLoader:
+-sun.reflect.DelegatingClassLoader@15db9742
  +-sun.misc.Launcher$AppClassLoader@4e0e2f2a
    +-sun.misc.Launcher$ExtClassLoader@2fdb006e
Location:
/*
 * Decompiled with CFR 0_132.
 *
 * Could not load the following classes:
 *  cn.itcast.jvm.t3.reflect.Reflect1
 */
package sun.reflect;
import cn.itcast.jvm.t3.reflect.Reflect1;
import java.lang.reflect.InvocationTargetException;
import sun.reflect.MethodAccessorImpl;
public class GeneratedMethodAccessor1
extends MethodAccessorImpl {
    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
  public Object invoke(Object object, Object[] arrobject) 
    throws InvocationTargetException {
    // 比较奇葩的做法，如果有参数，那么抛非法参数异常 
    block4 : {
      if (arrobject == null || arrobject.length == 0) break block4;
      throw new IllegalArgumentException();
    }
    try {
      // 可以看到，已经是直接调用了😱😱😱 
      Reflect1.foo();
      // 因为没有返回值
      return null;
    }
    catch (Throwable throwable) {
      throw new InvocationTargetException(throwable);
    }
    catch (ClassCastException | NullPointerException runtimeException) {
      throw new IllegalArgumentException(Object.super.toString());
    } 
  }
}
Affect(row-cnt:1) cost in 1540 ms.
</code></pre>
<blockquote>
<p>注意<br>
通过查看 ReflectionFactory 源码可知</p>
<ul>
<li>sun.reflect.noInflation 可以用来禁用膨胀(直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算)</li>
<li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM垃圾回收]]></title>
        <id>https://yeyuan1107.github.io/post/jvm-la-ji-hui-shou/</id>
        <link href="https://yeyuan1107.github.io/post/jvm-la-ji-hui-shou/">
        </link>
        <updated>2022-02-22T13:10:23.000Z</updated>
        <content type="html"><![CDATA[<p><a name="Dee1j"></a></p>
<h1 id="如何判断对象可以回收">如何判断对象可以回收</h1>
<p><a name="KDBNf"></a></p>
<h2 id="引用计数法">引用计数法</h2>
<p>只要一个对象被其他变量所引用，那么该对象的计数加一，否则减一。当该对象引用计数变为0，那么就说明没有变量引用，可以当作垃圾回收<br>
<a name="GVYSe"></a></p>
<h3 id="存在问题">存在问题</h3>
<figure data-type="image" tabindex="1"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645603195966-317f5292-8997-4090-a195-d02fb97e6015-20220312195236110.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>循环引用造成内存泄漏</li>
<li>当没有变量引用A对象，也没有变量引用B对象，但是A和B相互引用，引用计数器为1，无法对其进行垃圾回收，导致内存泄漏<br>
<a name="LQ6se"></a></li>
</ul>
<h2 id="可达性分析算法">可达性分析算法</h2>
<ul>
<li>Java所使用的方法</li>
<li>确定一系列根对象(肯定不能当作垃圾回收的对象)，垃圾回收前首先对堆中所有对象进行扫描，看看每一个对象是否被根对象直接或者间接的引用。如果没有被根对象直接或间接的引用，那么就可以当作垃圾回收</li>
<li>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</li>
<li>可以被作为GC Root的对象(工具Memory Analyzer 可视化Java堆分析工具)
<ul>
<li>System Class：系统类、核心类</li>
<li>Native Stack：本地方法引用的一些对象</li>
<li>Busy Monitor：加锁的对象</li>
<li>Thread：活动线程中的对象<br>
<a name="CkjCo"></a></li>
</ul>
</li>
</ul>
<h2 id="四种引用">四种引用</h2>
<ol>
<li>强引用
<ol>
<li>只有所有GC Roots 对象都不通过【强号1用1引1用该对象，该对象才能被垃圾回收</li>
</ol>
</li>
<li>软引用 (SoftReference)
<ol>
<li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li>
<li>可以配合引用队列来释放软引用自身</li>
</ol>
</li>
<li>弱引用 (WeakReference)
<ol>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引1用自身</li>
</ol>
</li>
<li>虛引用 (PhantomReference)
<ol>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由<br />Reference Handler 线程调用虚引用相关方法释放直接内存</li>
</ol>
</li>
<li>终结器引用 (FinalReference)
<ol>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引1用入队（被引1用对象暂时没有<br />被回收），再由 Finalizer 线程通过终结器引1用找到被引1用对象并调用它的finalize 方法，第二次GC 时才能回收被引用对象</li>
</ol>
</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645604622637-56b774e8-e033-4af2-b34d-81ce05d26bab-20220312195236455.png" alt="image.png" loading="lazy"><br />实线表示强引用<br>
<a name="cNooy"></a></p>
<h3 id="强引用">强引用</h3>
<ul>
<li>日常引用基本都为强引用，比如：new一个对象，对象通过赋值给一个变量，那么该变量强引用这个对象</li>
<li>只要沿着GC Root的引用链可以找到该对象，那么该对象就不会被回收</li>
<li>GC Root对他的引用都断开时，当垃圾回收发生时，该对象被回收<br>
<a name="labEX"></a></li>
</ul>
<h3 id="软-弱引用">软、弱引用</h3>
<ul>
<li>只要对象没有没有被直接的强引用所引用，当垃圾回收发生时，都有可能被回收</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645606649699-466a5547-db23-4e24-ba9e-b444bfd7b86e-20220312195236779.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>软引用：没有强引用引用他，发生垃圾回收且垃圾回收后内存不足，就会回收软引用引用的对象</li>
<li>弱引用：没有强引用引用他，发生垃圾回收，不管内存是否充足，都会回收弱引用引用的对象</li>
<li>软、弱引用的对象被回收后，软、弱引用就会被放入引用队列，如果想要释放软、弱引用，需要使用引用队列进行释放</li>
<li>可以配合引用队列使用，也可以不配合引用队列使用<br>
<a name="AIm45"></a></li>
</ul>
<h4 id="软引用的应用">软引用的应用</h4>
<pre><code class="language-java">//byte[]使用强引用，可能造成OutOfMemoryError
//list 强引用--&gt; byte[]
List&lt;byte[]&gt; list;

//list 强引用--&gt; SoftReference 软引用--&gt; byte[]
//不会造成OutOfMemoryError，当内存不足时byte[]会被垃圾回收
List&lt;SoftReference&lt;byte[]&gt;&gt; list
</code></pre>
<p><a name="ThDRd"></a></p>
<h4 id="软引用引用队列">软引用引用队列</h4>
<pre><code class="language-java">ReferenceQueue&lt;byte[]&gt; queue
//希望在byte[]被清理时，对应的SoftReference&lt;byte[]&gt;也被清理
List&lt;SoftReference&lt;byte[]&gt;&gt; list
//软引用对象关联了软引用队列，当软引用所关联的byte[]被回收时，软引用会加入到queue中去
SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[], queue);
//从队列中获取无用的软引用对象，并移除
Referecne&lt;? extends byte[]&gt; poll = queue.poll();
while(poll != null){
    //移除列表中的软引用对象
    list.remove(poll);
    poll = queue.poll();
}
</code></pre>
<p><a name="IGTJN"></a></p>
<h4 id="弱引用的应用">弱引用的应用</h4>
<pre><code class="language-java">//byte[]使用强引用，可能造成OutOfMemoryError
//list 强引用--&gt; byte[]
List&lt;byte[]&gt; list;

//list 强引用--&gt; WeakReference 弱引用--&gt; byte[]
//不会造成OutOfMemoryError，byte[]没有被强引用时，会被垃圾回收
//在垃圾回收时会进行垃圾回收
//弱引用的引用队列与软引用类似
List&lt;WeakReference&lt;byte[]&gt;&gt; list
</code></pre>
<p><a name="NSHeJ"></a></p>
<h3 id="虚引用">虚引用</h3>
<ol>
<li>当ByteBuffer对象创建，会产生一个Cleaner的虚引用对象，ByteBuffer会产生一块直接内存，并把直接内存地址传递给虚引用对象</li>
</ol>
<figure data-type="image" tabindex="3"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645605803852-3bc4837a-4519-4c8f-83d5-4794b885e43e-20220312195237090.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>当ByteBuffer没有被强引用，ByteBuffer可以被垃圾回收掉</li>
</ol>
<figure data-type="image" tabindex="4"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645605918244-b702c4b9-14bc-4ecc-879d-7840d277686d-20220312195237416.png" alt="image.png" loading="lazy"></figure>
<ol start="3">
<li>ByteBuffer被垃圾回收后，虚引用对象Cleaner进入到引用队列。</li>
<li>ReferenceHandler会定时查看引用队列是否有虚引用对象Cleaner，如果有就调用其中的clean方法，从而释放直接内存</li>
</ol>
<figure data-type="image" tabindex="5"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645606114585-c64711bb-e14d-433c-ba62-9551d5bc4dd1-20220312195237744.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>与软、弱引用不同，虚引用必须配合引用队列使用<br>
<a name="Tcntl"></a></li>
</ul>
<h3 id="终结器引用">终结器引用</h3>
<ol>
<li>当一个对象没有被强引用，且重写了finalize()方法，JVM会创建终结器引用</li>
</ol>
<figure data-type="image" tabindex="6"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645606418844-28eed4aa-ec58-48b1-9886-212b1dd29359-20220312195237873.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>当被垃圾回收时，将终结器引用放入队列</li>
</ol>
<figure data-type="image" tabindex="7"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645606440872-e3eda565-e279-4c96-ba33-8cbd3b33019b-20220312195238154.png" alt="image.png" loading="lazy"></figure>
<ol start="3">
<li>再由一个优先级很低的线程FinalizeHandler的线程查看引用队列中是否有终结器引用，如果有就找到对象调用对象的finalize()方法，在下一次垃圾回收时，就把该对象占用的内存真正回收掉了<br>
<a name="PI68T"></a></li>
</ol>
<h1 id="垃圾回收算法">垃圾回收算法</h1>
<p>JVM会根据具体情况在下面三种方法中选择适当的垃圾回收算法来进行垃圾回收<br>
<a name="BvQek"></a></p>
<h2 id="标记清除算法mark-sweep">标记清除算法(Mark Sweep)</h2>
<ol>
<li>标记，将没有被GC Root引用的对象标记出来</li>
</ol>
<figure data-type="image" tabindex="8"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645614249994-b3ca2518-99b8-4bb5-a74b-3395fb22246f-20220312195238191.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>清除，将标记的对象进行清除，将对应内存的开始和结束地址放入空闲地址列表即可</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645614336971-9345a045-21c1-4380-b001-dc111958a874-20220312195238907.png" alt="image.png" loading="lazy"><br>
<a name="kHn3e"></a></p>
<h3 id="优点">优点</h3>
<p>速度快<br>
<a name="QnOO4"></a></p>
<h3 id="缺点">缺点</h3>
<p>会造成内存碎片<br>
<a name="Z2EjA"></a></p>
<h2 id="标记整理算法mark-compact">标记整理算法(Mark Compact)</h2>
<ol>
<li>标记，将没有被GC Root引用的对象标记出来</li>
</ol>
<figure data-type="image" tabindex="9"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645614514893-91de49b5-c9c8-4849-ac6a-dfd654563c2a-20220312195238966.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>整理，将标记的对象进行清除，同时进行整理</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645614584722-79908789-bffb-46f3-965f-112d57eb6b5d-20220312195239019.png" alt="image.png" loading="lazy"><br>
<a name="AWOOl"></a></p>
<h3 id="优点-2">优点</h3>
<p>解决内存碎片的问题<br>
<a name="I7DzR"></a></p>
<h3 id="缺点-2">缺点</h3>
<p>由于整理涉及到对象的移动，导致效率较低<br>
<a name="NESOw"></a></p>
<h2 id="复制算法copy">复制算法(Copy)</h2>
<ol>
<li>将内存区域划分为大小相等的两块区域，一块为FROM另一块为TO</li>
<li>标记，将没有被GC Root引用的对象标记出来</li>
</ol>
<figure data-type="image" tabindex="10"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645614944342-0e6ea7d4-650e-40fc-8f5c-ceb16d98183f-20220312195239068.png" alt="image.png" loading="lazy"></figure>
<ol start="3">
<li>把FROM中存活的对象复制(复制过程中也会进行整理)到TO中，然后清除FROM中的对象</li>
</ol>
<figure data-type="image" tabindex="11"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645615121705-e0866db1-3d26-4356-a562-cce9979e69b3-20220312195239360.png" alt="image.png" loading="lazy"></figure>
<ol start="4">
<li>TO变为FROM，FROM变TO</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645615197185-3b1414e9-4d30-4f85-9ab3-eee572d91525-20220312195239427.png" alt="image.png" loading="lazy"><br>
<a name="iFMBG"></a></p>
<h3 id="优点-3">优点</h3>
<p>不会产生内存碎片<br>
<a name="gx36P"></a></p>
<h3 id="缺点-3">缺点</h3>
<p>占用双倍的内存空间<br>
<a name="XGUe7"></a></p>
<h1 id="分代回收">分代回收</h1>
<figure data-type="image" tabindex="12"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645615499390-3d20ec05-fb67-4115-b640-21a13ea7e9f9-20220312195239483.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>新生代垃圾回收更为频繁，回收一次耗时较少</li>
<li>老年代垃圾回收频率较低，回收一次耗时较多</li>
</ul>
<ol>
<li>新创建的对象，存放在伊甸园当中</li>
<li>当继续创建对象时发现伊甸园内的内存空间不足，就会触发一次垃圾回收(Minor GC)
<ol>
<li>Minor GC根据可达性分析算法，对对象进行标记</li>
<li>使用复制算法把存活的对象复制到幸存区TO中，同时将这些对象的寿命+1</li>
<li>幸存区FROM变为TO，TO变成FROM</li>
</ol>
</li>
<li>继续向伊甸园存放对象，当伊甸园再次内存空间不足时，再次触发第二次垃圾回收(Minor GC)
<ol>
<li>Minor GC根据可达性分析算法，对伊甸园中和幸存区中对象进行标记</li>
<li>使用复制算法把存活的对象复制到幸存区TO中，同时将这些对象的寿命+1
<ol>
<li>当幸存区对象中的寿命达到了阈值(最大寿命为15)，将其晋升到老年代中</li>
</ol>
</li>
<li>幸存区FROM变为TO，TO变成FROM</li>
<li>Minor GC会引发stop the world(在垃圾回收时，暂停其他的用户线程，等垃圾回收动作结束，其他的用户线程才可以继续进行)</li>
</ol>
</li>
<li>当老年代空间不足，先尝试触发Minor GC，如果之后空间仍不足，触发一次Full GC(Full GC同样会触发stop the world，且时间更长，采用的是标记整理或标记清除算法)
<ol>
<li>当老年代空间足够，新生代空间一定不足的情况下，大对象直接晋升到老年代</li>
</ol>
</li>
<li>如果仍旧分配失败，触发OutOfMemoryError
<ol>
<li>一个线程的OutOfMemoryError不会导致整个进程结束<br>
<a name="Trz34"></a></li>
</ol>
</li>
</ol>
<h2 id="相关vm参数">相关VM参数</h2>
<table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx或-XX:MaxHeapSize=size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn或(-XX:NewSize=size+ -XX:MaxNewSize=size)</td>
</tr>
<tr>
<td>幸存区比例(动态)</td>
<td>-XX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>FullGC前MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody>
</table>
<p><a name="ry4E1"></a></p>
<h2 id="分代垃圾回收详情">分代垃圾回收详情</h2>
<ol>
<li>初始情况</li>
</ol>
<figure data-type="image" tabindex="13"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645672461032-8452a2f1-0f4b-46cb-a573-630ab6c1e7bb-20220312195239790.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>执行后情况</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645672435742-05da2772-9f32-4a00-8d82-004f0e8acf3a-20220312195240083.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645672510315-4c6b0fb4-6052-47fe-a49b-71d608e05b48-20220312195240427.png" alt="image.png" loading="lazy"></p>
<ol start="3">
<li>触发第二次GC</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645673297389-f9f77314-6614-4d08-8d5c-2f6d531f725e-20220312195241234.png" alt="image.png" loading="lazy"><br>
<a name="u03OF"></a></p>
<h1 id="垃圾回收器">垃圾回收器</h1>
<p><a name="ET8h1"></a></p>
<h2 id="串行的垃圾回收器">串行的垃圾回收器</h2>
<ul>
<li>单线程(其他线程都暂停)</li>
<li>堆内存较小时，适合个人电脑</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645685403294-22290a4b-316b-43ef-a214-dd1f1691903e-20220312195241322.png" alt="image.png" loading="lazy"><br />Serial：工作在新生代，采用的是复制算法<br />SerialOld：工作在老年代，采用的是标记整理算法<br>
<a name="r2P99"></a></p>
<h2 id="吞吐量优先的垃圾回收器">吞吐量优先的垃圾回收器</h2>
<ul>
<li>多线程</li>
<li>堆内存较大的场景，需要多核cpu来支持</li>
<li>让单位时间内，stop the world的时间最短，降低垃圾回收时间在工作时间的占比</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645685722473-d75e6551-6e3c-48d6-a754-acd786439173-20220312195241655.png" alt="image.png" loading="lazy"><br />并行的，多个垃圾回收器并行运行，但是垃圾回收期间不允许用户线程继续运行<br />UseParallelGC：作用在新生代，使用复制算法<br />UseParallelOldGC：作用在老年代，使用标记整理算法<br />ParallelGCThreads：控制ParallelGC线程数<br />UseAdaptiveSizePolicy：采用自适应的大小调整策略，调整新生代大小(动态调整伊甸园和幸存区比例，以及晋升阈值)<br />GCTimeRatio ：调整垃圾回收与总时间的占比(1/(1+ratio))(ratio默认为99)垃圾回收时间占总时间的最大比例，一般修改为19<br />MaxGCPauseMillis：默认值为200ms，单次垃圾回收暂停最大时间，与GCTimeRatio成反比需要折中(当堆变大，单词回收时间变长，当堆变小，垃圾回收占比增加，减少吞吐量)</p>
<p><a name="XMz8F"></a></p>
<h2 id="响应时间优先的垃圾回收器">响应时间优先的垃圾回收器</h2>
<ul>
<li>多线程</li>
<li>堆内存较大的场景，需要多核cpu来支持</li>
<li>让单次的stop the world的时间尽可能的短，降低每次垃圾回收所需要的时间</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645756703388-0ef82847-33ee-402b-b29e-d6de5b6ded3c-20220312195242020.png" alt="image.png" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645778356967-b6ffad86-4926-4aff-8312-e8ffb0054ff8-20220312195242421.png" alt="image.png" loading="lazy"><br />使用标记清除算法的垃圾回收器，且为并发的，用户线程与垃圾回收线程并发进行<br />UseConMarkSweepGC：工作在老年代，使用标记清除算法，如果出现并发失败的问题使用SerialOld来进行补救，使用标记整理的方法<br />UseParNewGC：工作在新生代的垃圾回收器：复制算法<br />ParallelGCThreads：并行的垃圾回收线程数<br />ConGCThreads：并发的垃圾回收线程数，一般为ParallelGCThreads的四分之一<br />CMSInitiatingOccupancyFraction：内存占比到多少百分比时来进行垃圾回收<br />CMSScavengeBeforeRemark：在重新标记前对新生代进行一次垃圾回收，减少重新标记时垃圾回收器扫描的数量，减少时间</p>
<ol>
<li>老年代发生了内存不足，线程到达安全点暂停</li>
<li>CMS(ConcMarkSweepGC)进行初始标记，依然需要stop the world</li>
<li>用户线程可以回复运行，垃圾回收线程并发标记</li>
<li>并发标记后，stop the world 重新标记(线程中的资源可能发生改变)</li>
<li>用户线程恢复运行，垃圾回收器进行并发的清理</li>
<li>运行过程中可能产生新的垃圾，成为浮动垃圾，需要在下次垃圾回收时进行回收</li>
<li>需要预留空间保留浮动垃圾来保证用户线程的运行</li>
<li>碎片太多时，无法继续存放对象，进行一次SerialGC<br>
<a name="KF0BV"></a></li>
</ol>
<h2 id="g1garbage-one">G1(garbage one)</h2>
<p><a name="faPGe"></a></p>
<h3 id="定义">定义</h3>
<p>Garbage First<br />JDK9默认，废弃了CMS垃圾回收器<br>
<a name="fB32P"></a></p>
<h3 id="适用场景">适用场景</h3>
<ul>
<li>同时注重吞吐量和低延迟，默认的暂停目标为200ms</li>
<li>超大堆内存，会将堆划分为多个大小相等的Region</li>
<li>整体上是标记+整理算法，两个区域之间是复制算法<br>
<a name="kJcmM"></a></li>
</ul>
<h3 id="相关jvm参数">相关JVM参数</h3>
<p>-XX：+UseG1GC：JDK9以后默认开启，无需显式启用<br />-XX：G1HeapRegionSize=size：设定Region大小<br />-XX：MaxGCPauseMillis=time：设定暂停目标</p>
<p><a name="D2p5U"></a></p>
<h3 id="g1垃圾回收阶段">G1垃圾回收阶段</h3>
<figure data-type="image" tabindex="14"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645758891985-f7372bfc-c0ac-46ea-b3e9-18b333c31042-20220312195242727.png" alt="image.png" loading="lazy"></figure>
<ol>
<li>新生代的垃圾收集</li>
<li>老年代内存超过阈值，在新生代垃圾回收的同时进行并发的标记</li>
<li>混合收集：对新生代和老年代都进行垃圾收集<br>
<a name="GtQOD"></a></li>
</ol>
<h3 id="youngcollection">YoungCollection</h3>
<ul>
<li>会STW</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645759075130-53932929-d02f-4752-aa31-7f6841210f0b-20220312195243029.png" alt="image.png" loading="lazy"><br />每个方格代表一个Region(该Region可以为伊甸园或幸存区或老年代)，空白表示为空闲区域，E代表伊甸园区域，S代表幸存区，O代表老年代<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645759217710-9c726b97-87eb-4040-9189-5f05a88bb190-20220312195243103.png" alt="image.png" loading="lazy"><br />当伊甸园将要被占满触发新生代的垃圾回收(YoungCollection也会STW)，通过复制算法放入幸存区<br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645759347346-c12fbed2-184b-473b-acb7-df48fb78b5fb-20220312195243172.png" alt="image.png" loading="lazy"><br />幸存区的对象较多，或年龄超过阈值，再次触发新生代的垃圾回收，一部分对象进入到老年代，另一部分被垃圾回收或者拷贝到另一个幸存区</p>
<p><a name="NvKHq"></a></p>
<h3 id="youngcollection-concurrentmark">YoungCollection + ConcurrentMark</h3>
<ul>
<li>在YoungGC时会进行GCRoot的初始标记</li>
<li>老年代占用堆空间比例达到阈值时，进行并发标记(不会STW)，比例由<code>-XX:InitiatingHeapOccupancyPersent=percent</code>确定默认为45%</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645759737735-56ebe5da-e2a7-4428-a6b9-aa807c61da04-20220312195243887.png" alt="image.png" loading="lazy"><br>
<a name="wkh3j"></a></p>
<h3 id="mixed-collection">Mixed Collection</h3>
<p>会对E、S、O进行全面的垃圾回收</p>
<ul>
<li>最终标记(Remark)会STW，并发标记中可能漏掉的对象，浮动垃圾</li>
<li>拷贝存活(Evacuation)会STW</li>
<li>新生代：复制算法(黑色箭头)</li>
<li>老年代：复制算法(红色箭头，G1根据最大暂停时间选择性地进行一个垃圾回收，所以不是所有老年代都进行垃圾回收，选择垃圾最多的老年代区域进行垃圾回收)</li>
<li>-XX:MaxGCPauseMillis=ms</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645768341109-c20906fb-1d57-4b54-b551-052363331770-20220312195243963.png" alt="image.png" loading="lazy"><br>
<a name="Jadtx"></a></p>
<h3 id="fullgc">FullGC</h3>
<ul>
<li>SerialGC
<ul>
<li>新生代内存不足发生的垃圾收集 -Minor GC</li>
<li>老年代内存不足发生的垃圾收集 -FullGC</li>
</ul>
</li>
<li>ParallelGC
<ul>
<li>新生代内存不足发生的垃圾收集 -Minor GC</li>
<li>老年代内存不足发生的垃圾收集 -FullGC</li>
</ul>
</li>
<li>CMS
<ul>
<li>新生代内存不足发生的垃圾收集 -Minor GC</li>
<li>老年代内存不足
<ul>
<li>并发收集阶段，不为FullGC</li>
<li>并发失败，退化为串行垃圾收集，FullGC</li>
</ul>
</li>
</ul>
</li>
<li>G1
<ul>
<li>新生代内存不足发生的垃圾收集 -Minor GC</li>
<li>老年代内存不足
<ul>
<li>当老年代内存占比超过阈值时，触发并发标记阶段及混合收集的阶段
<ul>
<li>如果回收速度高于线程垃圾产生速度时，为并发垃圾收集</li>
<li>如果垃圾回收速度低于线程垃圾产生速度，并发收集失败，退化为多线程的垃圾收集-FullGC<br>
<a name="LkYRq"></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="young-collection跨代引用">Young Collection跨代引用</h3>
<ul>
<li>新生代回收的跨代引用(老年代引用新生代)问题</li>
</ul>
<figure data-type="image" tabindex="15"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645769997915-ad60690c-0fbc-4d0c-a9b8-5fac3e907641-20220312195244039.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>把老年代分为再次戏分为card，如果card中的对象引用了新生代中的对象，那么该card被标记为脏card</li>
</ul>
<figure data-type="image" tabindex="16"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645770208668-d8f55fad-847d-4aef-b505-5badfbb92038-20220312195244379.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>新生代中由Remembered Set记录Incoming Reference(记录外部对他的引用)，记录都有哪些脏card</li>
<li>在对新生代标记时，先根据Remembered Set找到对应脏card，再从脏card进行GCRoot</li>
<li>在引用变更时通过post-write barrier + dirty card queue，来标记脏card(异步操作，先将指令放在队列中，之后由一个线程完成脏卡的更新操作)</li>
<li>concurrent refinement threads更新Remembered Set<br>
<a name="UIARk"></a></li>
</ul>
<h3 id="remark重新标记阶段需要对着书重新整理">Remark(重新标记阶段)(需要对着书重新整理)</h3>
<ul>
<li>pre-write barrier + satb_mark_queue</li>
</ul>
<figure data-type="image" tabindex="17"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645770641393-cb09f5c6-852b-4004-ac69-ca1a3dd1f4d3-20220312195244431.png" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>上图表示并发标记阶段时的对象处理状态，<br>
黑色的指标记完成，且有对象引用的。<br>
灰色表示正在标记处理的<br>
白色表示还没有进行标记处理的</p>
</blockquote>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645770970758-e0cbb02c-3920-464d-94c7-3b68bafc079e-20220312195244489.png" alt="image.png" loading="lazy"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645771025992-f5a0b2e2-73a0-4205-bd2d-432523a34291-20220312195244772.png" alt="image.png" loading="lazy"></p>
<ol>
<li>B正在处理中，在处理后变为黑色</li>
</ol>
<figure data-type="image" tabindex="18"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645771070059-f17553a0-9763-45c6-8653-b050f34b00c2-20220312195244810.png" alt="image.png" loading="lazy"></figure>
<ol start="2">
<li>如果A引用了C，但是A已经完成标记，不会再对A进行标记，所以无法对C进行标记</li>
<li>但是C依然是被引用的，所以不能被垃圾回收掉</li>
</ol>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645771297668-1bb2a57b-1a6c-4a81-8407-9e64d6bf37e9-20220312195244845.png" alt="image.png" loading="lazy"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645771355493-66fd4e17-f307-447a-b4b6-2f1b3221f8ac-20220312195244905.png" alt="image.png" loading="lazy"></p>
<ol start="4">
<li>当对象的引用发生改变，触发写屏障代码，将该对象放入到一个队列中，并置为灰色。在进入到重新标记阶段时，对该队列中的对象重新进行一个检查<br>
<a name="I1ekJ"></a></li>
</ol>
<h3 id="jdk8u20字符串去重">JDK8u20字符串去重</h3>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了CPU时间，新生代回收时间略微增加</li>
</ul>
<p>-XX:+UseStringDeduplication</p>
<pre><code class="language-java">String s1 = new String(&quot;hello&quot;);//char[]{'h','e','l','l','o'}
String s2 = new String(&quot;hello&quot;);//char[]{'h','e','l','l','o'}
</code></pre>
<ul>
<li>将所有新分配的字符串放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有字符串重复</li>
<li>如果它们值一样，让它们引用同一个char[]</li>
<li>注意，与String.intern()不一样
<ul>
<li>String.intern()关注的是字符串对象</li>
<li>而字符串去重关注的是char<a href="String%E5%AF%B9%E8%B1%A1%E5%86%85%E7%9A%84char%5B%5D%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E6%94%B9%E5%8F%98%EF%BC%8CString%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E4%B8%8D%E5%8F%98"></a></li>
<li>在JVM内部，使用了不同的字符串表<br>
<a name="fLgOO"></a></li>
</ul>
</li>
</ul>
<h3 id="jdk8u40并发标记类卸载">JDK8u40并发标记类卸载</h3>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类<br />-XX:+ClassUnloadingWithConcurrentMark默认启用<br>
<a name="GTtk1"></a></p>
<h3 id="jdk8u60回收巨型对象">JDK8u60回收巨型对象</h3>
<figure data-type="image" tabindex="19"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645773276792-ac88935c-20ea-45ae-aecd-5b0f787258fd-20220312195245215.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>一个对象大于Region的一半时，称之为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，当巨型对象的incoming为0时，巨型对象可以在新生代垃圾回收时处理掉<br>
<a name="rqruU"></a></li>
</ul>
<h3 id="jdk9并发标记起始时间的调整">JDK9并发标记起始时间的调整</h3>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为FullGC</li>
<li>JDK9之前需要使用<code>-XX:InitiatingHeapOccupancyPercent</code></li>
<li>JDK9可以动态调整
<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的存档空间<br>
<a name="joAjF"></a></li>
</ul>
</li>
</ul>
<h1 id="垃圾回收调优">垃圾回收调优</h1>
<p><a name="HjJ1t"></a></p>
<h2 id="调优的领域">调优的领域</h2>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu占用</li>
<li>io<br>
<a name="cu0gm"></a></li>
</ul>
<h2 id="确定调优目标">确定调优目标</h2>
<ul>
<li>低延迟还是高吞吐量，选择合适的回收站
<ul>
<li>科学计算适合高吞吐量</li>
<li>web项目适合低延迟</li>
</ul>
</li>
<li>选择合适的垃圾回收器
<ul>
<li>低延迟：CMS、G1、ZGC</li>
<li>高吞吐量：ParallelGC</li>
</ul>
</li>
<li>可以通过更换虚拟机来进行调优：例如，Zing虚拟机<br>
<a name="rSxQG"></a></li>
</ul>
<h2 id="最快的gc是不发生gc">最快的GC是不发生GC</h2>
<ul>
<li>查看FullGC前后的内存占用，考虑如下的问题</li>
<li>数据是不是太多
<ul>
<li>resultSet = statement.executeQuery(&quot;select * from 表&quot;)</li>
</ul>
</li>
<li>数据表示是否太臃肿
<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏
<ul>
<li>static Map map 一直向静态map中存放对象</li>
<li>熟练使用软弱引用，使用缓存时，使用第三方的缓存实现<br>
<a name="ww9gt"></a></li>
</ul>
</li>
</ul>
<h2 id="新生代调优">新生代调优</h2>
<p><a name="z5bCA"></a></p>
<h3 id="新生代特点">新生代特点</h3>
<ul>
<li>所有的new操作的内存分配非常廉价
<ul>
<li>TLAB thread-local allocation buffer
<ul>
<li>每个线程都会在伊甸园中被分配一块私有的区域</li>
<li>当线程new一个对象时，如果TLAB有空间，那么优先在TLAB分配内存</li>
<li>减少了线程分配内存时的冲突</li>
</ul>
</li>
</ul>
</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li>MinorGC的时间远远低于FullGC<br>
<a name="kKa7V"></a></li>
</ul>
<h3 id="调优">调优</h3>
<p>-Xmn(设置新生代的初始大小和最大大小)：Oracle建议新生代大小为整个堆大小的25%-50%，刚开始时随着新生代的容量增大，吞吐量逐渐升高，但是到达一定大小后，吞吐量随着新生代容量增大会减少(但是减少的程度较小)(新生代容量太大会导致老年代容量变少，容易触发FullGC，导致垃圾回收消耗时间变长)。建议设置为<code>并发量*(请求响应过程中产生对象)</code><br />幸存区：大小能保留<code>当前活跃对象+需要晋升对象</code> <br />幸存区晋升阈值：晋升阈值配置得当，让长时间存活对象尽快晋升<br />-XX:MaxTenuringThreshold=threshold：调整最大晋升阈值<br />-XX:+PrintTenuringDistribution：显示晋升详细信息<br>
<a name="naN9Q"></a></p>
<h2 id="老年代调优">老年代调优</h2>
<p>以CMS为例</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有FullGC那么已经很好了，否则先尝试调优新生代</li>
<li>观察发生FullGC时老年代内存占用，将老年代内存预设调大1/4-1/3
<ul>
<li>-XX:CMSInitiatingOccupancyFraction=percent超过百分比进行CMS垃圾回收<br>
<a name="i48zJ"></a></li>
</ul>
</li>
</ul>
<h2 id="调优案例">调优案例</h2>
<p><a name="jS1vq"></a></p>
<h3 id="1-fullgc和minorgc频繁且minorgc更频繁">1. FullGC和MinorGC频繁，且MinorGC更频繁</h3>
<p>新生代空间小，且会造成生命周期短的对象进入到老年代从而引发FullGC<br />通过增大新生代空间，同时提高幸存区晋升阈值，让生命周期较短的对象留在新生代中<br>
<a name="BRQdA"></a></p>
<h3 id="2请求高峰期发生fullgc单词暂停时间特别长cms">2.请求高峰期发生FullGC，单词暂停时间特别长(CMS)</h3>
<p>查看GC详情，发现重新标记耗时较多<br />在重新标记前进行一次新生代的垃圾回收<br />-XX:CMSScavengeBeforeRemark<br>
<a name="OQZGJ"></a></p>
<h3 id="3老年代充裕情况下发生fullgcjdk17-cms">3.老年代充裕情况下，发生FullGC(JDK1.7 CMS)</h3>
<p>永久带空间不足</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存结构]]></title>
        <id>https://yeyuan1107.github.io/post/jvm-nei-cun-jie-gou/</id>
        <link href="https://yeyuan1107.github.io/post/jvm-nei-cun-jie-gou/">
        </link>
        <updated>2022-02-18T13:10:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="程序计数器">程序计数器</h1>
<p><a name="BVQjL"></a></p>
<p>程序计数器、虚拟机栈、本地方法栈都是线程私有的堆、方法区都是线程共享的</p>
<h2 id="定义">定义</h2>
<p>Program Counter Register(程序计数器)(寄存器)<br>
<a name="gBUBr"></a></p>
<h2 id="作用">作用</h2>
<figure data-type="image" tabindex="1"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645583767626-1bcd7879-043b-42d8-8558-02c2302e76fd-20220312195126176.png" alt="iShot2022-02-22 11.07.15.png" loading="lazy"></figure>
<ul>
<li>右侧为Java源代码</li>
<li>左侧为二进制字节码，对应每一条jvm指令，<strong>jvm指令需要通过解释器生成机器码，再将机器码交给CPU来执行</strong></li>
<li>程序计数器：记住下一条jvm指令的执行地址，当前指令执行结束后，解释器到程序计数器读取下一条指令的地址，接着进行执行</li>
<li>程序计数器：物理(硬件)上是通过寄存器来实现的<br>
<a name="aG3Ta"></a></li>
</ul>
<h2 id="特点">特点</h2>
<ol>
<li>线程私有的，属于当前线程。如果当前线程时间片耗尽，程序计数器记录当前线程的下一条指令地址，等到当前线程获得CPU时继续进行执行</li>
<li>唯一一个不会存在内存溢出的区<br>
<a name="LX2CM"></a></li>
</ol>
<h1 id="虚拟机栈">虚拟机栈</h1>
<pre><code class="language-java">-Xss指定虚拟机栈大小
</code></pre>
<ul>
<li><strong>虚拟机栈</strong>指的是线程运行需要的内存空间，多个线程就有多个虚拟机栈栈内的元素称之为栈帧。</li>
<li><strong>栈帧</strong>指的是每个方法运行时需要的内存(方法参数，局部变量，返回地址等)当线程<strong>调用一个方法</strong>时，虚拟机栈为该方法分配栈帧空间，并将栈帧压入虚拟机栈中，等方法结束时将该方法对应的栈帧弹出栈<br>
<a name="VAkBD"></a></li>
</ul>
<h2 id="定义-2">定义</h2>
<ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<blockquote>
<p>垃圾回收不涉及栈内存，垃圾回收只涉及堆内存<br />栈内存越大线程数越少，并不是越大越好<br />方法内的局部变量(<strong>不逃离方法的作用范围，逃离作用范围的行为比如作为参数传入或者作为返回值传出</strong>)是线程私有的，就无须考虑线程安全的问题，他是线程安全的。反之，如果为线程共享的，就需要考虑线程安全问题<br />如果局部变量引用了对象，并逃离了方法作用范围，需要考虑线程安全问题。如果为基本数据类型变量，则不需要考虑线程安全问题</p>
</blockquote>
<p><a name="eEKHZ"></a></p>
<h2 id="栈内存溢出stackoverflowerror">栈内存溢出(StackOverflowError)</h2>
<ol>
<li>栈帧过多导致栈内存溢出</li>
<li>栈帧过大导致栈内存溢出<br>
<a name="LODNb"></a></li>
</ol>
<h3 id="线程运行诊断">线程运行诊断</h3>
<p><a name="Hw0CJ"></a></p>
<h4 id="案例一cpu占用过多">案例一：CPU占用过多</h4>
<ul>
<li>用top命令定位哪个进程对cpu的占用过高</li>
<li>ps H -eo pidmtid,%cpu | grep 进程id() 用ps命令进一步定位是哪个线程引起的cpu占用过高</li>
<li>jstack 进程id
<ul>
<li>可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行数<br>
<a name="pmQ8C"></a></li>
</ul>
</li>
</ul>
<h4 id="案例二程序运行很长时间没有结果">案例二：程序运行很长时间没有结果</h4>
<ul>
<li>jstack查看是否存在死锁<br>
<a name="rEdZ1"></a></li>
</ul>
<h1 id="本地方法栈">本地方法栈</h1>
<p>给本地方法的运行(有一些方法无法使用Java实现，使用本地C++代码实现)，提供内存空间<br>
<a name="GaEUb"></a></p>
<h1 id="堆heap">堆(Heap)</h1>
<pre><code class="language-java">-Xmx指定堆空间大小
</code></pre>
<p><a name="AV6XS"></a></p>
<h2 id="定义-3">定义</h2>
<p>通过new关键字创建的对象都会使用堆</p>
<blockquote>
<p>特点<br />他是线程共享的，堆中对象都需要考虑线程安全的问题<br />有垃圾回收机制</p>
</blockquote>
<p><a name="td14f"></a></p>
<h2 id="堆内存溢出outofmemoryerror-oom">堆内存溢出(OutOfMemoryError OOM)</h2>
<p><a name="MH1HW"></a></p>
<h2 id="堆内存诊断">堆内存诊断</h2>
<ol>
<li>jps工具
<ul>
<li>查看当前系统中有哪些java进程</li>
</ul>
</li>
<li>jmap工具
<ul>
<li>查看堆内存占用情况</li>
<li><code>jmap -heap 进程id</code></li>
<li>Eden Space(新生代)：新创建的对象使用的区域</li>
</ul>
</li>
<li>jconsole工具
<ul>
<li>图形界面的，多功能的检测工具，可以连续监测<br>
<a name="F3H9e"></a></li>
</ul>
</li>
</ol>
<h3 id="案例">案例</h3>
<p><a name="nmmT4"></a></p>
<h4 id="垃圾回收后内存占用仍然很高">垃圾回收后，内存占用仍然很高</h4>
<p>jvisualvm -&gt; 堆dump -&gt; 最大的对象<br>
<a name="LyLHY"></a></p>
<h1 id="方法区">方法区</h1>
<pre><code class="language-java">-XX:MaxMetaspaceSize=8m//指定元空间大小
</code></pre>
<p><a name="y7tTp"></a></p>
<h2 id="定义-4">定义</h2>
<ul>
<li>所有线程共享的区域，在方法区中存储了类的结构的有关信息(Field、方法数据、方法及构造器方法的代码、运行时常亮池)</li>
<li>方法区在虚拟机启动时被创建，逻辑上是堆的一个组成部分(不同厂家实现不同)</li>
<li>方法区也会抛出内存溢出错误<br>
<a name="wXjvM"></a></li>
</ul>
<h2 id="组成">组成</h2>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645584184422-6dc5d964-688d-4544-9f7a-cb26ea82942d-20220312195126578.png" alt="iShot2022-02-22 16.00.35.png" loading="lazy"><br />常量池(运行时常量池)：</p>
<ul>
<li>一个类要运行需要先编译成二进制字节码(二进制字节码中包含：类的基本信息，常量池，类的方法定义，包含了虚拟机指令)</li>
<li>javap -v xxx.class 显示反编译后的详细信息 <code>#xx代表从常量池中寻找编号为xx的内容</code></li>
<li><strong>常量池</strong>，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li><strong>运行时常量池</strong>，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号<code>#xx</code>地址变为真实地址<br>
<a name="VRmXm"></a></li>
</ul>
<h2 id="方法区内存溢出outofmemoryerror-oom">方法区内存溢出(OutOfMemoryError OOM)</h2>
<ol>
<li>1.8以前会导致永久代内存溢出
<ul>
<li>OutOfMemoryError:PermGen space</li>
<li>-XX:MaxPermSize=8m</li>
</ul>
</li>
<li>1.8之后会导致元空间内存溢出
<ul>
<li>OutOfMemoryError:Metaspace</li>
<li>-XX:MaxMetaspaceSize=8m</li>
</ul>
</li>
</ol>
<p>常见场景：</p>
<ul>
<li>Spring：cglib动态生成字节码</li>
<li>MyBatis：cglib动态生成字节码</li>
<li>上述两种情况导致方法区类不停加载，从而导致OOM<br>
<a name="uGQxj"></a></li>
</ul>
<h2 id="运行时常量池">运行时常量池</h2>
<ul>
<li><strong>常量池</strong>，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li><strong>运行时常量池</strong>，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号<code>#xx</code>地址变为真实地址<br>
<a name="nH56Q"></a></li>
</ul>
<h2 id="stringtable">StringTable</h2>
<ul>
<li>常量池中的字符串仅是符号，第一次用到时才变为对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是StringBuilder(1.8)</li>
<li>字符串常量凭借的原理是编译期优化</li>
<li>可以使用intern方法，主动将 串池中还没有的字符串对象放入串池
<ul>
<li><strong>1.8</strong>intern()将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，不管有没有，最终都返回串池中的对象。如果成功放入那么当前对象的地址与常量池中的地址变为相同，否则不会发生变化</li>
<li><strong>1.6</strong>intern()将这个字符串对象尝试放入串池，如果有则不会放入，如果没有会把此对象复制一份，然后放入串池，不管有没有，最终都返回串池中的对象。不管成功放入与否那么当前对象的地址与常量池中的地址均不相同</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// 1. 常量池中的信息，都会被加载到运行时常量池中，这时&quot;a&quot;、&quot;b&quot;、&quot;ab&quot;都是常量池中的符号，还没有变为Java字符串对象
// 2. ldc #2 会把 a 符号变为&quot;a&quot;字符串对象，同时准备好一处空间，称为StringTable[ ]\(HashTable结构无法扩容)
// 3. 从StringTable[ ]中寻找 a 对象，如果不存在则放入到StringTable中(用到才会创建并放到StringTable中，用不到就不会创建)
// 4. ldc #3 会把 b 符号变为&quot;b&quot;字符串对象
// 5. 从StringTable[ ]中寻找 b 对象，如果不存在则放入到StringTable中
// 6. ldc #4 会把 ab 符号变为&quot;ab&quot;字符串对象
// 7. 从StringTable[ ]中寻找 ab 对象，如果不存在则放入到StringTable中
String s1 = &quot;a&quot;;
String s2 = &quot;b&quot;;
String s3 = &quot;ab&quot;;
// new StringBuilder().append(s1).append(s2).toString()
// toString()相当于创建了一个新的String变量 new String(&quot;ab&quot;) 并存入到s4中
// s3是StringTable中的一个字符串对象，s4是一个新的字符串对象存放在堆中
String s4 = s1 + s2;
// javac在编译期间的优化，结果已经在编译期间确定为&quot;ab&quot;不可能再变化
String s5 = &quot;a&quot; + &quot;b&quot;;
String s6 = s4.intern();

System.out.println(s3 == s4); //false
System.out.println(s3 == s5); //true
System.out.println(s3 == s6); //true


// 执行完该行代码后StringTable中有&quot;c&quot;和&quot;d&quot;
// new String(&quot;c&quot;) 是new了一个String对象，该对象存放在堆中
// new String(&quot;d&quot;) 是new了一个String对象，该对象存放在堆中
// x2 = new String(&quot;cd&quot;) 放在堆中，并不放在串池中
String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;);
String x1 = &quot;cd&quot;;
// intern()将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，不管有没有，最终都返回串池中的对象
// 如果成功放入那么x2的地址改为常量池中的地址，否则不会发生变化
x2.intern(); 

System.out.println(x1 == x2); //false
// 如果倒数两行代码互换位置 那么为true 。但是如果是Java6及之前依然为false
</code></pre>
<p><a name="czz9Y"></a></p>
<h3 id="stringtable位置">StringTable位置</h3>
<figure data-type="image" tabindex="2"><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645584899069-917db5ed-1144-410a-a0b4-90d13902671c-20220312195126888.png" alt="image.png" loading="lazy"></figure>
<ul>
<li>1.6及之前StringTable在常量池中
<ul>
<li>永久代垃圾回收效率较低</li>
<li>需要使用Full GC才进行永久代的垃圾回收</li>
<li>Full GC只有在老年代空间不足时才会触发</li>
</ul>
</li>
<li>1.7及之后StringTable在堆中
<ul>
<li>堆中垃圾回收效率高</li>
<li>Minor GC进行堆中的垃圾回收</li>
<li>减轻了字符串对方法区的内存占用<br>
<a name="yo9FR"></a></li>
</ul>
</li>
</ul>
<h3 id="stringtable垃圾回收">StringTable垃圾回收</h3>
<pre><code class="language-java">-Xmx1m -XX:+PringStringTableStatistics开启StringTable统计功能 -Xx:+PrintGCDetails -verbose:gc打印垃圾回收的详细信息
</code></pre>
<ul>
<li>StringTable中也存在垃圾回收，并不会一直保存<br>
<a name="g9gOx"></a></li>
</ul>
<h3 id="stringtable性能调优">StringTable性能调优</h3>
<pre><code class="language-java">-Xx:StringTableSize=200000 //底层为HashTable为数组和链表相结合，调整数组(桶)大小
</code></pre>
<ul>
<li>调整-Xx:StringTableSize=桶个数</li>
<li>考虑将字符串对象是否入池，如果有大量字符串重复，可以将重复的字符串入池，节省内存空间<br>
<a name="uSm4E"></a></li>
</ul>
<h1 id="直接内存direct-memory">直接内存(Direct Memory)</h1>
<p><a name="YHLoA"></a></p>
<h2 id="定义-5">定义</h2>
<ul>
<li>常见于NIO操作时，用于数据缓冲区(ByteBuffer)</li>
<li>分配回收成本较高，但是、读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645598236995-08c40bc6-edb7-42f0-b2f3-6d046b625007-20220312195126935.png" alt="image.png" loading="lazy">     <img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645599130121-94f43755-ab9d-45bc-85c3-c0253472f17b-20220312195127322.png" alt="image.png" loading="lazy"></p>
<ul>
<li>不使用直接内存：java无法直接访问系统缓存区，需要先从系统缓存区读入到java缓存区中，再读入到程序中进行使用</li>
<li>使用直接内存：直接划分一块直接内存，该内存既可以操作系统访问，又可以java程序访问，提高文件的读取速度<br>
<a name="leNmD"></a></li>
</ul>
<h2 id="直接内存的释放">直接内存的释放</h2>
<ol>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645601651664-6f7a90db-a776-4825-953b-d16577c6f535-20220312195127410.png" alt="image.png" loading="lazy"></li>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645601706459-6686f2e4-dc19-4957-aebd-a2c45ae191cd-20220312195127436.png" alt="image.png" loading="lazy"></li>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645601844846-ef5e2258-db83-4586-8334-8e530d039397-20220312195127641.png" alt="image.png" loading="lazy"></li>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645601808485-a093dd5f-4d3e-420a-a475-2aaa798531c7-20220312195127901.png" alt="image.png" loading="lazy"></li>
<li><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645601966473-12f1e35d-14b8-4cff-a1f7-eb2de788b46b-20220312195128064.png" alt="image.png" loading="lazy"></li>
<li>Cleaner中的this指ByteBuffer对象，当ByteBuffer对象被垃圾回收掉时，就会触发其中的clean()方法。在ReferenceHandler线程中监测虚引用对象，一旦虚引用对象关联的实际对象(ByteBuffer)被回收，就会执行clean()方法，执行任务对象(Deallocator)<br>
<a name="l2zr3"></a></li>
</ol>
<h2 id="分配和回收">分配和回收</h2>
<ul>
<li>使用了Unsafe对象完成直接内存的分配和回收，并且回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现类内部，使用了Cleaner(虚引用)来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory方法来释放内存</li>
<li><code>-Xx:+DisableExplicitGC</code>禁用代码中显式的垃圾回收
<ul>
<li><code>System.gc()</code>显式的垃圾回收，触发FullGC，同时清理新生代和老年代，耗费时间较长</li>
<li>可能对ByteBuffer有影响，导致直接内存占用较大
<ul>
<li>如需使用<code>-Xx:+DisableExplicitGC</code>，直接内存使用<code>unsafe.freeMemory()</code>管理直接内存</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM引言]]></title>
        <id>https://yeyuan1107.github.io/post/jvm-yin-yan/</id>
        <link href="https://yeyuan1107.github.io/post/jvm-yin-yan/">
        </link>
        <updated>2022-02-15T13:09:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是jvm">什么是JVM</h1>
<p>Java Virtual Machine - Java程序的运行环境(Java二进制字节码的运行环境)<br>
<a name="o4x8y"></a></p>
<h1 id="jvm的好处">JVM的好处</h1>
<ol>
<li>Java程序一次编写，到处运行的基石</li>
<li>自动内存管理，提供了垃圾回收的功能</li>
<li>数组下标越界检查</li>
<li>多态<br>
<a name="dkaO8"></a></li>
</ol>
<h1 id="比较">比较</h1>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645583640772-362689af-35bf-4ccd-a74b-a67477032489-20220312194953326.png" alt="iShot2022-02-22 10.41.00.png" loading="lazy"><br>
<a name="PdQ5k"></a></p>
<h1 id="常见jvm">常见JVM</h1>
<p><strong>本笔记基于HotSpot</strong><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645583661822-54ab67ad-0ecb-47db-a0d3-4e3e14f88bea-20220312194953677.png" alt="iShot2022-02-22 10.58.18.png" loading="lazy"><br>
<a name="giZNB"></a></p>
<h1 id="学习路线">学习路线<img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/1645583698773-0f9a5c55-5b71-442f-a7b8-7b0c9227c4de-20220312194953952.png" alt="iShot2022-02-22 11.01.01.png" loading="lazy"></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java11新特性]]></title>
        <id>https://yeyuan1107.github.io/post/java11-xin-te-xing/</id>
        <link href="https://yeyuan1107.github.io/post/java11-xin-te-xing/">
        </link>
        <updated>2021-12-05T13:21:46.000Z</updated>
        <content type="html"><![CDATA[<p><a name="Uhq1Z"></a></p>
<h1 id="string新增方法">String新增方法</h1>
<ol>
<li>isBlank()：判断字符串是否为空白</li>
<li>strip()：去除首尾空白</li>
<li>stripTrailing()：去除尾部空格</li>
<li>stripLoading()：去除首部空格</li>
<li>repeat(int count)：复制字符串</li>
<li>lines().count()：行数统计<br>
<a name="PDR2I"></a></li>
</ol>
<h1 id="optional加强">Optional加强</h1>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/Optional%E5%A2%9E%E5%BC%BA.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=PZMGY&amp;originHeight=506&amp;originWidth=1407&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br>
<a name="fhRwc"></a></p>
<h1 id="局部变量类型推断的升级">局部变量类型推断的升级</h1>
<p>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样的语法</p>
<pre><code class="language-java">//错误的形式 : 必须要有类型 , 可以加上 var
//Consumer&lt;String&gt; con1 = (@Deprecated t) --&gt;System.out.println(t.toUpperCase());
//正确的形式
//使用 var 的好处是在使用 lambda 表达式时给参数加上注解。
Consumer&lt;String&gt; con2 = ( (@Deprecated var t) --&gt;System. out .println(t.UpperCase());
</code></pre>
<p><a name="wi6wy"></a></p>
<h1 id="全新的http客户端api">全新的HTTP客户端API</h1>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/HttpClient-1-20220312153039410.png" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/HttpClient-2-20220312153039447.png" alt="" loading="lazy"><br>
<a name="RApG4"></a></p>
<h1 id="更简化的编译运行程序">更简化的编译运行程序</h1>
<p>JDK11之前javac xxx.javajava xxx<br />JDK11及之后java xxx.java</p>
<blockquote>
<p><strong>注意：</strong><br>
执行源文件中的第一个类，第一个类必须包含主方法<br />并且不可以使用其他源文件中的自定义类，本文件中的自定义类是可以使用的</p>
</blockquote>
<p><a name="u7ptS"></a></p>
<h1 id="废弃nashorn引擎">废弃Nashorn引擎</h1>
<p>废除Nashorn javascript 引擎 在后续版本准备移除掉，有需要的可以考虑使用 GraalVM。<br>
<a name="wmh0f"></a></p>
<h1 id="zgc">ZGC</h1>
<ul>
<li>GC 是 java 主要优势之一 。 然而当 GC 停顿太长 就会开始影响应用的响应时间 。 消除或者减少 GC 停顿时长 java 将对更广泛的应用场景是一个更有吸引力的平台 。 此外 现代系统中可用内存不断增长用户和程序员希望 JVM 能够以高效的方式充分利用这些内存 并且无需长时间的 GC 暂停时间 。</li>
<li>ZGC A Scalable Low Latency Garbage Collector(Experimental)，这应该是 JDK 11 最为瞩目的特性没有之一。 但是后面带了 Experimental，说明这还不建议用到生产环境。ZGC 是一个并发，基于 region，压缩型的垃圾收集器只有 root 扫描阶段会STW( stop the world )因此 GC 停顿时间不会随着堆的增长和存活对象的增长而变长<br>
<a name="K6VZ1"></a></li>
</ul>
<h2 id="优势">优势：</h2>
<ol>
<li>GC 暂停时间不会超过 10 ms</li>
<li>既能处理几百兆的小堆也能处理几个T的大堆</li>
<li>和G1相比应用吞吐能力不会下降超过15%</li>
<li>为未来的GC功能和利用 colord 指针以及 Load barriers 优化奠定基础</li>
<li>初始只支持 64 位系统</li>
</ol>
<ul>
<li>ZGC 的设计目标是：支持 TB 级内存容量暂停时间低 10 ms 对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆(即热对象置于 DRAM 和冷对象置于 NVMe 闪存或压缩堆)<br>
<a name="jltPJ"></a></li>
</ul>
<h1 id="其他新特性">其他新特性</h1>
<ul>
<li>Unicode 10</li>
<li>Deprecate the Pack200 Tools and API</li>
<li>新的 Epsilon 垃圾收集器</li>
<li>完全支持 Linux 容器(包括 Docker)</li>
<li>支持 G1 上的并行完全垃圾收集</li>
<li>最新的 HTTPS 安全协议 TLS 1.3</li>
<li>Java Flight Recorder</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java10新特性]]></title>
        <id>https://yeyuan1107.github.io/post/java10-xin-te-xing/</id>
        <link href="https://yeyuan1107.github.io/post/java10-xin-te-xing/">
        </link>
        <updated>2021-12-05T13:21:22.000Z</updated>
        <content type="html"><![CDATA[<p><a name="xhmxg"></a></p>
<h1 id="局部变量的类型推断">局部变量的类型推断</h1>
<pre><code class="language-java">//引用型变量也可以
//在处理var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中
var 变量名 = xxx;
</code></pre>
<p>不能用的情况</p>
<ol>
<li>局部变量不赋值</li>
<li>Lambda表达式中左边的函数式接口不能声明为var</li>
<li>方法引用</li>
<li>数组的静态初始化<code>int[] arr = {1, 2, 3, 4, 5}</code></li>
<li>方法的返回值类型</li>
<li>方法中的参数类型、构造器参数类型</li>
<li>属性</li>
<li>catch块</li>
</ol>
<blockquote>
<p>注意<br>
var不是一个关键字，除了不能用它作为类名，其他的都可以<br>
var并不会改变Java时一门静态类型语言的事实</p>
</blockquote>
<p><a name="fL1jZ"></a></p>
<h1 id="集合新增创建不可变集合的方法">集合新增创建不可变集合的方法</h1>
<pre><code class="language-java">//示例 1
var list1 = List.of(&quot; Java&quot;, &quot; Python&quot;, &quot;C&quot;);
var copy1 = List.copyOf(list1);
System.out.println(list1 == copy1); // true
//示例 2
var list2 = new ArrayList&lt;String&gt;();
var copy2 = List.copyOf(list2);
System.out.println(list2 == copy2); // false
//示例 1 和 2 代码基本一致， 为什么一个为 true, 一个为 false?
//如果当前集合已经是只读集合，那么copyOf()返回值为当前集合
//如果不是只读集合copyOf()返回一个新的集合，该集合是只读的
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java9新特性]]></title>
        <id>https://yeyuan1107.github.io/post/java9-xin-te-xing/</id>
        <link href="https://yeyuan1107.github.io/post/java9-xin-te-xing/">
        </link>
        <updated>2021-12-04T13:20:40.000Z</updated>
        <content type="html"><![CDATA[<p><a name="FPuvW"></a></p>
<h1 id="jdk和jre结构的改变">JDK和JRE结构的改变</h1>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/JDK%E5%92%8CJRE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%9A%84%E6%94%B9%E5%8F%98.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=diP8p&amp;originHeight=823&amp;originWidth=1357&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/JDK%E5%92%8CJRE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%9A%84%E6%94%B9%E5%8F%98-1.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=EhREH&amp;originHeight=763&amp;originWidth=1601&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br />模块化系统</p>
<ul>
<li>Jigsaw -&gt; Modularity</li>
<li>随着Java的发展，Java运行环境膨胀和臃肿，每次JVM启动的时候，至少会有30-60MB的内存加载，主要原因是JVM需要加载rt.jar</li>
<li>本质上讲也就是说，用模块来管理各个package，通过声明某个package暴露，模块(module)的概念，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏
<ul>
<li>模块画的主要目的在于减少内存的开销</li>
<li>只须必要模块，而非全部jdk模块，可见话各种类库和大型应用的开发和维护</li>
<li>改进JavaSE平台，使其可以适应不同大小的计算设备</li>
<li>改进其安全性，可维护性，提高性能</li>
</ul>
</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/%E6%A8%A1%E5%9D%97%E5%8C%96.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=HwMJo&amp;originHeight=769&amp;originWidth=1544&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/%E6%A8%A1%E5%9D%97%E5%8C%96-1.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=WzVET&amp;originHeight=679&amp;originWidth=1340&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/%E6%A8%A1%E5%9D%97%E5%8C%96-2.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=pfuhb&amp;originHeight=666&amp;originWidth=1137&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"></p>
<ul>
<li>Java的REPL工具：jShell 命令
<ul>
<li>REPL(read-evaluate-print-loop)，以交互式的方式对语句和表达式进行求职。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈</li>
</ul>
</li>
<li>多版本兼容 jar 包</li>
<li>接口的私有方法
<ul>
<li>JDK8中增加了static方法和默认方法</li>
<li>JDK9接口中的方法可以是private的</li>
</ul>
</li>
<li>钻石操作符的使用升级
<ul>
<li>JDK9中匿名实现类钻石操作符中的类型可以省略<code>Comparator\&lt;Object&gt; com = new Comparator\&lt;&gt;()</code>	，JDK8中会报错</li>
</ul>
</li>
<li>语法改进： try 语句
<ul>
<li>JDK8之前，资源的关闭放在finally中。JDK8中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必须在try子句中初始化(catch后自动关闭括号中创建的资源)，否则编译不通过。JDK9中，用资源语句编写try将更容易，我们可以在try字句中使用已经初始化过的资源，此时的资源是final的</li>
</ul>
</li>
</ul>
<p><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/JDK8-try-20220312152941311.png" alt="" loading="lazy"><br /><img src="http://yuanye1107.oss-cn-shanghai.aliyuncs.com/img/JDK9-try-20220312152941335.png" alt="" loading="lazy"></p>
<ul>
<li>String 存储结构变更
<ul>
<li>String从char[] -&gt; byte[]同时加上编码标记，节约了空间。</li>
<li>StringBuffer和StringBuilder同样更改</li>
</ul>
</li>
<li>快速创建只读集合： of()
<ul>
<li>Java8中：Collections.unmodifiableList(集合名)，Arrays.asList(Object[] objs)</li>
<li>Java9中：
<ul>
<li>static <E> List<E> LIst.of(E e1, E e2, ... , E en)</li>
<li>Set.of()</li>
<li>Map.of()</li>
<li>Map.ofEntries()</li>
</ul>
</li>
</ul>
</li>
<li>增强的 Stream API
<ul>
<li>在 Java 9 中， Stream API 变得更好， Stream 接口中添加了 4 个新的方法takeWhile , dropWhile, ofNullable ，还有个 iterate 方法的新重载方法 ，可以让你提供一个 Predicate ( 判断条件 来指定什么时候结束迭代 。
<ul>
<li>takeWhile(predicate)返回从开头开始的尽量多的元素，从开头到第一个不满足条件的，Predicate为函数式接口</li>
<li>dropWhile(predicate)与takeWhile()相反，返回第一个不满足条件的元素及其之后的元素</li>
<li>ofNullable()形参变量是可以为null值的单个元素</li>
<li>iterate(seed, predicate, UnaryOperator)重载方法，指定什么时候结束迭代</li>
</ul>
</li>
<li>除了对 Stream 本身的扩展， Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个(可能是空的) Stream 对象。</li>
</ul>
</li>
<li>InputStream加强
<ul>
<li>InputStream增加方法transferTo(OutputStream)，直接将输入流的所有数据自动地复制到输出流中</li>
</ul>
</li>
<li>全新 的 HTTP 客户端 API</li>
<li>Deprecated 的相关 API</li>
<li>javadoc 的 HTML 5 支持</li>
<li>Javascript 引擎升级： Nashorn</li>
<li>java 的动态 编译器</li>
</ul>
]]></content>
    </entry>
</feed>
{"posts":[{"title":"常见排序算法（下）","content":"计数排序 准备待排序的数组中最大-max和最小-min的元素，准备一个长度为（max-min+1）辅助计数数组help。 分配:统计原数组中值为arr[i]的元素出现的次数，存入辅助计数数组对应arr[i]-min的索引位置处。 收集: 收集:根据辅助数组的反向从index=0开始填充目标数组。循环判断辅助数组索引为i的元素值help[i]是否&gt;0，如果是，则原数组arr[index++]=i + min class Solution { public int[] sortArray(int[] nums) { // stream 获取最大最小值方法 int max = Arrays.stream(nums).max().getAsInt(); int min = Arrays.stream(nums).min().getAsInt(); int[] support = new int[max - min + 1]; for(int num : nums){ support[num - min]++; } int index = 0; for(int i = 0 ; i &lt; support.length ; i++){ int times = support[i]; while(times-- &gt; 0){ nums[index++] = i + min; } } return nums; } } 桶排序 桶排序（Bucket sort）又被称为箱排序。前面讲的计数排序，最大值和最小值相差多少就准备多少个桶，试想如果最大值和最小值相差过大的话，会造成桶的数量过多，空间复杂度大幅度提升。计数排序不再适用，此时可以采用桶排序。 稳定性：桶排序是否稳定取决于每个桶采用的排序算法，因为桶排序可以做到稳定，所以桶排序是稳定的排序算法。 桶排序详细过程如下： 准备待排序的数组中最大-max和最小-min的元素，准备一个桶容器，每个桶里放的元素用list存储，因为每个桶存放元素的数量是不固定的。桶的数量为k=(max-min)/arr.length+1。 遍历数组 arr，按一定的映射规则（这类似于哈希表）计算每个元素放的桶位置，并将待排序元素划分到不同的桶。 每个桶各自排序，一般采用快速排序。 顺序遍历桶集合，把排序好的元素回写进原数组。 class Solution { public int[] sortArray(int[] nums) { int max = Arrays.stream(nums).max().getAsInt(); int min = Arrays.stream(nums).min().getAsInt(); // 计算桶数组的长度 int bucketNums = (max - min) / nums.length + 1; List&lt;Integer&gt;[] buckets = new List[bucketNums]; // 计算每个桶的装载范围 int bucketRange = (max - min + 1) / bucketNums; for(int i = 0 ; i &lt; buckets.length ; i++){ buckets[i] = new ArrayList&lt;&gt;(); } for(int num : nums){ // 计算当前数值应该放入到哪个桶中 int index = (num - min) / (bucketRange + 1); buckets[index].add(num); } int index = 0; for(List&lt;Integer&gt; list : buckets){ Collections.sort(list); for (Integer integer : list) { nums[index++] = integer; } } return nums; } } 基数排序 有负数不行 将所有待排序非负整数统一为位数相同的整数，位数较少的前面补零。一般用10进制，也可以用16进制甚至2进制，所有的前提是能够找到最大值，得到最长的位数，设k进制下最长为位数为d。实际上相同位数上的值就是要比较的多个键。 对相同的位数上的数值按照大小进行稳定排序（因为稳定排序能够将上一次排序的成果保留下来。例如十位数的排序过程能保留个位数的排序成果，百位数的排序过程能保留十位数的排序成果）。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 MSD：先从高位开始进行排序，在每个关键字上，可采用计数排序。 LSD：先从低位开始进行排序，在每个关键字上，可采用桶排序。 class Solution { int[] digit; public int[] sortArray(int[] nums) { int[] help = new int[10]; int[] temp = new int[nums.length]; int max = Arrays.stream(nums).max().getAsInt(); int len = String.valueOf(max).length(); digit = new int[len]; digit[0] = 1; for(int i = 1 ; i &lt; len ; i++){ digit[i] = digit[i - 1] * 10; } for(int k = 1 ; k &lt;= len ; k++){ Arrays.fill(help, 0); for(int num : nums){ help[getNum(num, k)]++; } // 通过help数组直接找到对应的index for(int i = 1; i &lt; help.length ; i++){ help[i] += help[i - 1]; } // 一定要从后向前遍历，保证相对顺序不变 for(int i = nums.length - 1 ; i &gt;= 0 ; i--){ temp[help[getNum(nums[i], k)] - 1] = nums[i]; help[getNum(nums[i], k)]--; } for(int i = 0 ; i &lt; nums.length ; i++){ nums[i] = temp[i]; } } return nums; } /** * 用于计算num从低到高低k位的数值 * @param num * @param k * @return k位数值 */ public int getNum(int num, int k){ return (num / digit[k - 1]) % 10; } } ","link":"https://yeyuan1107.github.io/post/chang-jian-pai-xu-suan-fa-xia/"},{"title":"常见排序算法（上）","content":" 本文章总结了七种比较排序算法 冒泡排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 O(n2) class Solution { public int[] sortArray(int[] nums) { int len = nums.length; for(int i = 0 ; i &lt; len - 1 ; i++){ boolean flag = true; for(int j = 0 ; j &lt; len - 1 - i ; j++){ if(nums[j] &gt; nums[j + 1]){ swap(nums, j, j+1); flag = false; } } if (flag) break; } return nums; } public void swap(int[] nums, int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 选择排序 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 O(n2) class Solution { public int[] sortArray(int[] nums) { int len = nums.length; for(int i = 0 ; i &lt; len - 1 ; i++){ int index = i; for(int j = i + 1 ; j &lt; len ; j++){ if(nums[j] &lt; nums[index]){ index = j; } } swap(nums, i, index); } return nums; } public void swap(int[] nums, int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 插入排序 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） O(n2) class Solution { public int[] sortArray(int[] nums) { int len = nums.length; for(int i = 0 ; i &lt; len ; i++){ int temp = nums[i]; int j = i - 1; while(j &gt;= 0 &amp;&amp; nums[j] &gt; temp){ nums[j + 1] = nums[j]; j--; } nums[j + 1] = temp; } return nums; } } 希尔排序 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录&quot;基本有序&quot;时，再对全体记录进行依次直接插入排序。 class Solution { public int[] sortArray(int[] nums) { int len = nums.length; int temp; for(int step = len / 2 ; step &gt;= 1 ; step /= 2){ for(int i = step ; i &lt; len ; i++){ temp = nums[i]; int j = i - step; while(j &gt;= 0 &amp;&amp; nums[j] &gt; temp){ nums[j + step] = nums[j]; j -= step; } nums[j + step] = temp; } } return nums; } } 归并排序 class Solution { public int[] sortArray(int[] nums) { return mergeSort(nums, 0, nums.length); } public int[] mergeSort(int[] nums, int begin, int end){ if(begin &gt;= end) return new int[0]; if(begin + 1 == end) return new int[]{nums[begin]}; int mid = (end + begin) &gt;&gt; 1; int[] left = mergeSort(nums, begin, mid); int[] right = mergeSort(nums, mid, end); int[] ans = new int[end - begin]; int index = 0, lPointer = 0, rPointer = 0; while(lPointer &lt; left.length || rPointer &lt; right.length){ if(lPointer &gt;= left.length){ ans[index++] = right[rPointer++]; }else if(rPointer &gt;= right.length){ ans[index++] = left[lPointer++]; }else{ if(left[lPointer] &gt; right[rPointer]){ ans[index++] = right[rPointer++]; }else{ ans[index++] = left[lPointer++]; } } } return ans; } } 快速排序 class Solution { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length); return nums; } public void quickSort(int[] nums, int begin, int end){ if(begin &gt;= end) return; if(begin + 1 == end) return; // 随机选取一个值作为基准值 int index = new Random().nextInt(end - begin) + begin; swap(nums, begin, index); int cur = begin; // 比基准值小的放到数组的左边，大的放到右边 for(int i = begin ; i &lt; end ; i++){ if(nums[i] &lt;= nums[begin]){ swap(nums, cur, i); cur++; } } swap(nums, begin, cur - 1); // 分开排序 quickSort(nums, begin, cur - 1); quickSort(nums, cur, end); } public void swap(int[] nums, int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 堆排序 class Solution { public int[] sortArray(int[] nums) { for(int i = (nums.length - 2) / 2 ; i &gt;= 0 ; i--){ buildBigHeap(nums, i, nums.length); } for(int i = nums.length - 1 ; i &gt;= 0 ; i--){ swap(nums, 0, i); buildBigHeap(nums, 0, i); } return nums; } public void buildBigHeap(int[] nums, int begin, int end){ int childIndex; for(int i = begin ; i * 2 + 1 &lt; end ; i = childIndex){ childIndex = i * 2 + 1; if(childIndex + 1 &lt; end &amp;&amp; nums[childIndex] &lt; nums[childIndex + 1]){ childIndex += 1; } if(nums[childIndex] &gt; nums[i]){ swap(nums, i, childIndex); }else{ break; } } } public void swap(int[] nums, int left, int right){ int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } 堆的下沉和上浮方法，上浮方法用于插入建堆，下沉用于直接建堆 public void sink(int[] nums, int begin, int end){ int childIndex; for(int i = begin ; i * 2 + 1 &lt; end ; i = childIndex){ childIndex = i * 2 + 1; if(childIndex + 1 &lt; end &amp;&amp; nums[childIndex] &lt; nums[childIndex + 1]){ childIndex += 1; } if(nums[childIndex] &gt; nums[i]){ swap(nums, i, childIndex); }else{ break; } } } public void flow(int[] nums, int num, int end){ nums[end] = num; int parentIndex; for(int i = end ; (i - 1) / 2 &gt;= 0 ; i = parentIndex){ parentIndex = (i - 1) / 2; if(nums[parentIndex] &lt; nums[i]) { swap(nums, parentIndex, i); }else{ break; } } } ","link":"https://yeyuan1107.github.io/post/chang-jian-pai-xu-suan-fa-shang/"},{"title":"JMM内存模型","content":" 解决方法 sychronized(同步关键字)语法 synchronized( 对象 ) { 要作为原子操作代码 } 用synchronized解决并发问题 static int i = 0; static Object obj = new Object(); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int j = 0; j &lt; 5000; j++) { synchronized (obj) { i++; } } }); Thread t2 = new Thread(() -&gt; { for (int j = 0; j &lt; 5000; j++) { synchronized (obj) { i--; } } }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); } 如何理解呢:你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。 当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行count++ 代码。 这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才 可以进入 obj 房间，反锁住门，执行它的 count-- 代码。 注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对 象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。 每个类对象都有一个Monitor区，只有在使用synchronized关键字才生效 Owner表示Monitor的所有者，同一时刻只能有一个线程成为Owner 当一个线程t1到达，发现Owner为空的，那么该线程就会成为Owner，并且执行monitorenter会对Monitor进行锁定 当一个线程t2到达，发现Owner不为空，且锁定了Monitor，进入EntryList进行等待(阻塞) 当t1执行完毕，执行monitorexit，通知EntryList中正在等待的线程，可以来争抢成为新的Owner EntryList WaitSet 可见性 退不出的循环 先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止: static boolean run = true; public static void main(String[] args) throws InterruptedException { Thread t = new Thread(()-&gt;{ while(run){ // .... } }); t.start(); Thread.sleep(1000); run = false; // 线程t不会如预想的停下来 } 为什么呢，分析一下可知 初始状态，t线程刚开始从主内存读取了run的值到工作内存，每次循环都需要从主内存中读一次run的值 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值 解决方法 volatile (易变关键字)它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到 主存中获取它的值，线程操作 volatile 变量都是直接操作主存 可见性 前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况: 上例从字节码理解是这样的: getstatic run //线程t获取runtrue getstatic run //线程t获取runtrue getstatic run //线程t获取runtrue getstatic run //线程t获取runtrue putstatic run // 线程 main 修改 run 为 false， 仅此一次 getstatic run // 线程 t 获取 run false 比较一下之前我们将线程安全时举的例子:两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错 // 假设i的初始值为0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized是属于重量级操作，性能相对更低 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了 println中有synchronized关键字，强制当前线程从主存中读取值而不是从告诉缓存中 有序性 诡异的结果 int num = 0; boolean ready = false; // 线程1 执行此方法 public void actor1(I_Result r) { if(ready) { //r1用来保存结果 r.r1 = num + num; } else { r.r1 = 1; } } // 线程2 执行此方法 public void actor2(I_Result r) { num = 2; ready = true; } I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种?有同学这么分析情况1:线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1情况2:线程2 先执行 num = 2，但没来得及执行 ready = true，线程1执行，还是进入 else 分支，结果为1情况3:线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4(因为 num 已经执行过了)但我告诉你，结果还有可能是 0 😁😁😁，信不信吧!这种情况下是:线程2 执行 ready = true，切换到线程1，进入if分支，相加为0，再切回线程2执行num = 2相信很多人已经晕了 😵😵😵 这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现:借助 java 并发压测工具 jcstress https://wiki.openjdk.java.net/display/CodeTools/jcstress mvn archetype:generate -DinteractiveMode=false - DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test- archetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0 创建maven项目，提供如下测试类 @JCStressTest //检查感兴趣的结果 @Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;) @Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;) @State public class ConcurrencyTest { int num = 0; boolean ready = false; @Actor public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } @Actor public void actor2(I_Result r) { num = 2; ready = true; } } 执行 mvn clean install java -jar target/jcstress.jar 会输出我们感兴趣的结果 *** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 2 matching test results. [OK] test.ConcurrencyTest (JVM args: [-XX:-TieredCompilation]) Observed state Occurrences Expectation Interpretation 0 1,729 ACCEPTABLE_INTERESTING !!!! 1 42,617,915 ACCEPTABLE ok 4 5,146,627 ACCEPTABLE ok [OK] test.ConcurrencyTest (JVM args: []) Observed state Occurrences Expectation Interpretation 0 1,652 ACCEPTABLE_INTERESTING !!!! 1 46,460,657 ACCEPTABLE ok 4 4,571,072 ACCEPTABLE ok 可以看到，出现结果为 0 的情况有 1729 次，虽然次数相对很少，但毕竟是出现了。 解决 volatile 修饰的变量，可以禁用指令重排 @JCStressTest @Outcome(id = {&quot;1&quot;, &quot;4&quot;}, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;) @Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;) @State public class ConcurrencyTest { int num = 0; volatile boolean ready = false; @Actor public void actor1(I_Result r) { if(ready) { r.r1 = num + num; } else { r.r1 = 1; } } @Actor public void actor2(I_Result r) { num = 2; ready = true; } } 结果为 *** INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 0 matching test results. 有序性理解 JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码 static int i; static int j; // 在某个线程内执行如下赋值操作 i = ...; // 较为耗时的操作 j = ...; 可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行 时，既可以是 i = ...; // 较为耗时的操作 j = ...; 也可以是 j = ...; i = ...; // 较为耗时的操作 这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性，例如著名的 double-checked locking 模式实现单例 public final class Singleton { private Singleton() { } private static Singleton INSTANCE = null; public static Singleton getInstance() { // 实例没创建，才会进入内部的 synchronized代码块 if (INSTANCE == null) { synchronized (Singleton.class) { // 也许有其它线程已经创建实例，所以再判断一次 if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } } 以上实现的特点是 懒惰实例化 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 但在多线程环境下，上面的代码是有问题的， INSTANCE = new Singleton() 对应的字节码为: 0: new #2 // class cn/itcast/jvm/t4/Singleton 3: dup 4: invokespecial #3 // Method &quot;&lt;init&gt;&quot;:()V 7: putstatic #4 // Field INSTANCE:Lcn/itcast/jvm/t4/Singleton; 其中4 7 两步的顺序不是固定的，也许 jvm 会优化为:先将引用地址赋值给 INSTANCE 变量后，再执行 构造方法，如果两个线程 t1，t2 按如下时间序列执行: 时间1 t1 线程执行到 INSTANCE = new Singleton(); 时间2 t1 线程分配空间，为Singleton对象生成了引用地址(0 处) 时间3 t1 线程将引用地址赋值给 INSTANCE，这时 INSTANCE != null(7 处) 时间4 t2 线程进入getInstance() 方法，发现 INSTANCE != null(synchronized块外)，直接 返回 INSTANCE 时间5 t1 线程执行Singleton的构造方法(4 处) 这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才 会真正有效 happens-before happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结， 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见 static int x; static Object m = new Object(); new Thread(()-&gt;{ synchronized(m) { x = 10; } },&quot;t1&quot;).start(); new Thread(()-&gt;{ synchronized(m) { System.out.println(x); } },&quot;t2&quot;).start(); 线程对volatile变量的写，对接下来其他线程对该变量的读可见 volatile static int x; new Thread(()-&gt;{ x = 10; },&quot;t1&quot;).start(); new Thread(()-&gt;{ System.out.println(x); },&quot;t2&quot;).start(); 线程start前对变量的写，对该线程开始后对该变量的读可见 static int x; x = 10; new Thread(()-&gt;{ System.out.println(x); },&quot;t2&quot;).start(); 线程结束前对变量的写，对其它线程得知它结束后的读可见(比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束) static int x; Thread t1 = new Thread(()-&gt;{ x = 10; },&quot;t1&quot;); t1.start(); t1.join(); System.out.println(x); 线程 t1 打断 t2(interrupt)前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见(通 过t2.interrupted 或 t2.isInterrupted) static int x; public static void main(String[] args) { Thread t2 = new Thread(()-&gt;{ while(true) { if(Thread.currentThread().isInterrupted()) { System.out.println(x); break; } } },&quot;t2&quot;); t2.start(); new Thread(()-&gt;{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } x = 10; t2.interrupt(); },&quot;t1&quot;).start(); while(!t2.isInterrupted()) { Thread.yield(); } System.out.println(x); } 对变量默认值(0，false，null)的写，对其它线程对该变量的读可见 具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z 变量都是指成员变量或静态成员变量 参考: 第17页 CAS与原子类 CAS CAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 +1 操作: // 需要不断尝试 while(true) { int 旧值 = 共享变量 ; // 比如拿到了当前值 0 int 结果 = 旧值 +1;// 在旧值 0 的基础上增加 1 ，正确结果是 1 /* 这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候 compareAndSwap 返回 false，重新尝试，直到: compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰 */ if( compareAndSwap ( 旧值, 结果 )) { // 成功，退出循环 } } 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进 行线程安全保护的一个例子 import sun.misc.Unsafe; import java.lang.reflect.Field; public class TestCAS { public static void main(String[] args) throws InterruptedException { DataContainer dc = new DataContainer(); int count = 5; Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; count; i++) { dc.increase(); } }); t1.start(); t1.join(); System.out.println(dc.getData()); } } class DataContainer { private volatile int data; static final Unsafe unsafe; static final long DATA_OFFSET; static { try { // Unsafe 对象不能直接调用，只能通过反射获得 Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); unsafe = (Unsafe) theUnsafe.get(null); } catch (NoSuchFieldException | IllegalAccessException e) { throw new Error(e); } try { // data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性 DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(&quot;data&quot;)); } catch (NoSuchFieldException e) { throw new Error(e); } } public void increase() { int oldValue; while(true) { // 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解 oldValue = data; // cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue + 1)){ return; } } } public void decrease() { int oldValue; while(true){ oldValue = data; if (unsafe.compareAndSwapInt(this, DATA_OFFSET, oldValue, oldValue - 1)){ return; } } } public int getData() { return data; } } 乐观锁与悲观锁 CAS 是基于乐观锁的思想:最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。 synchronized 是基于悲观锁的思想:最悲观的估计，得防着其它线程来修改共享变量，我上了锁 你们都别想改，我改完了解开锁，你们才有机会。 原子操作类 juc(java.util.concurrent)中提供了原子操作类，可以提供线程安全的操作，例如:AtomicInteger、AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。 可以使用 AtomicInteger 改写之前的例子: // 创建原子整数对象 private static AtomicInteger i = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { for (int j = 0; j &lt; 5000; j++) { i.getAndIncrement(); // 获取并且自增 i++ //i.incrementAndGet(); // 自增并且获取 ++i } }); Thread t2 = new Thread(() -&gt; { for (int j = 0; j &lt; 5000; j++) { i.getAndDecrement(); // 获取并且自减 i-- } }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); } sychronized优化 Java HotSpot虚拟机中，每个对象都有对象头(包括 class 指针和 Mark Word)。Mark Word 平时存储这个对象的哈希码、分代年龄(从幸存区晋升到老年代会用到)，当加锁时，这些信息就根据情况被替换为标记位(锁的类型)、线程锁记录指针、重量级锁指针、线程ID等内容 轻量级锁 如果一个对象虽然有多线程访问，但多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化。这就好比:学生(线程 A)用课本占座，上了半节课，出门了(CPU时间到)，回来一看，发现课本没变，说明没有竞争，继续上他的课。如果这期间有其它学生(线程 B)来了，会告知(线程A)有并发访问，线程 A 随即升级为重量级锁(锁膨胀)， 进入重量级锁的流程。而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来 假设有两个方法同步块，利用同一个对象加锁 static Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } } 每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word 如果加锁MarkWord中的内容需要发生改变，需要把原来的内容保存起来 加锁时将锁记录地址给MarkWord 等解锁后，需要把原来的内容还给MarkWord 锁膨胀 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁(有竞争)，这时需要进行锁膨胀，将轻量级锁变为重量级锁。线程一解锁失败，是为了告诉线程一现在是一个重量级锁，需要按照重量级锁的方式来解锁MarkWord中增加重量级锁，是为了唤醒阻塞中的线程 static Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 } } 重量锁 重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功(即这时候持锁线程已经退出了同步块，释放了锁)，这时当前线程就可以避免阻塞。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能 性会高，就多自旋几次;反之，就少自旋甚至不自旋，总之，比较智能。 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 好比等红灯时汽车是不是熄火，不熄火相当于自旋(等待时间短了划算)，熄火了相当于阻塞(等待时间长了划算) Java 7 之后不能控制是否开启自旋功能 自旋重试成功的情况自旋重试失败的情况 偏向锁 轻量级锁在没有竞争时(就自己这个线程)，每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化:只有第一次使用 CAS 将线程 ID设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS. 变为重量级锁时需要撤销偏向锁，撤销偏向锁需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停(STW) 访问对象的 hashCode 也会撤销偏向锁 当一个对象已经计算过identity hash code(未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值)，它就无法进入偏向锁状态； 当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁； 重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2， 重偏向会重置对象的 Thread ID 撤销偏向和重偏向都是批量进行的，以类为单位 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的 可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁 可以参考这篇论文:https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp- 149958.pdf 假设有两个方法同步块，利用同一个对象加锁 static Object obj = new Object(); public static void method1() { synchronized( obj ) { // 同步块 A method2(); } } public static void method2() { synchronized( obj ) { // 同步块 B } } ![image.png](https://cdn.nlark.com/yuque/0/2022/png/26092193/1646030118607-c926f2b8-b980-4c23-a77f-eec29106c721.png#clientId=ufbb25c08-b6bc-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=249&amp;id=u81a5b064&amp;margin=[object Object]&amp;name=image.png&amp;originHeight=498&amp;originWidth=994&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=82025&amp;status=done&amp;style=none&amp;taskId=u3c8466fd-b12d-42c7-a3c6-0f8793c0408&amp;title=&amp;width=497) 其他优化 1. 减少上锁时间 同步代码块中尽量短(减少线程交错时间，尽量保持为轻量级锁) 2. 减少锁的粒度 将一个锁拆分为多个锁提高并发度，例如: ConcurrentHashMap LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值 LinkedBlockingQueue入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高 3. 锁粗化 多次循环进入同步块不如同步块内多次循环另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次(因为都是对同一个对象加锁， 没必要重入多次) new StringBuffer().append(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;); 4. 锁消除 JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。 5. 读写分离 CopyOnWriteArrayListCopyOnWriteSet 参考 https://wiki.openjdk.java.net/display/HotSpot/Synchronization http://luojinping.com/2015/07/09/java锁优化/https://www.infoq.cn/article/java-se-16-synchronized https://www.jianshu.com/p/9932047a89be https://www.cnblogs.com/sheeva/p/6366782.html https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock ","link":"https://yeyuan1107.github.io/post/jmm-nei-cun-mo-xing/"},{"title":"JVM类加载与字节码技术","content":" 类文件结构 package com.yuanye.jvm public class HelloWorld{ public static void main(String[] args){ System.out.println(&quot;hello world&quot;); } } 执行javac -parameters -d . HelloWorld.java [root@localhost ~]# od -t xC HelloWorld.class 0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14 根据JVM规范，类文件结构如下左侧u4、u2代表字节数字节码详解 魔数(magic) u4，四个字节表示0-3字节，表示它是否是class类型的文件0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 版本 4-7字节，表示类的版本0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 常量池 8-9字节，表示常量池长度，0023(35)表示常量池有#1-#34项，注意#0项不计入，也没有值0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 第#1项0a(根据常量池)表示一个Method信息，0006和0015表示它引用了常量池中#6和#21项，来获取这个方法的所属类和方法名0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 第#2项09表示一个Field信息，0016和0017表示它引用了常量池中#22和#23来获得这个成员变量的所属类和成员变量名0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 090000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#3项 08 表示一个字符串常量名称，0018表示它引用了常量池中 #24 项 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#4项 0a 表示一个 Method 信息，0019和 001a表示它引用了常量池中 #25 和 #26 项来获得这个方法的所属类和方法名0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#5项 07 表示一个 Class 信息，00 1b表示它引用了常量池中 #27 项 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 第#6项 07 表示一个 Class 信息，00 1c表示它引用了常量池中 #28 项0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 】0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 第#10项 01 表示一个 utf8 串，00 0f(15) 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 第#11项 01 表示一个 utf8 串，00 12(18) 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 第#13项 01 表示一个 utf8 串，00 1d(29) 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 第#15项 01 表示一个 utf8 串，00 16(22) 表示长度，是【([Ljava/lang/String;)V】其实就是参数为字符串数组，无返回值0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 第#17项 01 表示一个 utf8 串，00 13(19) 表示长度，是【[Ljava/lang/String;】0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 第#18项 01 表示一个 utf8 串，00 10(16) 表示长度，是【MethodParameters】 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 第#19项 01 表示一个 utf8 串，00 0a(10) 表示长度，是【SourceFile】 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 第#20项 01 表示一个 utf8 串，00 0f(15) 表示长度，是【HelloWorld.java】 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 640000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 第#22项 07 表示一个 Class 信息，00 1d(29) 引用了常量池中 #29 项 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 第#23项 0c 表示一个 【名+类型】，00 1e(30) 00 1f (31)引用了常量池中 #30 #31 两项 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 第#24项 01 表示一个 utf8 串，00 0f(15) 表示长度，是【hello world】 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 第#25项 07 表示一个 Class 信息，00 20(32) 引用了常量池中 #32 项 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 第#26项 0c 表示一个 【名+类型】，00 21(33) 00 22(34)引用了常量池中 #33 #34 两项 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 第#27项 01 表示一个 utf8 串，00 1b(27) 表示长度，是【cn/itcast/jvm/t5/HelloWorld】 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 第#28项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/Object】 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 第#29项 01 表示一个 utf8 串，00 10(16) 表示长度，是【java/lang/System】 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 第#31项 01 表示一个 utf8 串，00 15(21) 表示长度，是【Ljava/io/PrintStream;】0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 第#32项 01 表示一个 utf8 串，00 13(19) 表示长度，是【java/io/PrintStream】 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 第#34项 01 表示一个 utf8 串，00 15(21) 表示长度，是【(Ljava/lang/String;)V】 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 访问标识与继承信息 21 表示该 class 是一个类，公共的 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 05 表示根据常量池中 #5 找到本类全限定名 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 06 表示根据常量池中 #6 找到父类全限定名 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 表示接口的数量，本类为 0 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 FIeld信息 表示成员变量数量，本类为00000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 Method信息 表示方法数量，本类为 2 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 一个方法由 访问修饰符，名称，参数描述，方法属性(代码)数量，方法属性组成 红色代表访问修饰符(本类中是 public) 蓝色代表引用了常量池 #07 项作为方法名称 绿色代表引用了常量池 #08 项作为方法参数描述 黄色代表方法属性数量，本方法是 1 红色代表方法属性 00 09 表示引用了常量池 #09 项，发现是【Code】属性 00 00 00 2f 表示此属性的长度是 47 00 01 表示【操作数栈】最大深度 00 01 表示【局部变量表】最大槽(slot)数 00 00 00 05 表示字节码长度，本例是 5 2a b7 00 01 b1 是字节码指令 00 00 00 02 表示方法细节属性数量，本例是 2 00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性 00 00 00 06 表示此属性的总长度，本例是 6 00 01 表示【LineNumberTable】长度 00 00 表示【字节码】行号 00 04 表示【java 源码】行号 00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性 00 00 00 0c 表示此属性的总长度，本例是 12 00 01 表示【LocalVariableTable】长度 00 00 表示局部变量生命周期开始，相对于字节码的偏移量 00 05 表示局部变量覆盖的范围长度 00 0c 表示局部变量名称，本例引用了常量池 #12 项，是【this】 00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是 【Lcn/itcast/jvm/t5/HelloWorld;】 00 00 表示局部变量占有的槽位(slot)编号，本例是 0 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 红色代表访问修饰符(本类中是 public static) 蓝色代表引用了常量池 #14 项作为方法名称 绿色代表引用了常量池 #15 项作为方法参数描述 黄色代表方法属性数量，本方法是 2 红色代表方法属性(属性1) 00 09 表示引用了常量池 #09 项，发现是【Code】属性 00 00 00 37 表示此属性的长度是 55 00 02 表示【操作数栈】最大深度 00 01 表示【局部变量表】最大槽(slot)数 00 00 00 05 表示字节码长度，本例是 9 b2 00 02 12 03 b6 00 04 b1 是字节码指令 00 00 00 02 表示方法细节属性数量，本例是 2 00 0a 表示引用了常量池 #10 项，发现是【LineNumberTable】属性 00 00 00 0a 表示此属性的总长度，本例是 10 00 02 表示【LineNumberTable】长度 00 00 表示【字节码】行号 00 06 表示【java 源码】行号 00 08 表示【字节码】行号 00 07 表示【java 源码】行号 00 0b 表示引用了常量池 #11 项，发现是【LocalVariableTable】属性 00 00 00 0c 表示此属性的总长度，本例是 12 00 01 表示【LocalVariableTable】长度 00 00 表示局部变量生命周期开始，相对于字节码的偏移量 00 09 表示局部变量覆盖的范围长度 00 10 表示局部变量名称，本例引用了常量池 #16 项，是【args】 00 11 表示局部变量的类型，本例引用了常量池 #17 项，是【[Ljava/lang/String;】 00 00 表示局部变量占有的槽位(slot)编号，本例是 0 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 红色代表方法属性(属性2) 00 12 表示引用了常量池 #18 项，发现是【MethodParameters】属性 00 00 00 05 表示此属性的总长度，本例是 5 01 参数数量 00 10 表示引用了常量池 #16 项，是【args】 00 00 访问修饰符 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14 附加属性 00 01 表示附加属性数量 00 13 表示引用了常量池 #19 项，即【SourceFile】 00 00 00 02 表示此属性的长度 00 14 表示引用了常量池 #20 项，即【HelloWorld.java】 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 0001120 00 00 02 00 14 参考文档 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html 字节码指令 入门 接着上一节，研究一下两组字节码指令，一个是public cn.itcast.jvm.t5.HelloWorld();构造方法的字节码指令 2a b7 00 01 b1 2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数 b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？ 00 01 引用常量池中 #1 项，即【 Method java/lang/Object.&quot;&quot;😦)V 】 b1 表示返回 另一个是public static void main(java.lang.String[]);主方法的字节码指令 b2 00 02 12 03 b6 00 04 b1 b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？ 00 02 引用常量池中 #2 项，即【Field java/lang/System.out:Ljava/io/PrintStream;】 12 =&gt; ldc 加载参数，哪个参数呢？ 03 引用常量池中 #3 项，即 【String hello world】 b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？ 00 04 引用常量池中 #4 项，即【Method java/io/PrintStream.println:(Ljava/lang/String;)V】 b1 表示返回 参考 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5 javap工具 自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件 Classfile /Users/yy/projects/IdeaProjects/Leetcode/out/production/Leetcode/com/yuanye/jvm/HelloWorld.class Last modified 2022年2月25日; size 562 bytes MD5 checksum 68406ec2a8c4f60b7d40f3d3138c8146 Compiled from &quot;HelloWorld.java&quot; public class com.yuanye.jvm.HelloWorld minor version: 0 major version: 55 flags: (0x0021) ACC_PUBLIC, ACC_SUPER this_class: #5 // com/yuanye/jvm/HelloWorld super_class: #6 // java/lang/Object interfaces: 0, fields: 0, methods: 2, attributes: 1 Constant pool: #1 = Methodref #6.#20 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // HelloWorld #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // com/yuanye/jvm/HelloWorld #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/yuanye/jvm/HelloWorld; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 HelloWorld.java #20 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 HelloWorld #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 com/yuanye/jvm/HelloWorld #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V { public com.yuanye.jvm.HelloWorld(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/yuanye/jvm/HelloWorld; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String HelloWorld 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 6: 0 line 7: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; } 图解方法执行流程 原始java代码 package cn.itcast.jvm.t3.bytecode; /** * 演示 字节码指令 和 操作数栈、常量池的关系 */ public class Demo3_1 { public static void main(String[] args) { int a = 10; int b = Short.MAX_VALUE + 1; int c = a + b; System.out.println(c); } } 编译后的字节码文件 [root@localhost ~]# javap -v Demo3_1.class Classfile /root/Demo3_1.class Last modified Jul 7, 2019; size 665 bytes MD5 checksum a2c29a22421e218d4924d31e6990cfc5 Compiled from &quot;Demo3_1.java&quot; public class cn.itcast.jvm.t3.bytecode.Demo3_1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #7.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #27 // java/lang/Short #3 = Integer 32768 #4 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V #6 = Class #32 // cn/itcast/jvm/t3/bytecode/Demo3_1 #7 = Class #33 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 LocalVariableTable #13 = Utf8 this #14 = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1; #15 = Utf8 main #16 = Utf8 ([Ljava/lang/String;)V #17 = Utf8 args #18 = Utf8 [Ljava/lang/String; #19 = Utf8 a #20 = Utf8 I #21 = Utf8 b #22 = Utf8 c #23 = Utf8 MethodParameters #24 = Utf8 SourceFile #25 = Utf8 Demo3_1.java #26 = NameAndType #8:#9 // &quot;&lt;init&gt;&quot;:()V #27 = Utf8 java/lang/Short #28 = Class #34 // java/lang/System #29 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #30 = Class #37 // java/io/PrintStream #31 = NameAndType #38:#39 // println:(I)V #32 = Utf8 cn/itcast/jvm/t3/bytecode/Demo3_1 #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (I)V { public cn.itcast.jvm.t3.bytecode.Demo3_1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 // Method java/lang/Object.&quot; 0: aload_0 1: invokespecial #1 &lt;init&gt;&quot;:()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/itcast/jvm/t3/bytecode/Demo3_1; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: bipush 10 2: istore_1 3: ldc #3 // int 32768 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 8: 0 line 9: 3 line 10: 6 line 11: 10 line 12: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 3 15 1 a I 6 12 2 b I 10 8 3 c I MethodParameters: Name Flags args } 常量池载入运行时常量池 当java代码被执行时，由jvm的类加载器对main()方法所在的类进行类加载(将.class文件的字节数据读取到内存中) 将常量池的数据会放入到运行时常量池中，运行时常量池属于方法区 比较小的数字并不存在常量池中，与方法的字节码存放在一起。一旦数字超过了short类型的最大值，就存放在常量池中 方法字节码载入方法区 main线程开始运行，分配栈帧内存 绿色代表局部变量标，蓝色表示操作数栈 stack表示操作数栈深度，locals表示局部变量表长度 执行引擎开始执行字节码 bipush 10 将一个byte压入操作数栈(其长度会补齐4个字节)，类似的指令还有 sipush将一个short压入操作数栈(其长度会补齐4个字节) ldc将一个int压入操作数栈 ldc2_w将一个long压入操作数栈(分两次压入，因为long是8个字节) 这里小的数字都是和字节码指令存在一起，超过short范围的数字存入了常量池 istore_1 将操作数栈顶数据弹出，存入局部变量表的slot 1 对应java代码中a=10; ldc#3 从常量池加载#3数据到操作数栈 注意 Short.MAX_VALUE是32767，所以32768=Short.MAX_VALUE+1实际是在编译期间计算好的 istore 2 iload 1 iload 2 iadd 运算需要在操作数栈中运行，所以需要加载到栈中 iadd弹出两个结果进行运算，将结果压入到操作数栈中 istore 3 getstatic #41 getstatic到常量池中找到成员变量的引用 成员变量存放在堆中，通过常量池找到堆中的成员变量 然后将成员变量的引用放入到操作数栈中 iload3 invokevirtual #5 找到常量池#5项 定位到方法区java/io/PrintStream.println:(I)V方法 生成新的栈帧(分配locals、stack等) 传递参数，执行新栈帧中的字节码 执行完毕弹出栈帧 清除main操作数栈内容 return 完成main方法调用，弹出main栈帧 程序结束 自增运算图解(a++, ++a) 注意iinc指令是直接在局部变量slot上进行运算 第一个参数是对哪个slot做自增，第二个参数为自增多少 a++和++a的区别是先执行iload还是先执行iinc a++ ++a 条件判断指令 几点说明 byte，short，char都会按int比较，因为操作数栈都是4 goto用来进行跳转到指定行号的字节码 源码 public class Demo3_3 { public static void main(String[] args) { int a = 0; if(a == 0) { a = 10; } else { a = 20; } } } 字节码 iconst_0得到一个0的常量从-1-5之间的数用iconst 0: iconst_0 1: istore_1 2: iload_1 3: ifne 12 6: bipush 10 8: istore_1 9: goto 15 12: bipush 20 14: istore_1 15: return 思考 细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎 么办? 参考 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp 循环控制执行 其实循环控制还是条件判断中的那些指令 While源代码 public class Demo3_4 { public static void main(String[] args) { int a = 0; while (a &lt; 10) { a++; } } } While对应字节码 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 14 8: iinc 1, 1 11: goto 2 14: return Do while源代码 public class Demo3_5 { public static void main(String[] args) { int a = 0; do { a++; } while (a &lt; 10); } } Do while字节码 0: iconst_0 1: istore_1 2: iinc 1, 1 5: iload_1 6: bipush 10 8: if_icmplt 2 11: return For循环源代码 public class Demo3_6 { public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { } } } For循环字节码 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 14 8: iinc 1, 1 11: goto 2 14: return 注意 比较while和for的字节码，你发现他们是一模一样的，殊途同归 练习 public class Demo3_6_1 { public static void main(String[] args) { int i = 0; int x = 0; while (i &lt; 10) { x = x++;//iload_x --&gt; iinc 1,1 --&gt; istore_x(存回去的x=0覆盖了自增后的x=1) i++; } System.out.println(x); // 结果是 0 } } 构造器方法 ()V public class Demo3_8_1 { static int i = 10; static { i = 20; } static { i = 30; } } 编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方 法 &lt;cinit&gt;()V 0: bipush 10 2: putstatic #2 //Field i:I 5: bipush 20 7: putstatic #2 //Field i:I 10: bipush 30 12: putstatic #2 //Field i:I 15: return &lt;cinit&gt;()V 方法会在类加载的初始化阶段被调用 练习 可以调整一下static变量和静态代码块的位置，观察字节码的改动 ()V public class Demo3_8_2 { private String a = &quot;s1&quot;; { b = 20; } private int b = 10; { a = &quot;s2&quot;; } public Demo3_8_2(String a, int b) { this.a = a; this.b = b; } public static void main(String[] args) { Demo3_8_2 d = new Demo3_8_2(&quot;s3&quot;, 30); System.out.println(d.a); System.out.println(d.b); } } 编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构 造方法内的代码总是在最后 aload_0把this加载到栈 方法调用 看一下几种不同的方法调用对应的字节码指令 public class Demo3_9 { public Demo3_9() { } private void test1() { } private final void test2() { } public void test3() { } public static void test4() { } public static void main(String[] args) { Demo3_9 d = new Demo3_9(); d.test1(); d.test2(); } } 0: new #2 //class cn/itcast/jvm/t3/bytecode/Demo3_9 3: dup 4: invokespecial #3 //Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: invokespecial #4 //Method test1:()V 12: aload_1 13: invokespecial #5 //Method test2:()V 16: aload_1 17: invokevirtual #6 //Method test3:()V 20: aload_1 21: pop 22: invokestatic #7 //Method test4:()V 25: invokestatic #7 //Method test4:()V 28: return new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈 dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 &quot;&quot;😦)V (会消耗掉栈顶一个引用)，另一个要配合 astore_1 赋值给局部变量 最终方法(final)，私有方法(private)，构造方法都是由 invokespecial 指令来调用，属于静态绑定 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态 ，具体方法需要在运行时确定 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了，因此调用静态方法时不要使用对象调用，会产生两条无用的字节码指令，直接使用类来调用即可 还有一个执行 invokespecial 的情况是通过 super 调用父类方法 多态的原理 package cn.itcast.jvm.t3.bytecode; import java.io.IOException; /** * 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩 * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers */ public class Demo3_10 { public static void test(Animal animal) { animal.eat(); System.out.println(animal.toString()); } public static void main(String[] args) throws IOException { test(new Cat()); test(new Dog()); System.in.read(); } } abstract class Animal { public abstract void eat(); @Override public String toString() { return &quot;我是&quot; + this.getClass().getSimpleName(); } } class Dog extends Animal { @Override public void eat() { System.out.println(&quot;啃骨头&quot;); } } class Cat extends Animal { @Override public void eat() { System.out.println(&quot;吃鱼&quot;); } } 运行代码 停在 System.in.read() 方法上，这时运行 jps 获取进程 id 运行HSDB工具 进入JDK安装目录，执行java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB 查找某个对象 打开Tools --&gt; Find Object By Query输入select d from cn.itcast.jvm.t3.bytecode.Dog d点击Execute执行d为指定的类型别名 查看对象内存结构 点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的 16 字节，前 8 字节是MarkWord，后 8 字节就是对象的 Class 指针 但目前看不到它的实际地址 查看对象Class的内存地址 通过windows --&gt; console 进入命令行模式，执行mem 0x00000001299b4978 2mem有两个参数，参数1是对象地址，参数2是查看2行(即16字节)结果中第二行 0x000000001b7d4028 即为 Class 的内存地址 查看类的vtable 方法1:Alt+R进入Inspector工具，输入刚才的Class内存地址，看到如下洁面 方法2:或者 Tools -&gt; Class Browser 输入 Dog 查找，可以得到相同的结果 无论通过哪种方法，都可以找到 Dog Class 的 vtable 长度为 6，意思就是 Dog 类有 6 个虚方法(多态相关的，final，static 不会列入)那么这 6 个方法都是谁呢?从 Class 的起始地址开始算，偏移 0x1b8 就是 vtable 的起始地址，进行计算得到: 0x000000001b7d4028 1b8 + --------------------- 0x000000001b7d41e0 通过windows --&gt; console进入命令行模式，执行 mem 0x000000001b7d41e0 6 0x000000001b7d41e0: 0x000000001b3d1b10 0x000000001b7d41e8: 0x000000001b3d15e8 0x000000001b7d41f0: 0x000000001b7d35e8 0x000000001b7d41f8: 0x000000001b3d1540 0x000000001b7d4200: 0x000000001b3d1678 0x000000001b7d4208: 0x000000001b7d3fa8 就得到了6个虚方法的入口 验证方法地址 通过 Tools -&gt; Class Browser 查看每个类的方法定义，比较可知 Dog - public void eat() @0x000000001b7d3fa8 Animal - public java.lang.String toString() @0x000000001b7d35e8; Object - protected void finalize() @0x000000001b3d1b10; Object - public boolean equals(java.lang.Object) @0x000000001b3d15e8; Object - public native int hashCode() @0x000000001b3d1540; Object - protected native java.lang.Object clone() @0x000000001b3d1678; 对号入座，发现 eat() 方法是 Dog 类自己的 toString() 方法是继承 Animal 类的 finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的 小结 当执行 invokevirtual 指令时， 先通过栈帧中的对象引用找到对象 分析对象头，找到对象的实际 Class Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了 查表得到方法的具体地址 执行方法的字节码 异常处理 try-catch public class Demo3_11_1 { public static void main(String[] args) { int i = 0; try { i = 10; } catch (Exception e) { i = 20; } } } 注意 为了抓住重点，下面的字节码省略了不重要的部分 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: goto 12 8: astore_2 9: bipush 20 11: istore_1 12: return Exception table: from to target type 2 5 8 Class java/lang/Exception LineNumberTable: ... LocalVariableTable: Start Length Slot Name Signature 9 3 2 e Ljava/lang/Exception; 0 13 0 args [Ljava/lang/String; 2 11 1 i I StackMapTable: ... MethodParameters: ... } 可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号 8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置 多个single-catch块的情况 public class Demo3_11_2 { public static void main(String[] args) { int i = 0; try { i = 10; } catch (ArithmeticException e) { i = 30; } catch (NullPointerException e) { i = 40; } catch (Exception e) { i = 50; } } } public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: iconst_0 1: istore_1 2: bipush 10 4: istore_1 5: goto 26 8: astore_2 9: bipush 30 11: istore_1 12: goto 26 15: astore_2 16: bipush 40 18: istore_1 19: goto 26 22: astore_2 23: bipush 50 25: istore_1 26: return Exception table: from to target type 258 2 5 15 2 5 22 LineNumberTable: ... LocalVariableTable: Class java/lang/ArithmeticException Class java/lang/NullPointerException Class java/lang/Exception Start Length Slot Name Signature 9 3 2 e Ljava/lang/ArithmeticException; 16 3 2 e Ljava/lang/NullPointerException; 23 3 2 e Ljava/lang/Exception; 0 27 0 args [Ljava/lang/String; 2 25 1 i I StackMapTable: ... MethodParameters: ... 因为异常出现时，只能进入Exception table中一个分支，所以局部变量表slot2位置被共用 multi-catch的情况 public class Demo3_11_3 { public static void main(String[] args) { try { Method test = Demo3_11_3.class.getMethod(&quot;test&quot;); test.invoke(null); } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } } public static void test() { System.out.println(&quot;ok&quot;); } } public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: ldc #2 2: ldc #3 4: iconst_0 5: anewarray #4 8: invokevirtual #5 11: astore_1 12: aload_1 13: aconst_null 14: iconst_0 15: anewarray #6 18: invokevirtual #7 21: pop 22: goto 30 25: astore_1 26: aload_1 27: invokevirtual #11 // e.printStackTrace:()V 30: return Exception table: from to target type 0 22 25 0 22 25 0 22 25 LineNumberTable: ... LocalVariableTable: Class java/lang/NoSuchMethodException Class java/lang/IllegalAccessException Class java/lang/reflect/InvocationTargetException Start Length Slot Name Signature 12 10 1 test Ljava/lang/reflect/Method; 26 4 1 e Ljava/lang/ReflectiveOperationException; 0 31 0 args [Ljava/lang/String; StackMapTable: ... MethodParameters: ... finally public class Demo3_11_4 { public static void main(String[] args) { int i = 0; try { i = 10; } catch (Exception e) { i = 20; } finally { i = 30; } } } 可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程 finally面试题 finally出现了return public class Demo3_12_2 { public static void main(String[] args) { int result = test(); System.out.println(result); } public static int test() { try { return 10; } finally { return 20; } } } public static int test(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=2, args_size=0 0: bipush 10 //&lt;--10放入栈顶 2: istore_0 //10--&gt;slot0(从栈顶移除了) 3: bipush 20 //&lt;--20放入栈顶 5: ireturn //返回栈顶 int(20) 6: astore_1 //catch any --&gt; slot 1 7: bipush 20 //&lt;--20放入栈顶 9: ireturn //返回栈顶 int(20) Exception table from to target type 0 3 6 any LineNumberTable: ... StackMapTable: ... 由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子 跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们:如果在 finally 中出现了 return，会吞掉异常😱😱😱，可以试一下下面的代码 public class Demo3_12_1 { public static void main(String[] args) { int result = test(); System.out.println(result); } public static int test() { try { int i = 1/0; return 10; } finally { return 20; } } } finally对返回值的影响 public class Demo3_12_2 { public static void main(String[] args) { int result = test(); System.out.println(result); } public static int test() { int i = 10; try { return i; } finally { i = 20; } } } public static int test(); descriptor: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=0 0: bipush 10 // &lt;- 10 放入栈顶 2: istore_0 // 10-&gt;i 3: iload_0 // &lt;- i(10) 4: istore_1 // 10 -&gt; slot 1，暂存至 slot 1，目的是为了固定返回值 5: bipush 20 // &lt;- 20 放入栈顶 7: istore_0 // 20-&gt;i 8: iload_1 // &lt;- slot 1(10) 载入 slot 1 暂存的值 9: ireturn // 返回栈顶的 int(10) 10: astore_2 11: bipush 20 13: istore_0 14: aload_2 15: athrow Exception table: from to target type 3 5 10 any LineNumberTable: ... LocalVariableTable: Start Length Slot Name Signature 3 13 0 i I StackMapTable: ... synchronized public class Demo3_13 { public static void main(String[] args) { Object lock = new Object(); synchronized (lock) { System.out.println(&quot;ok&quot;); } } } monitorenter加锁，monitorexit解锁 注意 方法级别的synchronized不会在字节码指令中有所体现 编译期处理 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利(给糖吃嘛)注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并 不是编译器还会转换出中间的 java 源码，切记。 默认构造器 public class Candy1 { } 编译成class后的代码 public class Candy1 { // 这个无参构造是编译器帮助我们加上的 public Candy1() { super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V } } 自动拆装箱 这个特性是JDK 5开始加入的 public class Candy2 { public static void main(String[] args) { Integer x = 1; int y = x; } } 这段代码在JDK 5之前是无法编译通过的，必须改写为: public class Candy2 { public static void main(String[] args) { Integer x = Integer.valueOf(1); int y = x.intValue(); } } 显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换(尤其是集合类中操作的都是 包装类型)，因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 代码片段1 都会在编译阶段被转换为 代码片段2 泛型集合取值 泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理: public class Candy3 { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); // 实际调用的是 List.add(Object e) Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index); } } 所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作 // 需要将 Object 转为 Integer Integer x = (Integer)list.get(0); 如果前面的x变量类型修改为int基本类型那么最终生成的字节码是 // 需要将 Object 转为 Integer, 并执行拆箱操作 int x = ((Integer)list.get(0)).intValue(); 擦除的是字节码上的泛型信息，可以看到 LocalVariableTypeTable 仍然保留了方法参数泛型的信息 LocalVariableTable: Start Length Slot Name Signature 0 32 0 args [Ljava/lang/String; 8 24 1 list Ljava/util/List; LocalVariableTypeTable: Start Length Slot Name Signature 8 24 1 list Ljava/util/List&lt;Ljava/lang/Integer;&gt;; 使用反射，仍然能够获得这些信息 public Set&lt;Integer&gt; test(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map) { } Method test = Candy3.class.getMethod(&quot;test&quot;, List.class, Map.class); Type[] types = test.getGenericParameterTypes(); for (Type type : types) { if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; System.out.println(&quot;原始类型 - &quot; + parameterizedType.getRawType()); Type[] arguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i &lt; arguments.length; i++) { System.out.printf(&quot;泛型参数[%d] - %s\\n&quot;, i, arguments[i]); } } } //输出结果 原始类型 - interface java.util.List 泛型参数[0] - class java.lang.String 原始类型 - interface java.util.Map 泛型参数[0] - class java.lang.Integer 泛型参数[1] - class java.lang.Object 可变参数 可变参数也是JDK 5开始加入的新特性 public class Candy4 { public static void foo(String... args) { String[] array = args; // 直接赋值 System.out.println(array); } public static void main(String[] args) { foo(&quot;hello&quot;, &quot;world&quot;); } } 可变参数 String... args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同样 java 编译器会在编译期间将上述代码变换为: public class Candy4 { public static void foo(String[] args) { String[] array = args; // 直接赋值 System.out.println(array); } public static void main(String[] args) { foo(new String[]{&quot;hello&quot;, &quot;world&quot;}); } } 注意 如果调用了foo()则等价代码为foo(new String[]{})，创建了一个空的数组，而不会传递null进去 foreach循环 仍是JDK5开始引入的语法糖， 数组的循环： public class Candy5_1 { public static void main(String[] args) { int[] array = {1, 2, 3, 4, 5}; // 数组赋初值的简化写法也是语法糖哦 for (int e : array) { System.out.println(e); } } } 会被编译器转换为 public class Candy5_1 { public Candy5_1() { } public static void main(String[] args) { int[] array = new int[]{1, 2, 3, 4, 5}; for(int i = 0; i &lt; array.length; ++i) { int e = array[i]; System.out.println(e); } } } 集合的循环 public class Candy5_2 { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5); for (Integer i : list) { System.out.println(i); } } } 实际被编译器转换为对迭代器的调用 public class Candy5_2 { public Candy5_2() { } public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); Iterator iter = list.iterator(); while(iter.hasNext()) { Integer e = (Integer)iter.next(); System.out.println(e); } } } 注意 foreach循环写法，能够配合数组，以及所有实现了iterable接口的集合类一起食用，其中Iterable用来获取集合的迭代器 switch字符串 从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖 public class Candy6_1 { public static void choose(String str) { switch (str) { case &quot;hello&quot;: { System.out.println(&quot;h&quot;); break; } case &quot;world&quot;: { System.out.println(&quot;w&quot;); break; } } } } 注意 switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清楚 public class Candy6_1 { public Candy6_1() { } public static void choose(String str) { byte x = -1; switch(str.hashCode()) { case 99162322: // hello 的 hashCode if (str.equals(&quot;hello&quot;)) { x = 0; } break; case 113318802: // world 的 hashCode if (str.equals(&quot;world&quot;)) { x = 1; } } switch(x) { case 0: System.out.println(&quot;h&quot;); break; case 1: System.out.println(&quot;w&quot;); } } } 可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢?hashCode 是为了提高效率，减少可 能的比较;而 equals 是为了防止 hashCode 冲突，例如 BM 和 C. 这两个字符串的hashCode值都是2123 ，如果有如下代码: public class Candy6_2 { public static void choose(String str) { switch (str) { case &quot;BM&quot;: { System.out.println(&quot;h&quot;); break; } case &quot;C.&quot;: { System.out.println(&quot;w&quot;); break; } } } } 会被编译器转换为 public class Candy6_2 { public Candy6_2() { } public static void choose(String str) { byte x = -1; switch(str.hashCode()) { case 2123: // hashCode 值可能相同，需要进一步用 equals 比较 if (str.equals(&quot;C.&quot;)){ x = 1; } else if (str.equals(&quot;BM&quot;)) { x = 0; } default: switch(x) { case 0: System.out.println(&quot;h&quot;); break; case 1: System.out.println(&quot;w&quot;); } } } } switch枚举 switch枚举的例子，原始代码： enum Sex { MALE, FEMALE } public class Candy7 { public static void foo(Sex sex) { switch (sex) { case MALE: System.out.println(&quot;男&quot;); break; case FEMALE: System.out.println(&quot;女&quot;); break; } } } 转换后代码 public class Candy7 { /** * 定义一个合成类(仅 jvm 使用，对我们不可见) * 用来映射枚举的 ordinal 与数组元素的关系 * 枚举的 ordinal 表示枚举对象的序号，从 0 开始 * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1 */ static class $MAP { // 数组大小即为枚举元素个数，里面存储case用来对比的数字 static int[] map = new int[2]; static { map[Sex.MALE.ordinal()] = 1; map[Sex.FEMALE.ordinal()] = 2; } } public static void foo(Sex sex) { int x = $MAP.map[sex.ordinal()]; switch (x) { case 1: System.out.println(&quot;男&quot;); break; case 2: System.out.println(&quot;女&quot;); break; } } } 枚举类 JDK 7 新增了枚举类，以前面的性别枚举为例: enum Sex { MALE, FEMALE } 转换后代码 public final class Sex extends Enum&lt;Sex&gt; { public static final Sex MALE; public static final Sex FEMALE; private static final Sex[] $VALUES; static { MALE = new Sex(&quot;MALE&quot;, 0); FEMALE = new Sex(&quot;FEMALE&quot;, 1); $VALUES = new Sex[]{MALE, FEMALE}; } /** * Sole constructor. Programmers cannot invoke this constructor. * It is for use by code emitted by the compiler in response to * enum type declarations. * * @param name - The name of this enum constant, which is the identifier * used to declare it. * @param ordinal - The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned */ private Sex(String name, int ordinal) { super(name, ordinal); } public static Sex[] values() { return $VALUES.clone(); } public static Sex valueOf(String name) { return Enum.valueOf(Sex.class, name); } } try-with-resources JDK 7开始新增了对需要关闭的资源处理的特殊语法try-with-resources: try(资源变量 = 创建资源对象){ } catch( ) { } 其中资源对象需要实现AutoCloseable接口，例如InputStream、OutStream、Connection、Statement、ResultSet等接口都实现了AutoCloseable使用try-with-resources可以不用写finally语法块，编译器会帮助生成关闭资源代码 public class Candy9 { public static void main(String[] args) { try(InputStream is = new FileInputStream(&quot;d:\\\\1.txt&quot;)) { System.out.println(is); } catch (IOException e) { e.printStackTrace(); } } } 会被转换为 public class Candy9 { public Candy9() { } public static void main(String[] args) { try { InputStream is = new FileInputStream(&quot;d:\\\\1.txt&quot;); Throwable t = null; try { System.out.println(is); } catch (Throwable e1) { // t 是我们代码出现的异常 t = e1; throw e1; } finally { // 判断了资源不为空 if (is != null) { // 如果我们代码有异常 if (t != null) { try { is.close(); } catch (Throwable e2) { // 如果 close 出现异常，作为被压制异常添加 t.addSuppressed(e2); } } else { // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e is.close(); } } } } catch (IOException e) { e.printStackTrace(); } } } 为什么要设计一个addSuppressed(Throwable e)(添加被压制异常)的方法： 是为了防止异常信息的丢失(想想 try-with-resources 生成的 fianlly 中如果抛出了异常) public class Test6 { public static void main(String[] args) { try (MyResource resource = new MyResource()) { int i = 1/0; } catch (Exception e) { e.printStackTrace(); } } } class MyResource implements AutoCloseable { public void close() throws Exception { throw new Exception(&quot;close 异常&quot;); } } 输出： java.lang.ArithmeticException: / by zero at test.Test6.main(Test6.java:7) Suppressed: java.lang.Exception: close 异常 at test.MyResource.close(Test6.java:18) at test.Test6.main(Test6.java:6) 如以上代码所示，两个异常信息都不会丢失 方法重写时的桥接方法 我们都知道，方法重写时对返回值分两种情况： 父子类的返回值完全一致 子类返回值可以是夫类返回值的子类 class A { public Number m() { return 1; } } class B extends A { @Override // 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 public Integer m() { return 2; } } 对于子类，java编译器会做如下处理 class B extends A { public Integer m() { return 2; } // 此方法才是真正重写了父类 public Number m() 方法 public synthetic bridge Number m() { // 调用 public Integer m() return m(); } } 其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证 for (Method m : B.class.getDeclaredMethods()) { System.out.println(m); } public java.lang.Integer test.candy.B.m() public java.lang.Number test.candy.B.m() 匿名内部类 public class Candy11 { public static void main(String[] args) { Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;ok&quot;); } }; } } 转换后的代码 // 额外生成的类 final class Candy11$1 implements Runnable { Candy11$1() { } public void run() { System.out.println(&quot;ok&quot;); } } public class Candy11 { public static void main(String[] args) { Runnable runnable = new Candy11$1(); } } 引用局部变量的匿名内部类，源代码： public class Candy11 { public static void test(final int x) { Runnable runnable = new Runnable() { @Override public void run() { System.out.println(&quot;ok:&quot; + x); } }; } } 转换后的代码 // 额外生成的类 final class Candy11$1 implements Runnable { int val$x; Candy11$1(int x) { this.val$x = x; } public void run() { System.out.println(&quot;ok:&quot; + this.val$x); } } public class Candy11 { public static void test(final int x) { Runnable runnable = new Candy11$1(x); } } 注意 这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的:因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy111对象的val1 对象的 val1对象的valx 属性，所以 x 不应该再发生变化了，如果变化，那么 val$x 属性没有机会再跟着一起变化 类加载阶段 加载 将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有: _java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用 _super 即父类 _fields 即成员变量 _methods 即方法 _constants 即常量池 _class_loader 即类加载器 _vtable 虚方法表 _itable 接口方法表 如果这个类还有父类没有加载，先加载父类 加载和链接可能是交替运行的 注意 instanceKlass这样的【元数据】是存储在方法区(1.8后的元空间内)，但_java_mirror是存储在堆中的 可以通过HSDB工具来查看 Person.class有instanceKlass的地址信息，_java_mirror中有Person.class的地址信息 对象实例化后，有一个对象头，其中包含了class地址，如果想获取class信息那就会根据对象头中的class地址来获取person.class再间接到元空间找到instanceKlass，从元空间中找method等信息 链接 验证 验证类是否符合JVM规范，安全性检查用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行 E:\\git\\jvm\\out\\production\\jvm&gt;java cn.itcast.jvm.t5.HelloWorld Error: A JNI error has occurred, please check your installation and try again Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 3405691578 in class file cn/itcast/jvm/t5/HelloWorld at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) at java.net.URLClassLoader.access$100(URLClassLoader.java:73) at java.net.URLClassLoader$1.run(URLClassLoader.java:368) at java.net.URLClassLoader$1.run(URLClassLoader.java:362) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:361) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495) 准备 为 static 变量分配空间，设置默认值 static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成 如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成 解析 将常量池中的符号引用解析为直接引用(直接引用可以知道在内存中的位置) package cn.itcast.jvm.t3.load; /** * 解析的含义 */ public class Load2 { public static void main(String[] args) throws ClassNotFoundException, IOException { ClassLoader classloader = Load2.class.getClassLoader(); // loadClass 方法不会导致类的解析和初始化 Class&lt;?&gt; c = classloader.loadClass(&quot;cn.itcast.jvm.t3.load.C&quot;); //会进行类的解析和初始化 // new C(); System.in.read(); } } class C { D d = new D(); } class D { } 初始化 ()V方法初始化即调用&lt;cinit&gt;()V方法，虚拟机会保证这个类的【构造方法】的线程安全 发生的时机 概括得说，类初始化是【懒惰的】 main 方法所在的类，总会被首先初始化 首次访问这个类的静态变量或静态方法时，会导致这个类的初始化 子类初始化，如果父类还没初始化，会引发父类的初始化 子类访问父类的静态变量，只会触发父类的初始化 Class.forName new 会导致初始化 不会导致类初始化的情况 访问类的 static final 静态常量(基本类型和字符串)不会触发初始化 类对象.class 不会触发初始化 创建该类的数组不会触发初始化 类加载器的 loadClass 方法 Class.forName 的参数 2 为 false 时 实验 class A { static int a = 0; static { System.out.println(&quot;a init&quot;); } } class B extends A { final static double b = 5.0; static boolean c = false; static { System.out.println(&quot;b init&quot;); } } 验证(实验时请先全部注释，每次只执行其中一个) public class Load3 { static { System.out.println(&quot;main init&quot;); } public static void main(String[] args) throws ClassNotFoundException { // 1. 静态常量(基本类型和字符串)不会触发初始化 System.out.println(B.b); // 2. 类对象.class 不会触发初始化 System.out.println(B.class); // 3. 创建该类的数组不会触发初始化 System.out.println(new B[0]); // 4. 不会初始化类 B，但会加载 B、A ClassLoader cl = Thread.currentThread().getContextClassLoader(); cl.loadClass(&quot;cn.itcast.jvm.t3.B&quot;); // 5. 不会初始化类 B，但会加载 B、A ClassLoader c2 = Thread.currentThread().getContextClassLoader(); Class.forName(&quot;cn.itcast.jvm.t3.B&quot;, false, c2); // 1. 首次访问这个类的静态变量或静态方法时 System.out.println(A.a); // 2. 子类初始化，如果父类还没初始化，会引发 System.out.println(B.c); // 3. 子类访问父类静态变量，只触发父类初始化 System.out.println(B.a); // 4. 会初始化类 B，并先初始化类 A Class.forName(&quot;cn.itcast.jvm.t3.B&quot;); } } 练习 从字节码分析，使用a，b，c这三个常量是否会导致E初始化 public class Load4 { public static void main(String[] args) { System.out.println(E.a); System.out.println(E.b); System.out.println(E.c); } } class E { //不会 public static final int a = 10; //不会 public static final String b = &quot;hello&quot;; //会 //Integer.valueOf(20) public static final Integer c = 20; } 典型应用-完成懒惰初始化单例模式 public final class Singleton { private Singleton() { } // 内部类中保存单例 private static class LazyHolder { static final Singleton INSTANCE = new Singleton(); } //如果只调用外部类中的静态方法，会导致外部类的初始化，并不会导致内部类的初始化 // 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 public static Singleton getInstance() { return LazyHolder.INSTANCE; } } 以上的实现特点是： 懒惰实例化 初始化时的线程安全是有保障的 类加载器 以JDK8为例： 类加载器各自加载对应位置的类 有层级关系，低级加载器加载类时会问上级加载器是否加载过该类(例如，Application ClassLoader询问Extension ClassLoader是否加载，然后Extension ClassLoader 询问 Bootstrap ClassLoader) 如果上级均未加载，那么才让低级加载器加载该类 这就是双亲委派模型 启动类加载器(Bootstrap ClassLoader) 用Bootstrap类加载器加载类 package cn.itcast.jvm.t3.load; public class F { static { System.out.println(&quot;bootstrap F init&quot;); } } 执行 package cn.itcast.jvm.t3.load; public class Load5_1 { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.F&quot;); //获取加载该类的类加载器 System.out.println(aClass.getClassLoader()); } } 输出 E:\\git\\jvm\\out\\production\\jvm&gt;java -Xbootclasspath/a:. cn.itcast.jvm.t3.load.Load5 bootstrap F init null -Xbootclasspath表示设置bootclasspath 其中/a:.表示将当前目录追加至bootclasspath之后 可以用这个办法替换核心类 java -Xbootclasspath:&lt;new bootclasspath&gt; java -Xbootclasspath/a:&lt;追加路径&gt; /a为后追加 java -Xbootclasspath/p:&lt;追加路径&gt; /p为前追加，可以用来替换一些核心类 扩展类加载器 package cn.itcast.jvm.t3.load; public class G { static { System.out.println(&quot;classpath G init&quot;); } } 执行 public class Load5_2 { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.G&quot;); System.out.println(aClass.getClassLoader()); } } 输出 classpath G init sun.misc.Launcher$AppClassLoader@18b4aac2 写一个同名的类 package cn.itcast.jvm.t3.load; public class G { static { System.out.println(&quot;ext G init&quot;); } } 打个jar包 E:\\git\\jvm\\out\\production\\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class 已添加清单 正在添加: cn/itcast/jvm/t3/load/G.class(输入 = 481) (输出 = 322)(压缩了 33%) 将jar包拷贝到 JAVA_HOME/jre/lib/ext重新执行Load5_2输出 ext G init sun.misc.Launcher$ExtClassLoader@29453f44 双亲委派模型 所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则 委派上级做类的加载 如果上级没有，那么由本级的类加载器加载 注意 这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系 protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 1. 检查该类是否已经加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { // 2. 有上级的话，委派上级 loadClass c = parent.loadClass(name, false); } else { // 3. 如果没有上级了(ExtClassLoader)，则委派BootstrapClassLoader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { } if (c == null) { long t1 = System.nanoTime(); // 4. 每一层找不到，调用 findClass 方法(每个类加载器自己扩展)来加载 c = findClass(name); // 5. 记录耗时 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 例如 public class Load5_3 { public static void main(String[] args) throws ClassNotFoundException { Class&lt;?&gt; aClass = Load5_3.class.getClassLoader() .loadClass(&quot;cn.itcast.jvm.t3.load.H&quot;); System.out.println(aClass.getClassLoader()); } } 执行流程为 1. sun.misc.Launcher$AppClassLoader //1 处， 开始查看已加载的类，结果没有 2. sun.misc.Launcher$AppClassLoader // 2 处，委派上级 sun.misc.Launcher$ExtClassLoader.loadClass() 3. sun.misc.Launcher$ExtClassLoader // 1 处，查看已加载的类，结果没有 4. sun.misc.Launcher$ExtClassLoader // 3 处，没有上级了，则委派 BootstrapClassLoader查找 5. BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有 6. sun.misc.Launcher$ExtClassLoader // 4 处，调用自己的 findClass 方法，是在 JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader 的 // 2 处 7. 继续执行到 sun.misc.Launcher$AppClassLoader // 4 处，调用它自己的 findClass 方法，在 classpath 下查找，找到了 线程上下文类加载器 我们在使用JDBC时，都需要加载Driver驱动，但是，不写 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 也是可以让com.mysql.jdbc.Driver正确加载的 public class DriverManager { // 注册驱动的集合 private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); // 初始化驱动 static { loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;); } 先不看别的，看看DriverManager的类加载器 System.out.println(DriverManager.class.getClassLoader()); 打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢?继续看loadInitialDrivers()方法 private static void loadInitialDrivers() { String drivers; try { drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;(){ public String run() { return System.getProperty(&quot;jdbc.drivers&quot;); } }); } catch (Exception ex) { drivers = null; } // 1)使用 ServiceLoader 机制加载驱动，即 SPI AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() { public Void run() { ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try{ while(driversIterator.hasNext()) { //也破坏了双亲委派模型 driversIterator.next(); } } catch(Throwable t) { // Do nothing } return null; } }); println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers); // 2)使用 jdbc.drivers 定义的驱动名加载驱动 if (drivers == null || drivers.equals(&quot;&quot;)) { return; } String[] driversList = drivers.split(&quot;:&quot;); println(&quot;number of Drivers:&quot; + driversList.length); for (String aDriver : driversList) { try { println(&quot;DriverManager.Initialize: loading &quot; + aDriver); // 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器 Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); } catch (Exception ex) { println(&quot;DriverManager.Initialize: load failed: &quot; + ex); } } } 先看 2)发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载，打破了双亲委派模型 再看 1)它就是大名鼎鼎的 Service Provider Interface (SPI) 约定如下，在 jar 包的 META-INF/services 包下，以接口全限定名为文件名，文件内容是实现类名称 这样就可以使用 //找到接口的所有实现类 ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class); Iterator&lt;接口类型&gt; iter = allImpls.iterator(); while(iter.hasNext()) { //每次调用了迭代器，就可以返回实现类的实例 iter.next(); } 来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想: JDBC Servlet 初始化器 Spring 容器 Dubbo(对 SPI 进行了扩展) 接着看 ServiceLoader.load 方法: public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { // 获取线程上下文类加载器(默认就是应用程序类加载器) // 在线程启动时，jvm会把应用程序类加载器复制给当前线程 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } 线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由 Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类 LazyIterator 中: private S nextService() { if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try { c = Class.forName(cn, false, loader); } catch (ClassNotFoundException x) {&quot;Provider &quot; + cn + &quot; not found&quot;); } if (!service.isAssignableFrom(c)) { fail(service, &quot;Provider &quot; + cn + &quot; not a subtype&quot;); } try { S p = service.cast(c.newInstance()); providers.put(cn, p); return p; } catch (Throwable x) { fail(service, &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;, x); } throw new Error(); // This cannot happen } 自定义类加载器 什么时候需要自定义类加载器 想加载非classpath随意路径中的类文件 都是通过接口来使用实现，希望解耦时，常用在框架设计 这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于tomcat容器 步骤： 继承 ClassLoader 父类 要遵从双亲委派机制，重写 findClass 方法 注意不是重写 loadClass 方法，否则不会走双亲委派机制 读取类文件的字节码 调用父类的 defineClass 方法来加载类 使用者调用该类加载器的 loadClass 方法 示例: 准备好两个类文件放入 E:\\myclasspath，它实现了 java.util.Map 接口，可以先反编译看一下: package cn.itcast.jvm.t3.load; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; public class Load7 { public static void main(String[] args) throws Exception { MyClassLoader classLoader = new MyClassLoader(); Class&lt;?&gt; c1 = classLoader.loadClass(&quot;MapImpl1&quot;); Class&lt;?&gt; c2 = classLoader.loadClass(&quot;MapImpl1&quot;); //true System.out.println(c1 == c2); MyClassLoader classLoader2 = new MyClassLoader(); Class&lt;?&gt; c3 = classLoader2.loadClass(&quot;MapImpl1&quot;); //false，包名类名相同，且类加载器对象相同，才认为这是同一个类，不然认为是相互隔离的 System.out.println(c1 == c3); c1.newInstance(); } } //继承ClassLoader并重写findClass方法 class MyClassLoader extends ClassLoader { @Override // name 就是类名称 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { String path = &quot;e:\\\\myclasspath\\\\&quot; + name + &quot;.class&quot;; try { ByteArrayOutputStream os = new ByteArrayOutputStream(); Files.copy(Paths.get(path), os); // 得到字节数组 byte[] bytes = os.toByteArray(); // byte[] -&gt; *.class return defineClass(name, bytes, 0, bytes.length); } catch (IOException e) { e.printStackTrace(); throw new ClassNotFoundException(&quot;类文件未找到&quot;, e); } } } 运行期优化 即时编译 分层编译(TieredCompilation) public class JIT1 { public static void main(String[] args) { for (int i = 0; i &lt; 200; i++) { long start = System.nanoTime(); for (int j = 0; j &lt; 1000; j++) { new Object(); } long end = System.nanoTime(); System.out.printf(&quot;%d\\t%d\\n&quot;,i,(end - start)); } } } 0 96426 1 52907 2 44800 3 119040 4 65280 5 47360 6 45226 7 47786 8 48640 9 60586 10 42667 11 48640 12 70400 13 49920 14 49493 15 45227 16 45653 17 60160 18 58880 19 46080 20 47787 21 49920 22 54187 23 57173 24 50346 25 52906 26 50346 27 47786 28 49920 29 64000 30 49067 31 63574 32 63147 33 56746 34 49494 35 64853 36 107520 37 46933 38 51627 39 45653 40 103680 41 51626 42 60160 43 49067 44 45653 45 49493 46 51626 47 49066 48 47360 49 50774 50 70827 51 64000 52 72107 53 49066 54 46080 55 44800 56 46507 57 73813 58 61013 59 57600 60 83200 61 7024204 62 49493 63 20907 64 20907 65 20053 66 20906 67 20907 68 21333 69 22187 70 20480 71 21760 72 19200 73 15360 74 18347 75 19627 76 17067 77 34134 78 19200 79 18347 80 17493 81 15360 82 18774 83 17067 84 21760 85 23467 86 17920 87 17920 88 18774 89 18773 90 19200 91 20053 92 18347 93 22187 94 17920 95 18774 96 19626 97 33280 98 20480 99 20480 100 18773 101 47786 102 17493 103 22614 104 64427 105 18347 106 19200 107 26027 108 21333 109 20480 110 24747 111 32426 112 21333 113 17920 114 17920 115 19200 116 18346 117 15360 118 24320 119 19200 120 20053 121 17920 122 18773 123 20053 124 18347 125 18347 126 22613 127 18773 128 19627 129 20053 130 20480 131 19627 132 20053 133 15360 134 136533 135 43093 136 853 137 853 138 853 139 853 140 854 141 853 142 853 143 853 144 853 145 853 146 853 147 854 148 853 149 853 150 854 151 853 152 853 153 853 154 1280 155 853 156 853 157 854 158 853 159 853 160 854 161 854 162 853 163 854 164 854 165 854 166 854 167 853 168 853 169 854 170 853 171 853 172 853 173 1280 174 853 175 1280 176 853 177 854 178 854 179 427 180 853 181 854 182 854 183 854 184 853 185 853 186 854 187 853 188 853 189 854 190 1280 191 853 192 853 193 853 194 853 195 854 196 853 197 853 198 853 199 854 原因是什么呢?JVM 将执行状态分成了 5 个层次: 0 层，解释执行(Interpreter) 字节码加载到虚拟机，解释器将字节码解释为机器码 字节码被反复调用，到达一定阈值，就会启用编译器进行编译执行 1 层，使用 C1 即时编译器编译执行(不带 profiling) 2 层，使用 C1 即时编译器编译执行(带基本的 profiling) 3 层，使用 C1 即时编译器编译执行(带完全的 profiling) 4 层，使用 C2 即时编译器编译执行 比C1优化程度更高 profiling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等 即时编译器(JIT)与解释器的区别 解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 JIT 是将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译 解释器是将字节码解释为针对所有平台都通用的机器码 JIT 会根据平台类型，生成平台特定的机器码 对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运 行;另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1(提升5倍左右高) &lt; C2(提升10-100倍)，总的目标是发现热点代码(hotspot名称的由来)，并优化之 刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸(外层是否会用到该对象)。可以使用 -XX:- DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果 参考资料：https://docs.oracle.com/en/java/javase/12/vm/java-hotspot-virtual-machine-performance-enhancements.html#GUID-D2E3DC58-D18B-4A6C-8167-4A1DFB4888E4 方法内联(Inlining) private static int square(final int i) { return i * i; } System.out.println(square(9)); 如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、 粘贴到调用者的位置: //System.out.println(square(9))进行方法内联后 //变为 System.out.println(9 * 9); 还能够进行常量折叠(constant folding)的优化 //9固定不变，可以进行常量折叠的优化 System.out.println(81); 实验： public class JIT2 { // -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining (解锁隐藏参数)打印inlining 信息 // -XX:CompileCommand=dontinline,*JIT2.square 禁止某个方法 inlining *表示报名，JIT2为类名然后为方法名 // -XX:+PrintCompilation 打印编译信息 public static void main(String[] args) { int x = 0; for (int i = 0; i &lt; 500; i++) { long start = System.nanoTime(); for (int j = 0; j &lt; 1000; j++) { x = square(9); } long end = System.nanoTime(); System.out.printf(&quot;%d\\t%d\\t%d\\n&quot;,i,x,(end - start)); } } private static int square(final int i) { return i * i; } } 字段优化 字段优化为对成员变量和静态成员变量进行优化JMH基准测试请参考http://openjdk.java.net/projects/code-tools/jmh/创建maven工程，添加依赖如下 &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;${jmh.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;${jmh.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 编写基准测试代码 package test; import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.RunnerException; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.Random; import java.util.concurrent.ThreadLocalRandom; // 热身，让程序预热一段时间，让JIT对其进行充分的优化 @Warmup(iterations = 2, time = 1) // 进行几轮测试 @Measurement(iterations = 5, time = 1) @State(Scope.Benchmark) public class Benchmark1 { int[] elements = randomInts(1_000); private static int[] randomInts(int size) { Random random = ThreadLocalRandom.current(); int[] values = new int[size]; for (int i = 0; i &lt; size; i++) { values[i] = random.nextInt(); } return values; } @Benchmark public void test1() { for (int i = 0; i &lt; elements.length; i++) { doSum(elements[i]); } } @Benchmark public void test2() { int[] local = this.elements; for (int i = 0; i &lt; local.length; i++) { doSum(local[i]); } } @Benchmark public void test3() { for (int element : elements) { doSum(element); } } static int sum = 0; // 控制是否进行内联 @CompilerControl(CompilerControl.Mode.INLINE) static void doSum(int x) { sum += x; } public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder() .include(Benchmark1.class.getSimpleName()) .forks(1) .build(); new Runner(opt).run(); } } 首先启用doSum的方法内联，测试结果如下(每秒吞吐量，分数越高越好) Benchmark Mode Samples Score Score error Units t.Benchmark1.test1 thrpt 5 2420286.539 390747.467 ops/s t.Benchmark1.test2 thrpt 5 2544313.594 91304.136 ops/s t.Benchmark1.test3 thrpt 5 2469176.697 450570.647 ops/s 接下来禁用doSum方法内联 //禁用内联 @CompilerControl(CompilerControl.Mode.DONT_INLINE) static void doSum(int x) { sum += x; } 测试结果如下 Benchmark Mode Samples Score Score error Units t.Benchmark1.test1 thrpt 5 296141.478 63649.220 ops/s t.Benchmark1.test2 thrpt 5 371262.351 83890.984 ops/s t.Benchmark1.test3 thrpt 5 368960.847 60163.391 ops/s 分析：在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化: 如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子(伪代码): @Benchmark public void test1() { // elements.length 首次读取会缓存起来 -&gt; int[] local for (int i = 0; i &lt; elements.length; i++) { // 后续 999 次 求长度 &lt;- local sum += elements[i]; // 1000 次取下标 i 的元素 &lt;- local } } 可以节省1999次Field读取操作但如果doSum方法没有内联，则不会进行上面的优化 练习:在内联情况下将 elements 添加 volatile 修饰符，观察测试结果 反射优化 package cn.itcast.jvm.t3.reflect; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect1 { public static void foo() { System.out.println(&quot;foo...&quot;); } public static void main(String[] args) throws Exception { Method foo = Reflect1.class.getMethod(&quot;foo&quot;); for (int i = 0; i &lt;= 16; i++) { System.out.printf(&quot;%d\\t&quot;, i); foo.invoke(null); } System.in.read(); } } foo.invoke前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现 package sun.reflect; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import sun.reflect.misc.ReflectUtil; class NativeMethodAccessorImpl extends MethodAccessorImpl { private final Method method; private DelegatingMethodAccessorImpl parent; private int numInvocations; NativeMethodAccessorImpl(Method method) { this.method = method; } public Object invoke(Object target, Object[] args) throws IllegalArgumentException, InvocationTargetException { // inflationThreshold 膨胀阈值，默认 15 if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())){ // 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右 MethodAccessorImpl generatedMethodAccessor = (MethodAccessorImpl) (new MethodAccessorGenerator()) .generateMethod( this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers() ); this.parent.setDelegate(generatedMethodAccessor); } // 调用本地实现 return invoke0(this.method, target, args); } void setParent(DelegatingMethodAccessorImpl parent) { this.parent = parent; } private static nat ive Object invoke0(Method method, Object target, Object[] args); } 当调用到第 16 次(从0开始算)时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到 类名为 sun.reflect.GeneratedMethodAccessor1可以使用阿里的 arthas 工具: java -jar arthas-boot.jar [INFO] arthas-boot version: 3.1.1 [INFO] Found existing java process, please choose one and hit RETURN. * [1]: 13065 cn.itcast.jvm.t3.reflect.Reflect1 选择1回车表示分析该进程 1 [INFO] arthas home: /root/.arthas/lib/3.1.1/arthas [INFO] Try to attach process 13065 [INFO] Attach process 13065 success. [INFO] arthas-client connect 127.0.0.1 3658 wiki https://alibaba.github.io/arthas tutorials https://alibaba.github.io/arthas/arthas-tutorials version 3.1.1 pid 13065 time 2019-06-10 12:23:54 在输入【jad+类名】来进行反编译 $ jad sun.reflect.GeneratedMethodAccessor1 ClassLoader: +-sun.reflect.DelegatingClassLoader@15db9742 +-sun.misc.Launcher$AppClassLoader@4e0e2f2a +-sun.misc.Launcher$ExtClassLoader@2fdb006e Location: /* * Decompiled with CFR 0_132. * * Could not load the following classes: * cn.itcast.jvm.t3.reflect.Reflect1 */ package sun.reflect; import cn.itcast.jvm.t3.reflect.Reflect1; import java.lang.reflect.InvocationTargetException; import sun.reflect.MethodAccessorImpl; public class GeneratedMethodAccessor1 extends MethodAccessorImpl { /* * Loose catch block * Enabled aggressive block sorting * Enabled unnecessary exception pruning * Enabled aggressive exception aggregation * Lifted jumps to return sites */ public Object invoke(Object object, Object[] arrobject) throws InvocationTargetException { // 比较奇葩的做法，如果有参数，那么抛非法参数异常 block4 : { if (arrobject == null || arrobject.length == 0) break block4; throw new IllegalArgumentException(); } try { // 可以看到，已经是直接调用了😱😱😱 Reflect1.foo(); // 因为没有返回值 return null; } catch (Throwable throwable) { throw new InvocationTargetException(throwable); } catch (ClassCastException | NullPointerException runtimeException) { throw new IllegalArgumentException(Object.super.toString()); } } } Affect(row-cnt:1) cost in 1540 ms. 注意 通过查看 ReflectionFactory 源码可知 sun.reflect.noInflation 可以用来禁用膨胀(直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算) sun.reflect.inflationThreshold 可以修改膨胀阈值 ","link":"https://yeyuan1107.github.io/post/jvm-lei-jia-zai-yu-zi-jie-ma-ji-zhu/"},{"title":"JVM垃圾回收","content":" 如何判断对象可以回收 引用计数法 只要一个对象被其他变量所引用，那么该对象的计数加一，否则减一。当该对象引用计数变为0，那么就说明没有变量引用，可以当作垃圾回收 存在问题 循环引用造成内存泄漏 当没有变量引用A对象，也没有变量引用B对象，但是A和B相互引用，引用计数器为1，无法对其进行垃圾回收，导致内存泄漏 可达性分析算法 Java所使用的方法 确定一系列根对象(肯定不能当作垃圾回收的对象)，垃圾回收前首先对堆中所有对象进行扫描，看看每一个对象是否被根对象直接或者间接的引用。如果没有被根对象直接或间接的引用，那么就可以当作垃圾回收 扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收 可以被作为GC Root的对象(工具Memory Analyzer 可视化Java堆分析工具) System Class：系统类、核心类 Native Stack：本地方法引用的一些对象 Busy Monitor：加锁的对象 Thread：活动线程中的对象 四种引用 强引用 只有所有GC Roots 对象都不通过【强号1用1引1用该对象，该对象才能被垃圾回收 软引用 (SoftReference) 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象 可以配合引用队列来释放软引用自身 弱引用 (WeakReference) 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 可以配合引用队列来释放弱引1用自身 虛引用 (PhantomReference) 必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由Reference Handler 线程调用虚引用相关方法释放直接内存 终结器引用 (FinalReference) 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引1用入队（被引1用对象暂时没有被回收），再由 Finalizer 线程通过终结器引1用找到被引1用对象并调用它的finalize 方法，第二次GC 时才能回收被引用对象 实线表示强引用 强引用 日常引用基本都为强引用，比如：new一个对象，对象通过赋值给一个变量，那么该变量强引用这个对象 只要沿着GC Root的引用链可以找到该对象，那么该对象就不会被回收 GC Root对他的引用都断开时，当垃圾回收发生时，该对象被回收 软、弱引用 只要对象没有没有被直接的强引用所引用，当垃圾回收发生时，都有可能被回收 软引用：没有强引用引用他，发生垃圾回收且垃圾回收后内存不足，就会回收软引用引用的对象 弱引用：没有强引用引用他，发生垃圾回收，不管内存是否充足，都会回收弱引用引用的对象 软、弱引用的对象被回收后，软、弱引用就会被放入引用队列，如果想要释放软、弱引用，需要使用引用队列进行释放 可以配合引用队列使用，也可以不配合引用队列使用 软引用的应用 //byte[]使用强引用，可能造成OutOfMemoryError //list 强引用--&gt; byte[] List&lt;byte[]&gt; list; //list 强引用--&gt; SoftReference 软引用--&gt; byte[] //不会造成OutOfMemoryError，当内存不足时byte[]会被垃圾回收 List&lt;SoftReference&lt;byte[]&gt;&gt; list 软引用引用队列 ReferenceQueue&lt;byte[]&gt; queue //希望在byte[]被清理时，对应的SoftReference&lt;byte[]&gt;也被清理 List&lt;SoftReference&lt;byte[]&gt;&gt; list //软引用对象关联了软引用队列，当软引用所关联的byte[]被回收时，软引用会加入到queue中去 SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[], queue); //从队列中获取无用的软引用对象，并移除 Referecne&lt;? extends byte[]&gt; poll = queue.poll(); while(poll != null){ //移除列表中的软引用对象 list.remove(poll); poll = queue.poll(); } 弱引用的应用 //byte[]使用强引用，可能造成OutOfMemoryError //list 强引用--&gt; byte[] List&lt;byte[]&gt; list; //list 强引用--&gt; WeakReference 弱引用--&gt; byte[] //不会造成OutOfMemoryError，byte[]没有被强引用时，会被垃圾回收 //在垃圾回收时会进行垃圾回收 //弱引用的引用队列与软引用类似 List&lt;WeakReference&lt;byte[]&gt;&gt; list 虚引用 当ByteBuffer对象创建，会产生一个Cleaner的虚引用对象，ByteBuffer会产生一块直接内存，并把直接内存地址传递给虚引用对象 当ByteBuffer没有被强引用，ByteBuffer可以被垃圾回收掉 ByteBuffer被垃圾回收后，虚引用对象Cleaner进入到引用队列。 ReferenceHandler会定时查看引用队列是否有虚引用对象Cleaner，如果有就调用其中的clean方法，从而释放直接内存 与软、弱引用不同，虚引用必须配合引用队列使用 终结器引用 当一个对象没有被强引用，且重写了finalize()方法，JVM会创建终结器引用 当被垃圾回收时，将终结器引用放入队列 再由一个优先级很低的线程FinalizeHandler的线程查看引用队列中是否有终结器引用，如果有就找到对象调用对象的finalize()方法，在下一次垃圾回收时，就把该对象占用的内存真正回收掉了 垃圾回收算法 JVM会根据具体情况在下面三种方法中选择适当的垃圾回收算法来进行垃圾回收 标记清除算法(Mark Sweep) 标记，将没有被GC Root引用的对象标记出来 清除，将标记的对象进行清除，将对应内存的开始和结束地址放入空闲地址列表即可 优点 速度快 缺点 会造成内存碎片 标记整理算法(Mark Compact) 标记，将没有被GC Root引用的对象标记出来 整理，将标记的对象进行清除，同时进行整理 优点 解决内存碎片的问题 缺点 由于整理涉及到对象的移动，导致效率较低 复制算法(Copy) 将内存区域划分为大小相等的两块区域，一块为FROM另一块为TO 标记，将没有被GC Root引用的对象标记出来 把FROM中存活的对象复制(复制过程中也会进行整理)到TO中，然后清除FROM中的对象 TO变为FROM，FROM变TO 优点 不会产生内存碎片 缺点 占用双倍的内存空间 分代回收 新生代垃圾回收更为频繁，回收一次耗时较少 老年代垃圾回收频率较低，回收一次耗时较多 新创建的对象，存放在伊甸园当中 当继续创建对象时发现伊甸园内的内存空间不足，就会触发一次垃圾回收(Minor GC) Minor GC根据可达性分析算法，对对象进行标记 使用复制算法把存活的对象复制到幸存区TO中，同时将这些对象的寿命+1 幸存区FROM变为TO，TO变成FROM 继续向伊甸园存放对象，当伊甸园再次内存空间不足时，再次触发第二次垃圾回收(Minor GC) Minor GC根据可达性分析算法，对伊甸园中和幸存区中对象进行标记 使用复制算法把存活的对象复制到幸存区TO中，同时将这些对象的寿命+1 当幸存区对象中的寿命达到了阈值(最大寿命为15)，将其晋升到老年代中 幸存区FROM变为TO，TO变成FROM Minor GC会引发stop the world(在垃圾回收时，暂停其他的用户线程，等垃圾回收动作结束，其他的用户线程才可以继续进行) 当老年代空间不足，先尝试触发Minor GC，如果之后空间仍不足，触发一次Full GC(Full GC同样会触发stop the world，且时间更长，采用的是标记整理或标记清除算法) 当老年代空间足够，新生代空间一定不足的情况下，大对象直接晋升到老年代 如果仍旧分配失败，触发OutOfMemoryError 一个线程的OutOfMemoryError不会导致整个进程结束 相关VM参数 含义 参数 堆初始大小 -Xms 堆最大大小 -Xmx或-XX:MaxHeapSize=size 新生代大小 -Xmn或(-XX:NewSize=size+ -XX:MaxNewSize=size) 幸存区比例(动态) -XX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC前MinorGC -XX:+ScavengeBeforeFullGC 分代垃圾回收详情 初始情况 执行后情况 触发第二次GC 垃圾回收器 串行的垃圾回收器 单线程(其他线程都暂停) 堆内存较小时，适合个人电脑 Serial：工作在新生代，采用的是复制算法SerialOld：工作在老年代，采用的是标记整理算法 吞吐量优先的垃圾回收器 多线程 堆内存较大的场景，需要多核cpu来支持 让单位时间内，stop the world的时间最短，降低垃圾回收时间在工作时间的占比 并行的，多个垃圾回收器并行运行，但是垃圾回收期间不允许用户线程继续运行UseParallelGC：作用在新生代，使用复制算法UseParallelOldGC：作用在老年代，使用标记整理算法ParallelGCThreads：控制ParallelGC线程数UseAdaptiveSizePolicy：采用自适应的大小调整策略，调整新生代大小(动态调整伊甸园和幸存区比例，以及晋升阈值)GCTimeRatio ：调整垃圾回收与总时间的占比(1/(1+ratio))(ratio默认为99)垃圾回收时间占总时间的最大比例，一般修改为19MaxGCPauseMillis：默认值为200ms，单次垃圾回收暂停最大时间，与GCTimeRatio成反比需要折中(当堆变大，单词回收时间变长，当堆变小，垃圾回收占比增加，减少吞吐量) 响应时间优先的垃圾回收器 多线程 堆内存较大的场景，需要多核cpu来支持 让单次的stop the world的时间尽可能的短，降低每次垃圾回收所需要的时间 使用标记清除算法的垃圾回收器，且为并发的，用户线程与垃圾回收线程并发进行UseConMarkSweepGC：工作在老年代，使用标记清除算法，如果出现并发失败的问题使用SerialOld来进行补救，使用标记整理的方法UseParNewGC：工作在新生代的垃圾回收器：复制算法ParallelGCThreads：并行的垃圾回收线程数ConGCThreads：并发的垃圾回收线程数，一般为ParallelGCThreads的四分之一CMSInitiatingOccupancyFraction：内存占比到多少百分比时来进行垃圾回收CMSScavengeBeforeRemark：在重新标记前对新生代进行一次垃圾回收，减少重新标记时垃圾回收器扫描的数量，减少时间 老年代发生了内存不足，线程到达安全点暂停 CMS(ConcMarkSweepGC)进行初始标记，依然需要stop the world 用户线程可以回复运行，垃圾回收线程并发标记 并发标记后，stop the world 重新标记(线程中的资源可能发生改变) 用户线程恢复运行，垃圾回收器进行并发的清理 运行过程中可能产生新的垃圾，成为浮动垃圾，需要在下次垃圾回收时进行回收 需要预留空间保留浮动垃圾来保证用户线程的运行 碎片太多时，无法继续存放对象，进行一次SerialGC G1(garbage one) 定义 Garbage FirstJDK9默认，废弃了CMS垃圾回收器 适用场景 同时注重吞吐量和低延迟，默认的暂停目标为200ms 超大堆内存，会将堆划分为多个大小相等的Region 整体上是标记+整理算法，两个区域之间是复制算法 相关JVM参数 -XX：+UseG1GC：JDK9以后默认开启，无需显式启用-XX：G1HeapRegionSize=size：设定Region大小-XX：MaxGCPauseMillis=time：设定暂停目标 G1垃圾回收阶段 新生代的垃圾收集 老年代内存超过阈值，在新生代垃圾回收的同时进行并发的标记 混合收集：对新生代和老年代都进行垃圾收集 YoungCollection 会STW 每个方格代表一个Region(该Region可以为伊甸园或幸存区或老年代)，空白表示为空闲区域，E代表伊甸园区域，S代表幸存区，O代表老年代当伊甸园将要被占满触发新生代的垃圾回收(YoungCollection也会STW)，通过复制算法放入幸存区幸存区的对象较多，或年龄超过阈值，再次触发新生代的垃圾回收，一部分对象进入到老年代，另一部分被垃圾回收或者拷贝到另一个幸存区 YoungCollection + ConcurrentMark 在YoungGC时会进行GCRoot的初始标记 老年代占用堆空间比例达到阈值时，进行并发标记(不会STW)，比例由-XX:InitiatingHeapOccupancyPersent=percent确定默认为45% Mixed Collection 会对E、S、O进行全面的垃圾回收 最终标记(Remark)会STW，并发标记中可能漏掉的对象，浮动垃圾 拷贝存活(Evacuation)会STW 新生代：复制算法(黑色箭头) 老年代：复制算法(红色箭头，G1根据最大暂停时间选择性地进行一个垃圾回收，所以不是所有老年代都进行垃圾回收，选择垃圾最多的老年代区域进行垃圾回收) -XX:MaxGCPauseMillis=ms FullGC SerialGC 新生代内存不足发生的垃圾收集 -Minor GC 老年代内存不足发生的垃圾收集 -FullGC ParallelGC 新生代内存不足发生的垃圾收集 -Minor GC 老年代内存不足发生的垃圾收集 -FullGC CMS 新生代内存不足发生的垃圾收集 -Minor GC 老年代内存不足 并发收集阶段，不为FullGC 并发失败，退化为串行垃圾收集，FullGC G1 新生代内存不足发生的垃圾收集 -Minor GC 老年代内存不足 当老年代内存占比超过阈值时，触发并发标记阶段及混合收集的阶段 如果回收速度高于线程垃圾产生速度时，为并发垃圾收集 如果垃圾回收速度低于线程垃圾产生速度，并发收集失败，退化为多线程的垃圾收集-FullGC Young Collection跨代引用 新生代回收的跨代引用(老年代引用新生代)问题 把老年代分为再次戏分为card，如果card中的对象引用了新生代中的对象，那么该card被标记为脏card 新生代中由Remembered Set记录Incoming Reference(记录外部对他的引用)，记录都有哪些脏card 在对新生代标记时，先根据Remembered Set找到对应脏card，再从脏card进行GCRoot 在引用变更时通过post-write barrier + dirty card queue，来标记脏card(异步操作，先将指令放在队列中，之后由一个线程完成脏卡的更新操作) concurrent refinement threads更新Remembered Set Remark(重新标记阶段)(需要对着书重新整理) pre-write barrier + satb_mark_queue 上图表示并发标记阶段时的对象处理状态， 黑色的指标记完成，且有对象引用的。 灰色表示正在标记处理的 白色表示还没有进行标记处理的 B正在处理中，在处理后变为黑色 如果A引用了C，但是A已经完成标记，不会再对A进行标记，所以无法对C进行标记 但是C依然是被引用的，所以不能被垃圾回收掉 当对象的引用发生改变，触发写屏障代码，将该对象放入到一个队列中，并置为灰色。在进入到重新标记阶段时，对该队列中的对象重新进行一个检查 JDK8u20字符串去重 优点：节省大量内存 缺点：略微多占用了CPU时间，新生代回收时间略微增加 -XX:+UseStringDeduplication String s1 = new String(&quot;hello&quot;);//char[]{'h','e','l','l','o'} String s2 = new String(&quot;hello&quot;);//char[]{'h','e','l','l','o'} 将所有新分配的字符串放入一个队列 当新生代回收时，G1并发检查是否有字符串重复 如果它们值一样，让它们引用同一个char[] 注意，与String.intern()不一样 String.intern()关注的是字符串对象 而字符串去重关注的是char 在JVM内部，使用了不同的字符串表 JDK8u40并发标记类卸载 所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类-XX:+ClassUnloadingWithConcurrentMark默认启用 JDK8u60回收巨型对象 一个对象大于Region的一半时，称之为巨型对象 G1不会对巨型对象进行拷贝 回收时被优先考虑 G1会跟踪老年代所有incoming引用，当巨型对象的incoming为0时，巨型对象可以在新生代垃圾回收时处理掉 JDK9并发标记起始时间的调整 并发标记必须在堆空间占满前完成，否则退化为FullGC JDK9之前需要使用-XX:InitiatingHeapOccupancyPercent JDK9可以动态调整 -XX:InitiatingHeapOccupancyPercent用来设置初始值 进行数据采样并动态调整 总会添加一个安全的存档空间 垃圾回收调优 调优的领域 内存 锁竞争 cpu占用 io 确定调优目标 低延迟还是高吞吐量，选择合适的回收站 科学计算适合高吞吐量 web项目适合低延迟 选择合适的垃圾回收器 低延迟：CMS、G1、ZGC 高吞吐量：ParallelGC 可以通过更换虚拟机来进行调优：例如，Zing虚拟机 最快的GC是不发生GC 查看FullGC前后的内存占用，考虑如下的问题 数据是不是太多 resultSet = statement.executeQuery(&quot;select * from 表&quot;) 数据表示是否太臃肿 对象图 对象大小 是否存在内存泄漏 static Map map 一直向静态map中存放对象 熟练使用软弱引用，使用缓存时，使用第三方的缓存实现 新生代调优 新生代特点 所有的new操作的内存分配非常廉价 TLAB thread-local allocation buffer 每个线程都会在伊甸园中被分配一块私有的区域 当线程new一个对象时，如果TLAB有空间，那么优先在TLAB分配内存 减少了线程分配内存时的冲突 死亡对象的回收代价是零 大部分对象用过即死 MinorGC的时间远远低于FullGC 调优 -Xmn(设置新生代的初始大小和最大大小)：Oracle建议新生代大小为整个堆大小的25%-50%，刚开始时随着新生代的容量增大，吞吐量逐渐升高，但是到达一定大小后，吞吐量随着新生代容量增大会减少(但是减少的程度较小)(新生代容量太大会导致老年代容量变少，容易触发FullGC，导致垃圾回收消耗时间变长)。建议设置为并发量*(请求响应过程中产生对象)幸存区：大小能保留当前活跃对象+需要晋升对象 幸存区晋升阈值：晋升阈值配置得当，让长时间存活对象尽快晋升-XX:MaxTenuringThreshold=threshold：调整最大晋升阈值-XX:+PrintTenuringDistribution：显示晋升详细信息 老年代调优 以CMS为例 CMS的老年代内存越大越好 先尝试不做调优，如果没有FullGC那么已经很好了，否则先尝试调优新生代 观察发生FullGC时老年代内存占用，将老年代内存预设调大1/4-1/3 -XX:CMSInitiatingOccupancyFraction=percent超过百分比进行CMS垃圾回收 调优案例 1. FullGC和MinorGC频繁，且MinorGC更频繁 新生代空间小，且会造成生命周期短的对象进入到老年代从而引发FullGC通过增大新生代空间，同时提高幸存区晋升阈值，让生命周期较短的对象留在新生代中 2.请求高峰期发生FullGC，单词暂停时间特别长(CMS) 查看GC详情，发现重新标记耗时较多在重新标记前进行一次新生代的垃圾回收-XX:CMSScavengeBeforeRemark 3.老年代充裕情况下，发生FullGC(JDK1.7 CMS) 永久带空间不足 ","link":"https://yeyuan1107.github.io/post/jvm-la-ji-hui-shou/"},{"title":"JVM内存结构","content":"程序计数器 程序计数器、虚拟机栈、本地方法栈都是线程私有的堆、方法区都是线程共享的 定义 Program Counter Register(程序计数器)(寄存器) 作用 右侧为Java源代码 左侧为二进制字节码，对应每一条jvm指令，jvm指令需要通过解释器生成机器码，再将机器码交给CPU来执行 程序计数器：记住下一条jvm指令的执行地址，当前指令执行结束后，解释器到程序计数器读取下一条指令的地址，接着进行执行 程序计数器：物理(硬件)上是通过寄存器来实现的 特点 线程私有的，属于当前线程。如果当前线程时间片耗尽，程序计数器记录当前线程的下一条指令地址，等到当前线程获得CPU时继续进行执行 唯一一个不会存在内存溢出的区 虚拟机栈 -Xss指定虚拟机栈大小 虚拟机栈指的是线程运行需要的内存空间，多个线程就有多个虚拟机栈栈内的元素称之为栈帧。 栈帧指的是每个方法运行时需要的内存(方法参数，局部变量，返回地址等)当线程调用一个方法时，虚拟机栈为该方法分配栈帧空间，并将栈帧压入虚拟机栈中，等方法结束时将该方法对应的栈帧弹出栈 定义 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 垃圾回收不涉及栈内存，垃圾回收只涉及堆内存栈内存越大线程数越少，并不是越大越好方法内的局部变量(不逃离方法的作用范围，逃离作用范围的行为比如作为参数传入或者作为返回值传出)是线程私有的，就无须考虑线程安全的问题，他是线程安全的。反之，如果为线程共享的，就需要考虑线程安全问题如果局部变量引用了对象，并逃离了方法作用范围，需要考虑线程安全问题。如果为基本数据类型变量，则不需要考虑线程安全问题 栈内存溢出(StackOverflowError) 栈帧过多导致栈内存溢出 栈帧过大导致栈内存溢出 线程运行诊断 案例一：CPU占用过多 用top命令定位哪个进程对cpu的占用过高 ps H -eo pidmtid,%cpu | grep 进程id() 用ps命令进一步定位是哪个线程引起的cpu占用过高 jstack 进程id 可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行数 案例二：程序运行很长时间没有结果 jstack查看是否存在死锁 本地方法栈 给本地方法的运行(有一些方法无法使用Java实现，使用本地C++代码实现)，提供内存空间 堆(Heap) -Xmx指定堆空间大小 定义 通过new关键字创建的对象都会使用堆 特点他是线程共享的，堆中对象都需要考虑线程安全的问题有垃圾回收机制 堆内存溢出(OutOfMemoryError OOM) 堆内存诊断 jps工具 查看当前系统中有哪些java进程 jmap工具 查看堆内存占用情况 jmap -heap 进程id Eden Space(新生代)：新创建的对象使用的区域 jconsole工具 图形界面的，多功能的检测工具，可以连续监测 案例 垃圾回收后，内存占用仍然很高 jvisualvm -&gt; 堆dump -&gt; 最大的对象 方法区 -XX:MaxMetaspaceSize=8m//指定元空间大小 定义 所有线程共享的区域，在方法区中存储了类的结构的有关信息(Field、方法数据、方法及构造器方法的代码、运行时常亮池) 方法区在虚拟机启动时被创建，逻辑上是堆的一个组成部分(不同厂家实现不同) 方法区也会抛出内存溢出错误 组成 常量池(运行时常量池)： 一个类要运行需要先编译成二进制字节码(二进制字节码中包含：类的基本信息，常量池，类的方法定义，包含了虚拟机指令) javap -v xxx.class 显示反编译后的详细信息 #xx代表从常量池中寻找编号为xx的内容 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号#xx地址变为真实地址 方法区内存溢出(OutOfMemoryError OOM) 1.8以前会导致永久代内存溢出 OutOfMemoryError:PermGen space -XX:MaxPermSize=8m 1.8之后会导致元空间内存溢出 OutOfMemoryError:Metaspace -XX:MaxMetaspaceSize=8m 常见场景： Spring：cglib动态生成字节码 MyBatis：cglib动态生成字节码 上述两种情况导致方法区类不停加载，从而导致OOM 运行时常量池 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号#xx地址变为真实地址 StringTable 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是StringBuilder(1.8) 字符串常量凭借的原理是编译期优化 可以使用intern方法，主动将 串池中还没有的字符串对象放入串池 1.8intern()将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，不管有没有，最终都返回串池中的对象。如果成功放入那么当前对象的地址与常量池中的地址变为相同，否则不会发生变化 1.6intern()将这个字符串对象尝试放入串池，如果有则不会放入，如果没有会把此对象复制一份，然后放入串池，不管有没有，最终都返回串池中的对象。不管成功放入与否那么当前对象的地址与常量池中的地址均不相同 // 1. 常量池中的信息，都会被加载到运行时常量池中，这时&quot;a&quot;、&quot;b&quot;、&quot;ab&quot;都是常量池中的符号，还没有变为Java字符串对象 // 2. ldc #2 会把 a 符号变为&quot;a&quot;字符串对象，同时准备好一处空间，称为StringTable[ ]\\(HashTable结构无法扩容) // 3. 从StringTable[ ]中寻找 a 对象，如果不存在则放入到StringTable中(用到才会创建并放到StringTable中，用不到就不会创建) // 4. ldc #3 会把 b 符号变为&quot;b&quot;字符串对象 // 5. 从StringTable[ ]中寻找 b 对象，如果不存在则放入到StringTable中 // 6. ldc #4 会把 ab 符号变为&quot;ab&quot;字符串对象 // 7. 从StringTable[ ]中寻找 ab 对象，如果不存在则放入到StringTable中 String s1 = &quot;a&quot;; String s2 = &quot;b&quot;; String s3 = &quot;ab&quot;; // new StringBuilder().append(s1).append(s2).toString() // toString()相当于创建了一个新的String变量 new String(&quot;ab&quot;) 并存入到s4中 // s3是StringTable中的一个字符串对象，s4是一个新的字符串对象存放在堆中 String s4 = s1 + s2; // javac在编译期间的优化，结果已经在编译期间确定为&quot;ab&quot;不可能再变化 String s5 = &quot;a&quot; + &quot;b&quot;; String s6 = s4.intern(); System.out.println(s3 == s4); //false System.out.println(s3 == s5); //true System.out.println(s3 == s6); //true // 执行完该行代码后StringTable中有&quot;c&quot;和&quot;d&quot; // new String(&quot;c&quot;) 是new了一个String对象，该对象存放在堆中 // new String(&quot;d&quot;) 是new了一个String对象，该对象存放在堆中 // x2 = new String(&quot;cd&quot;) 放在堆中，并不放在串池中 String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;); String x1 = &quot;cd&quot;; // intern()将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，不管有没有，最终都返回串池中的对象 // 如果成功放入那么x2的地址改为常量池中的地址，否则不会发生变化 x2.intern(); System.out.println(x1 == x2); //false // 如果倒数两行代码互换位置 那么为true 。但是如果是Java6及之前依然为false StringTable位置 1.6及之前StringTable在常量池中 永久代垃圾回收效率较低 需要使用Full GC才进行永久代的垃圾回收 Full GC只有在老年代空间不足时才会触发 1.7及之后StringTable在堆中 堆中垃圾回收效率高 Minor GC进行堆中的垃圾回收 减轻了字符串对方法区的内存占用 StringTable垃圾回收 -Xmx1m -XX:+PringStringTableStatistics开启StringTable统计功能 -Xx:+PrintGCDetails -verbose:gc打印垃圾回收的详细信息 StringTable中也存在垃圾回收，并不会一直保存 StringTable性能调优 -Xx:StringTableSize=200000 //底层为HashTable为数组和链表相结合，调整数组(桶)大小 调整-Xx:StringTableSize=桶个数 考虑将字符串对象是否入池，如果有大量字符串重复，可以将重复的字符串入池，节省内存空间 直接内存(Direct Memory) 定义 常见于NIO操作时，用于数据缓冲区(ByteBuffer) 分配回收成本较高，但是、读写性能高 不受JVM内存回收管理 不使用直接内存：java无法直接访问系统缓存区，需要先从系统缓存区读入到java缓存区中，再读入到程序中进行使用 使用直接内存：直接划分一块直接内存，该内存既可以操作系统访问，又可以java程序访问，提高文件的读取速度 直接内存的释放 Cleaner中的this指ByteBuffer对象，当ByteBuffer对象被垃圾回收掉时，就会触发其中的clean()方法。在ReferenceHandler线程中监测虚引用对象，一旦虚引用对象关联的实际对象(ByteBuffer)被回收，就会执行clean()方法，执行任务对象(Deallocator) 分配和回收 使用了Unsafe对象完成直接内存的分配和回收，并且回收需要主动调用freeMemory方法 ByteBuffer的实现类内部，使用了Cleaner(虚引用)来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory方法来释放内存 -Xx:+DisableExplicitGC禁用代码中显式的垃圾回收 System.gc()显式的垃圾回收，触发FullGC，同时清理新生代和老年代，耗费时间较长 可能对ByteBuffer有影响，导致直接内存占用较大 如需使用-Xx:+DisableExplicitGC，直接内存使用unsafe.freeMemory()管理直接内存 ","link":"https://yeyuan1107.github.io/post/jvm-nei-cun-jie-gou/"},{"title":"JVM引言","content":"什么是JVM Java Virtual Machine - Java程序的运行环境(Java二进制字节码的运行环境) JVM的好处 Java程序一次编写，到处运行的基石 自动内存管理，提供了垃圾回收的功能 数组下标越界检查 多态 比较 常见JVM 本笔记基于HotSpot 学习路线 ","link":"https://yeyuan1107.github.io/post/jvm-yin-yan/"},{"title":"Java11新特性","content":" String新增方法 isBlank()：判断字符串是否为空白 strip()：去除首尾空白 stripTrailing()：去除尾部空格 stripLoading()：去除首部空格 repeat(int count)：复制字符串 lines().count()：行数统计 Optional加强 局部变量类型推断的升级 在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样的语法 //错误的形式 : 必须要有类型 , 可以加上 var //Consumer&lt;String&gt; con1 = (@Deprecated t) --&gt;System.out.println(t.toUpperCase()); //正确的形式 //使用 var 的好处是在使用 lambda 表达式时给参数加上注解。 Consumer&lt;String&gt; con2 = ( (@Deprecated var t) --&gt;System. out .println(t.UpperCase()); 全新的HTTP客户端API 更简化的编译运行程序 JDK11之前javac xxx.javajava xxxJDK11及之后java xxx.java 注意： 执行源文件中的第一个类，第一个类必须包含主方法并且不可以使用其他源文件中的自定义类，本文件中的自定义类是可以使用的 废弃Nashorn引擎 废除Nashorn javascript 引擎 在后续版本准备移除掉，有需要的可以考虑使用 GraalVM。 ZGC GC 是 java 主要优势之一 。 然而当 GC 停顿太长 就会开始影响应用的响应时间 。 消除或者减少 GC 停顿时长 java 将对更广泛的应用场景是一个更有吸引力的平台 。 此外 现代系统中可用内存不断增长用户和程序员希望 JVM 能够以高效的方式充分利用这些内存 并且无需长时间的 GC 暂停时间 。 ZGC A Scalable Low Latency Garbage Collector(Experimental)，这应该是 JDK 11 最为瞩目的特性没有之一。 但是后面带了 Experimental，说明这还不建议用到生产环境。ZGC 是一个并发，基于 region，压缩型的垃圾收集器只有 root 扫描阶段会STW( stop the world )因此 GC 停顿时间不会随着堆的增长和存活对象的增长而变长 优势： GC 暂停时间不会超过 10 ms 既能处理几百兆的小堆也能处理几个T的大堆 和G1相比应用吞吐能力不会下降超过15% 为未来的GC功能和利用 colord 指针以及 Load barriers 优化奠定基础 初始只支持 64 位系统 ZGC 的设计目标是：支持 TB 级内存容量暂停时间低 10 ms 对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆(即热对象置于 DRAM 和冷对象置于 NVMe 闪存或压缩堆) 其他新特性 Unicode 10 Deprecate the Pack200 Tools and API 新的 Epsilon 垃圾收集器 完全支持 Linux 容器(包括 Docker) 支持 G1 上的并行完全垃圾收集 最新的 HTTPS 安全协议 TLS 1.3 Java Flight Recorder ","link":"https://yeyuan1107.github.io/post/java11-xin-te-xing/"},{"title":"Java10新特性","content":" 局部变量的类型推断 //引用型变量也可以 //在处理var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中 var 变量名 = xxx; 不能用的情况 局部变量不赋值 Lambda表达式中左边的函数式接口不能声明为var 方法引用 数组的静态初始化int[] arr = {1, 2, 3, 4, 5} 方法的返回值类型 方法中的参数类型、构造器参数类型 属性 catch块 注意 var不是一个关键字，除了不能用它作为类名，其他的都可以 var并不会改变Java时一门静态类型语言的事实 集合新增创建不可变集合的方法 //示例 1 var list1 = List.of(&quot; Java&quot;, &quot; Python&quot;, &quot;C&quot;); var copy1 = List.copyOf(list1); System.out.println(list1 == copy1); // true //示例 2 var list2 = new ArrayList&lt;String&gt;(); var copy2 = List.copyOf(list2); System.out.println(list2 == copy2); // false //示例 1 和 2 代码基本一致， 为什么一个为 true, 一个为 false? //如果当前集合已经是只读集合，那么copyOf()返回值为当前集合 //如果不是只读集合copyOf()返回一个新的集合，该集合是只读的 ","link":"https://yeyuan1107.github.io/post/java10-xin-te-xing/"},{"title":"Java9新特性","content":" JDK和JRE结构的改变 模块化系统 Jigsaw -&gt; Modularity 随着Java的发展，Java运行环境膨胀和臃肿，每次JVM启动的时候，至少会有30-60MB的内存加载，主要原因是JVM需要加载rt.jar 本质上讲也就是说，用模块来管理各个package，通过声明某个package暴露，模块(module)的概念，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏 模块画的主要目的在于减少内存的开销 只须必要模块，而非全部jdk模块，可见话各种类库和大型应用的开发和维护 改进JavaSE平台，使其可以适应不同大小的计算设备 改进其安全性，可维护性，提高性能 Java的REPL工具：jShell 命令 REPL(read-evaluate-print-loop)，以交互式的方式对语句和表达式进行求职。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈 多版本兼容 jar 包 接口的私有方法 JDK8中增加了static方法和默认方法 JDK9接口中的方法可以是private的 钻石操作符的使用升级 JDK9中匿名实现类钻石操作符中的类型可以省略Comparator\\&lt;Object&gt; com = new Comparator\\&lt;&gt;() ，JDK8中会报错 语法改进： try 语句 JDK8之前，资源的关闭放在finally中。JDK8中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必须在try子句中初始化(catch后自动关闭括号中创建的资源)，否则编译不通过。JDK9中，用资源语句编写try将更容易，我们可以在try字句中使用已经初始化过的资源，此时的资源是final的 String 存储结构变更 String从char[] -&gt; byte[]同时加上编码标记，节约了空间。 StringBuffer和StringBuilder同样更改 快速创建只读集合： of() Java8中：Collections.unmodifiableList(集合名)，Arrays.asList(Object[] objs) Java9中： static List LIst.of(E e1, E e2, ... , E en) Set.of() Map.of() Map.ofEntries() 增强的 Stream API 在 Java 9 中， Stream API 变得更好， Stream 接口中添加了 4 个新的方法takeWhile , dropWhile, ofNullable ，还有个 iterate 方法的新重载方法 ，可以让你提供一个 Predicate ( 判断条件 来指定什么时候结束迭代 。 takeWhile(predicate)返回从开头开始的尽量多的元素，从开头到第一个不满足条件的，Predicate为函数式接口 dropWhile(predicate)与takeWhile()相反，返回第一个不满足条件的元素及其之后的元素 ofNullable()形参变量是可以为null值的单个元素 iterate(seed, predicate, UnaryOperator)重载方法，指定什么时候结束迭代 除了对 Stream 本身的扩展， Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个(可能是空的) Stream 对象。 InputStream加强 InputStream增加方法transferTo(OutputStream)，直接将输入流的所有数据自动地复制到输出流中 全新 的 HTTP 客户端 API Deprecated 的相关 API javadoc 的 HTML 5 支持 Javascript 引擎升级： Nashorn java 的动态 编译器 ","link":"https://yeyuan1107.github.io/post/java9-xin-te-xing/"},{"title":"Java8新特性","content":" Lambda表达式 Lambda是一种匿名函数，我们可以吧Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简介、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。本质上是一个接口的实例，且该接口应为函数式接口 语法格式 -&gt;：lambda操作符或箭头操作符-&gt;左边：lambda的形参列表，其实就是抽象方法的形参列表，类型可以省略-&gt;右边：lambda体，其实就是重写的抽象方法的方法体上述Lambda表达式中的参数类型都是由编译器推断得出的。Lambda表达式中无需指定类型，程序依然可以编译，这是因为javac根据程序的上下文，在后台推断出了参数的类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的&quot;类型推断&quot; 函数式接口 只包含一个抽象方法的接口，称为函数式接口 可以在一个接口上使用@FunctionalInterface注解，这样做可以检查它是否是一个函数式接口。同时javadoc也会包含一条生命，说明这个接口是一个函数式接口 你可以通过Lambda表达式来创建该接口的对象(若Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明) java.util.function包下定义了Java8的丰富的函数式接口 Java内置四大核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer消费型接口 T void 对类型为T 的对象应用操作，包含方法: void accept(T t) Supplier供给型接口 无 T 返回类型为T 的对象，包含方法: T get() Function&lt;T, R&gt;函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法: R apply(T t) Predicate断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法: boolean test(T t) 其他接口 方法引用 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用 方法引用可以看作是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的语法糖 实现接口的抽象方法的参数列表喝返回值类型，必须与方法引用的方法的参数列表喝返回值类型保持一致 格式：类名(或对象名)::方法名 对象::非静态方法名 类::静态方法名 上述两种要求实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表喝返回值类型保持一致 类::非静态方法名 当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数时)：使用该格式。第一个参数所属类::方法名。比如BiPredicate&lt;String, String&gt; bp = (x,y) -&gt; x.equals(y)使用BiPredicate&lt;String, String&gt; bp = String::equals 构造器引用 格式：ClassName::new 与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。 数组引用 格式：type[]::new Stream API Stream API ( java.util.stream) 把真正的函数式编程风格引入到 Java 中。这是目前为止对 Java 类库最好的补充，因为 Stream API 可以极大提供 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之， Stream API 提供了一种高效且易于使用的处理数据的方式。 Stream 和 Collection 集合的区别： Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。 前者是主要面向内存，存储在内存中，后者主要是面向 CPU ，通过 CPU 实现计算。 Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列 Stream自己不会存储元素 Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行 Stream操作的三个步骤 创建Stream：一个数据源，获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作(终端操作)：一旦执行终止操作，就执行中间操作脸，并产生结果。之后不会再被使用 创建 方式一：通过集合Java8中的Collection接口被扩展，提供了两个获取流的方法 default Stream stream()：返回一个顺序流 default Stream parallelStream()：返回一个并行流 集合名.stream()或集合名.parallelStream() 方式二：通过数组Java8中的Arrays的静态方法stream()可以获取数据流 static Stream stream(T[] array)：返回一个流 public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) Arrays.stream(数组名) 方式三：通过Stream的of()可以调用Stream类静态方法of()，通过显示值创建一个流。他可以接收任意数量的参数 public static Stream of(T...values)：返回一个流 Stream.of(数值一, 数值二, ..., 数值n) 方式四：创建无限流可以使用静态方法iterate()和generate()创建无限流 迭代：public static Stream iterate(final T seed, final UnaryOperator f) 生成：public static Stream generate(Supplier s) public void test4() { //迭代 //public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) Stream&lt;Integer&gt; stream = Stream.iterate(0, x-&gt; x +2); stream.limit(10).forEach(System.out::println); //生成 //public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) Stream&lt;Double&gt; stream1 = Stream.generate(Math::random); stream1.limit(10).forEach(System.out::println); } 中间操作 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为&quot;惰性求值&quot; 方法 描述 筛选与切片 filter(Predicate p) 接收Lambda 从流中排除某些元素 distinct() 筛选，通过流所生成元素的hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与 limit(n) 互补 映射 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 排序 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排序 终止操作 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如： List 、 Integer ，甚至是 void 。 流进行了终止操作后，不能再次使用。 方法 描述 匹配与查找 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch (Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) 归约 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T，iden为初始值 reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 收集 collect(Collector c) 将流转换为其他形式。接收一个Collector接口的实现，用于给 Stream 中元素做汇总的方法。Collector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。另外，Collectors实用类提供了很多静态方法，可以方便地创建常见的收集器类型 Collectors Optional类 为了解决空指针异常而引入的一个容器 Optional 类 (java.util.Optional) 是一个容器类 它可以保存类型 T 的值， 代表这个值存在 。或者仅仅保存 null ，表示这个值不存在 。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且 可以避免空指针异常 。 Optional 类的 Javadoc 描述如下：这是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true ，调用 get() 方法会返回该对象。 Optional类方法 Optional 提供很多有用的方法，这样我们就不用显式进行空值检测 。 方法 描述 创建 Optional 类对象的方法 Optional.of(T t) 创建一个 Optional 实例， t 必须非空 Optional.empty() 创建一个空的 Optional 实例 Optional.ofNullable(T t) t 可以为 null 判断 Optional 容器中是否包含对象 boolean isPresent() 判断是否包含对象 void ifPresent(Consumer&lt;? super T&gt; consumer) 如果有值，就执行 Consumer接口的实现代码，并且该值会作为参数传给它。 获取 Optional 容器的对象 T get() 如果调用对象包含值，返回该值，否则抛异常 T orElse(T other) 如果有值则将其返回，否则返回指定的 other 对象。 T orElseGet(Supplier&lt;? extends T&gt; other) 如果有值则将其返回，否则返回由Supplier 接口实现提供的对象。 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果有值则将其返回，否则抛出由 Supplier 接口实现提供的异常。 @Test public void test1() { Boy b = new Boy(&quot;张三&quot;); Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGirlFriend()); //如果女朋友存在就打印女朋友的信息 opt.ifPresent(System.out::println); } @Test public void test2() { Boy b = new Boy(&quot;张三&quot;); Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGirlFriend()); //如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了 Girl girl = opt.orElse(new Girl(&quot;嫦娥&quot;)); System.out.println(&quot;他的女朋友是:&quot;+ girl.getName()); } @Test public void test3(){ Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;,8888)); //判断 opt 中员工对象是否满足条件，如果满足就保留，否则返回空 Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;10000); System.out.println(emp); } @Test public void test4(){ Optional&lt;Employee&gt; opt = Optional.of(new Employee(&quot;张三&quot;, 8888)); //如果 opt 中员工对象不为空，就涨薪 10% Optional&lt;Employee&gt; emp = opt.map(e -&gt;e.setSalary(e.getSalary()%1.1); return e;}); System.out.println(emp); } ","link":"https://yeyuan1107.github.io/post/java8-xin-te-xing/"},{"title":"Java反射","content":" 简介 反射是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部消息，并能直接操作任何对象的内部属性及方法。 加载完类之后，在对内存的方法区中就产生了一个Class类型的对象（一个类只能有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们称之为反射 动态语言：在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。主要动态语言：C#、JavaScript、Python等 Java静态 + 反射 -&gt; 准动态语言 反射的作用 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 反射相关的主要API java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 ... Class 在Object类中定义了public final Class getClass()以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果也很好理解，即可以通过对象反射求出类的名称。 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class示例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class类的常用方法 方法 描述 static Class forName (String name) 返回指定类名name 的 Class 对象 Object newInstance() 调用缺省构造函数，返回该Class 对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或 void ）名称 Class getSuperClass() 返回当前Class 对象的父类的 Class 对象 Class [] getInterfaces () 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Constructor[] getConstructors 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields 返回Field 对象的一个数组 Method getMethod (String name, Class … paramTypes) 返回一个Method 对象，此对象的形参类型为paramType String str = &quot;test4.Person&quot;; Class clazz = Class.forName(str); Object obj = clazz.newInstance(); Field field = clazz.getField(&quot;name&quot;); field.set(obj,&quot;Peter&quot;); Object name = field.get(obj); System.out.println(name); 获取Class类的实例 //1. 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 Class&lt;T&gt; clazz = T.class; //2. 已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class clazz = &quot;str&quot;.getClass(); //3. 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException Class clazz = Class.forName(&quot;java.lang.String&quot;); //4. 使用类的加载器，loadClass传入参数为类的全类名 ClassLoader cl = this.getClass().getClassLoader(); Class clazz = cl.loadClass(&quot;java.lang.String&quot;) 哪些类型可以有Class对象 class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 类的加载与ClassLoader的理解 类在经过javac命令后生成一个或多个.class字节码文件，接着我们使用java.exe命令对某个字节码文件进行解释运行相当于将某个字节码文件加载到内存中，此过程称之为类的加载，加载到内存中的类，我们称之为运行时类，此运行时类，就作为Class的一个实例。换句话说，Class的实例就对应一个运行时类 加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个 Class 对象。这个加载的过程需要类加载器参与 。 链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。 验证：确保加载的类信息符合 JVM 规范，例如：以 cafe babe开头，没有安全方面的问题 准备：正式为类变量（ static ）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 。 初始化： 执行**类构造器() **方法的过程。 类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化 。 虚拟机会保证一个类的 () 方法在多线程环境中被正确加锁和同步 。 public class ClassLoadingTest { public static void main(String[] args){ System.out.println(A.m); } } class A { static { m = 300; } static int m = 100; } //第二步：链接结束后 m=0 //第三步：初始化后，m的值由&lt;clinit&gt;方法执行决定 //这个 A 的类构造器&lt;clinit&gt;方法由类变量的赋值和静态代码块中的语句按照顺序合并产生，类似于 // &lt;clinit&gt;(){ // m = 300; // m = 100; // } 什么时候发生类初始化 类的主动引用 一定会发生类的初始化 当虚拟机启动先初始化 main 方法所在的 类 new 一个类的对象 调用类的静态成员除了 final 常量和静态方法 使用 java lang reflect 包的方法对类进行反射调用 当初始化一个类如果其父类没有被初始化则先会初始化它的父类 类的被动引用不会发生类的初始化 当访问一个静态域时只有真正声明这个域的类才会被初始化 当通过子类引用父类的静态变量 不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了) public class ClassLoadingTest { public static void main(String[] args ){ //主动引用：一定会导致 A 和 Father 的初始化 //A a = new A(); //System.out.println(A.m); //Class.forName(&quot;com.atguigu.java2.A&quot;); //被动引用 A[] array = new A[5]; //不会导致 A 和 Father 的初始化 //System.out.println(A.b);// 只会初始化Father //System.out.println(A.M);// 不会导致 A 和Father 的初始化 } static{ System.out .println (&quot;main 所在的类); } } class Father { static int b = 2; static{ System.out.println(&quot;父类被加载&quot;); } } class A extends Father { static{ System.out.println(&quot;子类被加载&quot;); m=300; } static int m = 100; static final int M = 1; } ClassLoader ClassLoader常用方法 // 获取一个系统类加载器 ClassLoader classloader = ClassLoader.getSystemClassLoader(); System.out.println(classloader); // 获取系统类加载器的父类加载器，即扩展类加载器 classloader = classloader.getParent(); System.out.println(classloader); // 获取扩展类加载器的父类加载器，即引导类加载器 classloader = classloader.getParent(); System.out.println(classloader); // 测试当前类由哪个类加载器进行加载 classloader = Class.forName (&quot;exer2.getClassLoader&quot;).getClassLoader(); System.out.println(classloader); // 测试 JDK 提供的 Object 类由哪个类加载器加载 classloader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(classloader); //* 关于类加载器的一个主要方法：getResourceAsStream(String str)获取类路径下的指定文件的输入流 InputStream in = null; in = this.getClass().getClassLoader().getResourceAsStream (&quot;exer2\\\\test.properties&quot;); System.out.println(in); 通过类加载器读取配置文件 Properties pros = new Properties(); //方式一： FileInputStream fis = new FileInputStream(&quot;text.properties&quot;); pros.load(fis); String name = pros.getProperty(&quot;user&quot;); String pwd = pros.getProperty(&quot;password&quot;); //方式二： ClassLoader classLoader = xx.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;text.properties&quot;); pros.load(is); String name = pros.getProperty(&quot;user&quot;); String pwd = pros.getProperty(&quot;password&quot;); 创建运行时类的对象 创建类的对象：调用Class对象的newInstance()方法 newInstance()方法的要求： 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 JavaBean中要求提供一个public的空参构造器 便于通过反射，创建运行时类的对象 便于子类继承此运行时类的对象时默认调用super()，保证父类有此构造器 如果该类没有无参的构造器： 通过Class类的getDeclaredConstructor(Class...parameterTypes)取得被类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里边包含了构造器所需的各个参数 通过Constructor实例化对象 //方式一 //1. 无泛型 Class clazz = Person.class; Object obj = clazz.newInstance(); //2. 有泛型 Class&lt;T&gt; clazz = Person.class; Person person = clazz.newInstance(); //方式二： //1.根据全类名获取对应的 Class 对象 String name = &quot;atguigu.java.Person&quot;; Class clazz = null; clazz = Class.forName(name); //2.调用指定参数结构的构造器，生成 Constructor 的实例 Constructor con = clazz.getConstructor(String.class,Integer.class); //3.通过 Constructor 的实例创建对应类的对象，并初始化类属性 Person p2 = (Person) con.newInstance (&quot;Peter&quot;,20); System.out.println(p2); 获取运行时类的完整结构 通过反射获得 Field、 Method 、 Constructor 、 Superclass 、 Interface 、 Annotation public Field[] getFields()返回此Class对象所表示的类或接口的public的Filed public FIeld[] getDeclaredFields()返回此Class对象所表示的类或接口的全部Field Field类方法： public int getModifiers()以整数形式返回此Field的权限修饰符 public Class&lt;?&gt; getType()得到Field的属性名称 public String getName()返回FIeld的名称 Method public Method[] getMethods()返回此Class对象所表示的类或接口的public的方法 public Method[] getDeclaredMethods()返回此Class对象所表示的类或接口的全部方法 Method类方法 public Class&lt;?&gt; getReturnType()取得全部的返回值 public Class&lt;?&gt;[] getParameterTypes()取得全部的参数 public int getModifiers()取得权限修饰符 public Class&lt;?&gt;[] getExceptionTypes()取得异常信息 Annotation getAnnotation(Class annotationClass) public Annotation[] getAnnotations()获取注解 getDeclaredAnnotations() 实现的全部接口 public Class&lt;?&gt;[] getInterfaces()取得此对象所表示的类或接口实现的接口 所继承的父类 public Class&lt;? super T&gt; getSuperclass()返回表示此Class所表示的实体(类、接口、基本类型)的父类的Class 全部的构造器 public Constructor[] getConstructors()返回此Class对象所表示的类的所有public构造器 public Constructor[] getDeclaredConstructors()返回此Class对象所表示的类声明的所有构造器 Constructor类方法 public int getModifiers()取得权限修饰符 public String getName()取得方法名称 public Class&lt;?&gt;[] getParameterTypes()取得参数的类型 泛型相关 Type getGenericSuperclass()获取父类泛型类型 ParameterizedType泛型类型 public Type[] getActualTypeArguments()获取实际的泛型类型参数数组，通过ParameterizedType类型的对象调用，返回Type[] 类所在的包 Package getPackage()获取所在的包 调用运行时类的指定结构 调用指定方法 //推荐直接使用getDeclaredMethod()方法 //通过Class类的getMethod(String name, Class...parameterTypes)方法取得一个Method对象，并设置此方法操作时需要的参数类型 Method method = clazz.getMethod(String name, Class...parameterTypes); //之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息 //Object对应元方法的返回值，如果原方法无返回值，此时返回null //若原方法形参列表为空，则Object[] args为null //若原方法为静态方法，则行参Object obj可为null //若原方法声明为private，则使用getDeclaredMethod()方法，并且在invoke()前，显示调用方法对象的setAccessible(true)方法，将可访问private的方法 Objcet returnValue = method.invoke(Object obj, Object[] args); 调用指定属性 //获取Field Field name1 = clazz.getField(String name); Field name2 = clazz.getDeclaredField(String name); //public Object get(Object obj)取得指定对象obj上此Field的属性内容 //public void set(Object obj, Object value)设置指定对象obj上此Field的属性 name1.set(Object obj, Object value); name1.get(Object obj); //getDeclaredField()方法获取的Field在使用前建议调用setAccessible(true)的方法 //setAccesssible启动和禁用访问安全检查的开关 //参数值为true则只是反射的对象在使用时应该取消Java语言访问检查 // 提高反射的效率，如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true // 使得原本无法访问的私有成员也可以访问 //参数值为false则只是反射的对象应该实施Java语言访问检查 name2.setAccessible(true); name2.set(Object obj, Object value); name2.get(Object obj); 调用构造器 //获取指定形参类型的构造器 Constructor con = clazz.getDeclaredConstructor(Class...parameterType); con.setAccessible(true); //传入实参，创建对象 类 类名 = (类)con.newInstance(Object[] args) 反射的应用：动态代理 静态代理：代理类与被代理类在编译期间就确定了 动态代理与AOP代码示例 public interface Dog{ void info(); void run(); } public class HuntingDog implements Dog{ public void info(){ System.out.println(&quot;我是一只猎狗&quot;); } public void run(){ System.out.println(&quot;我奔跑迅速&quot;); } } public class DogUtil{ public void method1(){ System.out.println(&quot;=====模拟通用方法一=====&quot;);&quot; } public void method2(){ System.out.println(&quot;=====模拟通用方法二=====&quot;); } } public class MyInvocationHandler implements InvocationHandler{ //需要被代理的对象 private Object target; public void setTarget(Object target){ this.target = target; } //执行动态代理对象的所有方法时，都会被替换成执行如下的 invoke 方法 public Object invoke(Object proxy, Method method , Object[] args)throws Exception{ DogUtil du = new DogUtil(); //执行 DogUtil 对象中的 method1 。 du.method1(); //以 target 作为主调来执行 method 方法 Object result = method.invoke (target , args); //执行 DogUtil 对象中的 method2 。 du.method2(); return result; } } public class MyProxyFactory{ //为指定 target 生成动态代理对象 public static Object getProxy (Object target) throws Exception{ //创建一个 MyInvokationHandler 对象 MyInvokationHandler handler = new MyInvokationHandler(); //为 MyInvokationHandler 设置 target 对象 handler.setTarget(target); //创建、并返回一个动态代理对象 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); } } public class Test{ public static void main(String[] args)throws Exception{ //创建一个原始的 HuntingDog 对象，作为 target Dog target = new HuntingDog(); //以指定的 target 来创建动态代理 Dog dog = (Dog) MyProxyFactory.getProxy(traget); dog.info(); dog.run(); } } 反射与封装性是否冲突 不冲突 封装性：解决建议调用什么属性及方法的问题 反射：解决能不能调用的问题 反射与直接new对象是否冲突 不冲突优先使用new对象的方式，只有在编写时不知道创建哪个对象时才使用反射的方法 ","link":"https://yeyuan1107.github.io/post/java-fan-she/"},{"title":"Java网络编程","content":" Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序 Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由JVM进行控制。并且Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境 网络编程的目的：直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯。网络编程的主要问题：如何准确定位网络上一台或多台主机；定位主机上的特定的应用？找到主机后如何可靠高效地进行数据传输 网络编程要素 通信双方地址 IP 唯一的标识Internet上的计算机(通信实体) 本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost IP地址分类一：IPV4、IPV6 IP地址分类二：公网地址和私有地址，192.168.0.0 - 192.168.255.255专门为组织机构内部使用 端口号 表示正在计算机上运行的进程 不同进程有不同的端口号 端口号为一个16位的整数0-65535 端口分类： 公认端口(0-1023)，被预先定义的服务通信占用(如HTTP占用80，FTP占用21，Telnet占用23) 注册端口(1024-49151)，分配给用户进程或应用程序(如Tomcat占用8080，MySQL占用3306，Oracle占用1521) 动态/私有端口(49152-65535) 端口号与IP地址的组合得出一个网络套接字：Socket 一定的规则(即：网络通信协议) OSI参考模型：模型过于理想化，未能在因特网上进行广泛推官 TCP/IP参考模型(或TCP/IP协议)：实际上的国际标准 InetAddress类 Internet上的主机有两种方式表示地址： 域名：www.yblog.com IP地址：202.108.35.210 InetAddress类主要表示IP地址，存在两个子类：Inet4Address、Inet6Address InetAddress类对象含有一个Internet主机地址的域名和IP地址 域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化为IP地址，这样才能和主机建立连接 InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取InetAddress实例 public static InetAddress getLocalHost() public static InetAddress getByName(String host) host可以为ip地址也可以为域名 InetAddress常用方法 public String getHostAddress()：返回IP地址字符串 public String getHostName()：获取此IP地址的主机名 public boolean isReachable(int timeout)：测试是否可以到达该地址 TCP 使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道 传输前，采用“ 三次握手 方式 ，点对点通信 是 可靠的 TCP 协议进行通信的两个应用进程：客户端、 服务端。 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 UDP 将数据、源、目的封装成数据包，不需要建立连接 每个数据报的大小限制在 64K 内 发送不管对方是否准备好，接收方收到也不确认， 故是不可靠的 可以广播发送 发送数据结束时无需释放资源 ，开销小，速度快 Socket类 利用套接字(Socket) 开发网络应用程序早已被广泛的采用，以至于成为事实上的标准 。 网络上具有唯一标识的 IP 地址和端口号组合在一起才能构成唯一能识别的标识符套接字 。 通信的两端都要有Socket ，是两台机器间通信的端点 。 网络通信其实就是 Socket 间的通信。 Socket 允许程序把网络连接当成一个流， 数据在两个 Socket 间通过 IO 传输。 一般主动发起通信的应用程序属客户端 ，等待通信请求的为服务端。 Socket 分类： 流套接字（ stream socket ）：使用 TCP 提供可依赖的字节流服务 数据报套接字（ datagram socket ）：使用 UDP 提供“尽力而为”的数据报服务 方法 描述 Socket 类的常用构造器 public Socket(InetAddress address,int port) 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 public Socket(String host,int port) 创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket 类的常用方法： public InputStream getInputStream() 返回此套接字的输入流。 可以用于接收网络消息 public OutputStream getOutputStream() 返回此套接字的输出流 。 可以用于发送网络消息 public InetAddress getInetAddress() 此套接字连接到的远程 IP 地址；如果套接字是未连接的 则返回 null。 public InetAddress getLocalAddress() 获取套接字绑定的本地地址 。 即本端的 IP 地址 public int getPort() 此套接字连接到的远程端口号；如果尚未连接套接字 则返回 0。 public int getLocalPort() 返回此套接字绑定到的本地端口 。 如果尚未绑定套接字则返回 1。 即本端的端口号。 public void close() 关闭此套接字。 套接字被关闭后便不可在以后的网络连接中使用即无法重新连接或重新绑定。 需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 public void shutdownInput() 如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容则流将返回 EOF 文件结束符。 即不能在从此套接字的输入流中接收任何数据。 public void shutdownOutput() 禁用此套接字的输出流 。 对于 TCP 套接字 任何以前写入的数据都将被发送并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。 TCP网络编程 客户端 创建 Socket 根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 客户端程序可以使用 Socket 类创建对象创建的同时会自动向服务器方发起连接 。 Socket的构造器是 Socket(String host,int port)throws UnknownHostException,IOException ：向服务器(域名是host。端口号为 port) 发起 TCP 连接，若成功，则创建 Socket 对象，否则抛出异常。 Socket(InetAddress address,int port)throws IOException 根据 InetAddress 对象所表示的IP 地址以及端口号 port 发起连接。 客户端建立 socketAtClient 对象的过程就是向服务器发出套接字连接请求 打开连接到 Socket 的输入出流： 使用 getInputStream方法获得输入流，使用getOutputStream 方法获得输出流，进行数据传输 按照一定的协议对 Socket 进行读 写操作： 通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。 关闭 Socket 断开客户端到服务器的连接，释放线路 Socket s = new Socket( &quot;192.168.40.165&quot;, 9999); OutputStream out = s.getOutputStream(); out.write(&quot;hello&quot;.getBytes()); s.close(); 服务器端 调用 ServerSocket(int port) 创建一个服务器端套接字，并绑定到指定端口上 。用于监听客户端的请求。 ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说， 服务器必须事先建立一个等待客户请求建立套接字连接的 ServerSocket 对象。 所谓“接收”客户的套接字请求，就是 accept() 方法会返回一个 Socket 对象 调用 accept() 监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象 。 调用 该 Socket 类对象的 getOutputStream () 和 getInputStream 获取输出流和输入流，开始网络数据的发送和接收。 关闭 ServerSocket 和 Socket 对象： 客户端访问结束，关闭通信套接字 。 ServerSocket ss = new ServerSocket(9999); Socket s = ss.accept(); InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int num = in.read(buf); String str = new String(buf,0,num); System.out.println(s.getInetAddress().toString()+&quot;:&quot;+str); s.close(); ss.close(); UDP网络编程 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP 数据报通过数据报套接字 DatagramSocket 发送和接收， 系统不保证UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。 DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的 IP地址和端口号以及接收端的 IP 地址和端口号。 UDP 协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。 如同发快递包裹一样。 DatagramSocket常用方法 方法 描述 public DatagramSocket(int port) 创建数据报套接字并将其绑定到本地主机上的指定端口。 套接字将被绑定到通配符地址 IP 地址由内核来选择。 public DatagramSocket(int port,InetAddress laddr) 创建数据报套接字将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间(包括两者)。 如果 IP 地址为 0.0.0.0 套接字将被绑定到通配符地址 IP 地址由内核选择。 public void close() 关闭此数据报套接字。 public void send(DatagramPacket p) 从此套接字发送数据报包 。 DatagramPacket 包含的信息指示：将要发送的数据 、 其长度 、 远程主机的 IP 地址和远程主机的端口号。 public void receive(DatagramPacket p) 从此套接字接收数据报包。当此方法返回时, DatagramPacket的缓冲区填充了接收的数据。 数据报包也包含发送方的 IP 地址和发送方机器上的端口号 。 此方法在接收到数据报前一直阻塞。 数据报包对象的 length 字段包含所接收信息的长度 。 如果信息比包的长度长该信息将被截短。 public InetAddress getLocalAddress() 获取套接字绑定的本地地址。 public int getLocalPort() 返回此套接字绑定的本地主机上的端口号。 public InetAddress getInetAddress() 返回此套接字连接的地址。 如果套接字未连接 则返回 null。 public int getPort() 返回此套接字的端口 。 如果套接字未连接 则返回 -1 DatagramPacket常用方法 方法 描述 public DatagramPacket(byte[] buf,int length) 构造 DatagramPacket 用来接收长度为 length 的数据包。 length参数必须小于等于 buf.length。 public DatagramPacket(byte[] buf,int offset,int length,InetAddress address,int port) 构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。 length参数必须小于等于 buf.length。 public InetAddress getAddress() 返回某台机器的 IP 地址此数据报将要发往该机器或者是从该机器接收到的。 public int getPort() 返回某台远程主机的端口号此数据报将要发往该主机或者是从该主机接收到的。 public byte[] getData() 返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始 持续 length 长度。 public int getLength() 返回将要发送或接收到的数据的长度。 UDP网络通信流程 DatagramSocket 与 DatagramPacket 建立发送端，接收端(发送端与接受端是两个独立的运行程序) 建立数据包 调用 Socket 的发送 、 接收方法 关闭 Socket 发送端 DatagramSocket ds = null; try{ ds = new DatagramSocket(); byte[] by = &quot;hello,atguigu.com&quot;.getBytes(); DatagramPacket dp = new DatagramPacket( by, 0, by.length, InetAddress.getByName (&quot;127.0.0.1&quot;), 10000); ds.send(dp); }catch (Exception e ){ e.printStackTrace(); }finally{ if(ds != null){ ds.close(); } } 接收端 DatagramSocket ds = null try{ ds = new DatagramSocket(10000); byte[] by = new byte[1024]; DatagramPacket dp = new DatagramPacket(by , by.length); ds.receive(dp); String str = new String(dp.getData(), 0, dp.getLength()); System.out.println(str + &quot;----&quot; + dp.getAddress()); }catch (Exception e ){ e.printStackTrace(); }finally{ if(ds != null){ ds.close(); } } URL编程 URL(Uniform Resource Locator)：统一资源定位符，它表示Internet上某一资源的地址 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源 通过URL我们可以访问Internet上的各种网络资源，比如最常见的www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。 URL组成 &lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#&lt;片段名&gt;?&lt;参数列表&gt; 片段名：即锚点，例如看小说，直接定位到章节 参数列表格式：参数名=参数值&amp;参数名=参数值... 为了表示 URL， java.net 中实现了类 URL 。我们可以通过下面的构造器来初始化一个 URL 对象： public URL (String spec )：通过 一个表示 URL 地址的字符串可以构造一个 URL 对象。例如 URL url = new URL(&quot; http://www.atguigu.com/&quot;); public URL(URL context, String spec )：通过基 URL 和相对 URL 构造 一 个 URL 对象。例如 URL downloadUrl = new URL(url , &quot;download.html&quot;) public URL(String protocol, String host, String file); 例如new URL(&quot;http&quot;, &quot;www.atguigu.com &quot;, “download. html&quot;) public URL(String protocol, String host, int port, String file); 例如 : URL gamelan = new URL (&quot;http&quot;, www.atguigu.com &quot;, 80, &quot;download.html&quot;); URL 类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。 常用方法 一 个 URL 对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性： 方法 描述 public String getProtocol ( ) 获取该URL的协议名 public String getHost ( ) 获取该URL的主机名 public String getPort ( ) 获取该URL的端口号 public String getPath ( ) 获取该URL的文件路径 public String getFile ( ) 获取该URL的文件名 public String getQuery ( ) 获取该URL的查询名 针对HTTP协议的URL Connection类 URL的方法openStream()：能从网络上读取数据 若希望输出数据，例如向服务器端的CGI（公共网关接口 Common GatewayInterface 的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与 URL 建立连接，然后才能对其进行读写，此时需要使用URLConnection 。 URLConnection：表示到 URL 所引用的远程对象的连接。当与一个 URL 建立连接时，首先要在一个 URL 对象上通过方法 openConnection () 生成对应的 URLConnection对象。如果连接过程失败，将产生 IOException . URL netchinaren = new URL (&quot;http://www.atguigu.com/index.shtml&quot;); URLConnectonn u = netchinaren.openConnection ( ); 通过 URLConnection 对象获取的输入流和输出流，即可以与现有的 CGI程序进行交互。 public Object getContent() throws IOException public int getContentLength() public String getContentType () public long getDate () public long getLastModified () public InputStream getInputStream ( )throws IOException public OutputSteram getOutputStream ( )throws IOException 类 URL 和 URLConnection 提供了最高级网络应用。 URL 的网络资源的位置来同一表示Internet 上各种网络资源。通过 URL 对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。 URI、URL、URN区别 URI，是 uniform resource identifier，统一资源标识符用来唯一的标识一个资源。而 URL 是 uniform resource locator ，统一资源定位符 ，它是一种具体的URI ，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。而 URN uniform resource name，统一资源命名，是通过名字来标识资源比如 mailto:java-net@java.sun.com。也就是说， URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是具体的资源标识的方式。 URL和 URN 都是一种 URI 。在Java 的 URI 中，一个 URI 实例可以代表绝对的，也可以是相对的，只要它符合 URI 的语法规则。而 URL 类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 ","link":"https://yeyuan1107.github.io/post/java-wang-luo-bian-cheng/"},{"title":"JavaIO流","content":" File类的使用 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。File类的一个对象，代表一个文件或一个文件目录(文件夹)，该类可以新建、删除、重命名文件和目录，但不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录File对象可以作为参数传递给流的构造器 //创建一个File对象时，如果硬盘中有一个真实的文件或目录存在时，创建File对象时，各个属性会显示赋值。否则，出了指定的目录和路径之外，其他的属性都是取成员变量的默认值 //以pathname为路径创建创建File对象，可以是绝对路径或相对路径，如果为相对路径则默认的当前路径在系统属性user.dir中存储 //绝对路径：是一个固定的路径，从盘符开始 //相对路径：是相对于某个位置开始，IDEA中如果为单元测试，相对路径为当前module下，否则为project下 //分隔符：Windox和Dos用&quot;\\&quot;,UNIX和URL用&quot;/&quot;,跨平台使用File.separator作为分隔符 public File(String pathname) //windows和Dos File file1 = new File(&quot;d:\\\\atguigu\\\\info.txt&quot;); //通用 File file2 = new File(&quot;d:&quot;+ File.separator + &quot;atguigu&quot;+ File.separator + &quot;info.txt&quot;); //UNIX和URL File file3 = new File(&quot;d:/atguigu/info.txt&quot;); //以parent为父路径，child为子路径创建FIle对象 public File(String parent, String child) //根据一个父File对象和子文件路径创建File对象 public File(File parent， String child) 常用方法 方法 描述 File 类的获取功能 public String getAbsolutePath() 获取绝对路径 public String getPath() 获取路径 public String getName() 获取名称 public String getParent() 获取上层文件目录路径。 若无返回 null public long length() 获取文件长度即：字节数。不能获取目录的长度。 public long lastModified() 获取最后一次的修改时间毫秒值 public String[] list 获取指定目录下的所有文件或者文件目录的名称数组 public File[] listFiles 获取指定目录下的所有文件或者文件目录的File数组 File 类的重命名功能 public boolean renameTo(File dest) 把文件重命名为指定的文件路径 File 类的判断功能 public boolean isDirectory() 判断是否是文件目录 public boolean isFile() 判断是否是文件 public boolean exists() 判断是否存在 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 File 类的创建功能 public boolean createNewFile() 创建文件。 若文件存在则不创建返回false public boolean mkdir() 创建文件目录。 如果此文件目录存在就不创建了。如果此文件目录的上层目录不存在也不创建。 public boolean mkdirs() 创建文件目录。如果上层文件目录不存在一并创建 注意事项：如果你创建文件或者文件目录没有写盘符路径那么默认在项目路径下。 File 类的删除功能 public boolean delete() 删除文件或者文件夹 删除注意事项：Java中的删除不走回收站 。要删除一个文件目录请注意该文件目录内不能包含文件或者文件目录 IO流原理及流的分类 I/O 是 Input/Output 的缩写， I/O 技术是非常实用的技术， 用于处理设备之间的数据传输 。 如读/写文件，网络通讯等。 Java 程序中，对于数据的输入 输出操作 以 “流(stream)“ 的方式进行。 java.io 包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 输入：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中 输出：将程序(内存)数据输出到外部设备中(磁盘、光盘等存储设备中) 流的分类 按照操作数据单位不同氛围：字节流(8bit)，字符流(16bit) 按数据流的流向不同氛围：输入流，输出流 按流的角色不同分为：节点流(作用在文件上(文件流FileInputStream等))，处理流(作用在已有流的基础之上(缓冲流，转换流)) Java的IO流共设计40多个类，实际上非常规则，都是从如下4个抽象基类派生的由这四个类派生出来的子类名称都是以其父类名作为子类名后缀 抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 字符流 不能使用字符流来处理(图片，视频)数据 Reader 方法 描述 int read() 读取单个字符。作为整数读取的字符范围在0到65535之间(0x0000 - 0xffff)2个字节的 Unicode码如果已到达流的末尾则返回-1 int read(char[] cbuf) 将字符读入数组。如果已到达流的末尾则返回-1。否则返回本次读取的字符数。 int read(char[] cbuf,int off,int len) 将字符读入数组的某一部分。 存到数组cbuf中从off处开始存储最多读len个字符。如果已到达流的末尾则返回-1。 否则返回本次读取的字符数。 public void close() throws IOException 关闭此输入流并释放与该流关联的所有系统资源。 //1. File的实例化，读入文件一定要存在，否则报异常 File file = new File(String pathname); //2. FileReader的实例化 FileReader fileReader = new FileReader(File file); //3. 读入的操作 fileReader.read(); //4. 资源的关闭，应当放到finally中 fileReader.close() Writer 方法 描述 void write(int c) 写入单个字符。要写入的字符包含在给定整数值的16个低位中，16高位被忽略。即写入0到65535之间的Unicode码。 void write(char[] cbuf) 写入字符数组。 void write(char[] cbuf,int off,int len) 写入字符数组的某一部分。从 off 开始写入len个字符 void write(String str) 写入字符串。 void write(String str,int off,int len) 写入字符串的某一部分。 void flush() 刷新该流的缓冲则立即将它们写入预期目标。 public void close() throws IOException 关闭此输出流并释放与该流关联的所有系统资源。 //1. File的实例化，输出操作，文件不一定要存在 //文件不存在，在输出过程中自动创建此文件 //文件存在根据FileWriter构造器的参数： //false：覆盖原文件 //true：不会对原文件覆盖，而是在原文件追加内容 File file = new File(String pathname); //2. FileReader的实例化 FileWriter fileWriter = new FileWriter(File file); //3. 读入的操作 fileWriter.write(); //4. 资源的关闭，应当放到finally中 fileWriter.close() 字节流 文本文件(.txt, .java, .c, .cpp)用字符流 非文本文件(.jpg, .mp3, .mp4, .avi, .doc, .ppt)用字节流 InputStream 方法 描述 int read() 从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节则返回值-1。 int read(byte[] b) 从此输入流中将最多b.length个字节的数据读入一个 byte 数组中。 如果因为已经到达流末尾而没有可用的字节 则返回值-1 。 否则以整数形式返回实际读取的字节数。 int read(byte[] b, int off,int len) 将输入流中最多len个数据字节读入byte数组。尝试读取len个字节但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节则返回值-1。 public void close() throws IOException 关闭此输入流并释放与该流关联的所有系统资源。 //1. File的实例化，读入文件一定要存在，否则报异常 File file = new File(String pathname); //2. FileInputStream的实例化 FileInputStream fileInputStream = new FileInputStream(File file); //3. 读入的操作 fileInputStream.read(); //4. 资源的关闭，应当放到finally中 fileInputStream.close() OutputStream 方法 描述 void write(int b) 将指定的字节写入此输出流。write的常规协定：向输出流写入一个字节 。 要写入的字节是参数 b 的八个低位。 b的24个高位将被忽略。 即写入 0-255 范围的。 void write(byte[] b) 将b.length 个字节从指定的 byte 数组写入此输出流。 write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同 void write(byte[] b,int off,int len) 将指定byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 public void flush()throws IOException 刷新此输出流并强制写出所有缓冲的输出字节 调用此方法指示应将这些字节立即写入它们预期的目标。 public void close() throws IOException 关闭此输出流并释放与该流关联的所有系统资源。 //1. File的实例化，输出操作，文件不一定要存在 //文件不存在，在输出过程中自动创建此文件 //文件存在根据FileWriter构造器的参数： //false：覆盖原文件 //true：不会对原文件覆盖，而是在原文件追加内容 File file = new File(String pathname); //2. FileReader的实例化 FileOutputStream fileOutputStream = new FileOutputStream(File file); //3. 读入的操作 fileOutputStream.write(); //4. 资源的关闭，应当放到finally中 fileOutputStream.close() 节点流(或文件流) 读取示例 FileReader fr = null try{ fr = new FileReader(new File(&quot;test.txt&quot;)); char[] buf = new char[1024]; int len; while((len = fr.read(buf)) != 1) { System.out.print(new String(buf, 0, len); } }catch (IOException e){ System.out.println(&quot;read Exception :&quot;+ e.getMessage()); }finally{ if(fr!= null){ try{ fr.close(); }catch (IOException e){ System.out.println(&quot;close Exception:&quot;+ e.getMessage()); } } } 输出示例 FileWriter fw = null; try{ fw = new FileWriter(new File(&quot;Test.txt&quot;)); fw.write(&quot;atguigu songhongkang&quot;); }catch (IOException e ) e.printStackTrace() }finally{ if(fw != null){ try{ fw.close(); }catch (IOException e){ e.printStackTrace(); } } } 注意 定义文件路径时，注意：可以用&quot;/&quot;或者&quot;&quot;。 在写入一个文件时，如果使用构造器 FileOutputStream(file) ，则目录下有同名文件将被覆盖。如果使用构造器 FileOutputStream(file,true) ，则目录下的同名文件不会被覆盖在文件内容末尾追加内容。 在读取文件时，必须保证该文件已存在，否则报异常 。 字节流操作字节，比如：.mp3 , .avi , .rmvb, .mp4, .jpg, .doc, .ppt 字符流操作字符，只能操作普通文本文件。 最常见的文本文件：.txt, .java, .c, .cpp等语言的源代码。 尤其注意 .doc, .excel, .ppt这些不是文本文件。 处理流 缓冲流 为了提高数据读写的速度，JavaAPI提供了带缓冲功能的流泪，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8kb)的缓冲区。 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以分为 BufferedInputStream 和 BufferedOutputStream BufferedReader 和 BufferedWriter 示例 BufferedReader br = null BufferedWriter bw = null try{ //1. 选文件 //2. 创建缓冲流对象：它是处理流，是对节点流的包装 br = new BufferedReader( new FileReader(&quot;d:\\\\IOTest\\\\source.txt&quot;)); bw = new BufferedWriter( new FileWriter(&quot;d:\\\\IOTest\\\\dest.txt&quot;)) String str; //2. 读写数据 //readLine()一次读取字符文本文件的一行字符,返回String，如果为null说明到了末尾 while((str = br.readLine()) != null ){ bw.write(str); // 一次写入一行字符串 bw.newLine(); // 写入行分隔符 } bw.flush (); // 刷新缓冲区 }catch (IOException e ){ e.printStackTrace(); }finally{ //4. 关闭IO流对象 try{ if(bw != null){ bw.close (); //关闭过滤流时会自动关闭它所包装的底层节点流 } }catch (IOException e){ e.printStackTrace(); } try{ if(br != null){ br.close(); } }catch (IOException e){ e.printStackTrace(); } } 转换流(属于字符流) 转换流提供了再字节流和字符流之间的转换 JavaAPI提供了两个转换流： InputStreamReader：将InputStream转换为Reader OutputStreamWriter：将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能 编码：字符串 -&gt; 字节数组 解码：字节数组 -&gt; 字符串 转换流的编码应用 可以讲字符按照指定编码格式存储 可以对文本数据按照指定编码格式来解读 指定编码表的动作由构造器完成 InputStreamReader 实现将字节的输入流按照指定字符集转换为字符的输入流 需要和InputStream“套接” 构造器： public InputStreamReader(InputStream in) public InputStreamReader(InputStream in, String charsetName) OutputStreamWriter 实现将字符的输出流按照字符集转换为字节的输出流 需要和OutputStream“套接” 构造器： public OutputStreamWriter(OutputStream out) public OutputStreamWriter(OutputStream out, String charsetName) public void testMyInput() throws Exception { FileInputStream fis = new FileInputStream(&quot;dbcp.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;dbcp5.txt&quot;); InputStreamReader isr = new InputStreamReader(fis,&quot;GBK&quot;); OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;GBK&quot;); BufferedReader br = new BufferedReader(isr); BufferedWriter bw = new BufferedWriter(osw); String str = null while((str = br.readLine())!= null){ bw.write(str); bw.newLine(); bw.flush() } bw.close(); br.close(); } 标准输入、输出流(了解) System.in 和 System.out 分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in 的类型是 InputStream System.out 的类型是 PrintStream，其是 OutputStream的子类FilterOutputStream的子类 重定向：通过 System类的 setIn，setOut 方法对默认设备进行改变。 public static void setIn (InputStream in) public static void setOut (PrintStream out) System.out.println(&quot;请输入信息(退出输入e或 exit):&quot;) //把标准输入流键盘输入这个字节流包装成字符流再包装成缓冲流 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String s = null; try{ while((s = br .readLine()) != null ) {//读取用户输入的一行数据 --&gt; 阻塞程序 if((&quot; e&quot;. s ) || &quot; exit&quot;. s )){ System.out.println(&quot;安全退出&quot;); break; } //将读取到的整行字符串转成大写输出 System.out .println (&quot;--&gt;:&quot;+ s.toUpperCase()); System.out.println(&quot;继续输入信息&quot;); } }catch (IOException e){ e.printStackTrace(); }finally{ try{ if(br != null){ br.close(); // 关闭过滤流时 会自动关闭它包装的底层节点流 } }catch (IOException e){ e.printStackTrace(); } } 打印流(了解) 实现将基本数据类型的数据格式转化为字符串输出打印流： PrintStream PrintWriter 提供了一系列冲在的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream打印的所有字符都适用平台默认的字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类 System.out返回的是PrintStream的实例 PrintStream ps = null; try{ FileOutputStream fos = new FileOutputStream(new File( &quot;d:\\\\IO\\\\text.txt&quot; )); //创建打印输出流 设置为自动刷新模式写入换行符或字节&quot;\\n&quot;时都会刷新输出缓冲区 ps = new PrintStream(fos,true) if(ps != null) {// 把标准输出流 控制台输出 改成文件 System.setOut(ps); } for(int i = 0; i &lt;= 255; i ++) { // 输出 ASCII 字符 System.out.print((char) i); if(i % 50 == 0) { // 每 50 个数据一行 System.out.println (); // 换行 } } }catch (FileNotFoundException e ){ e.printStackTrace(); }finally{ if(ps != null){ ps.close(); } } 数据流(了解) 为了方便地操作 Java 语言的 基本 数据类型和 String 的 数据，可以使用数据流。 数据流有两个类：(用于读取和写出基本数据类型、 String 类的数据） DataInputStream 和 DataOutputStream 分别“套接”在 InputStream 和 OutputStream 子类的流上 DataInputStream 中的方法 boolean readBoolean() byte readByte() char readChar() float readFloat() double readDouble() short readShort() long readLong() int readInt() String readUTF() void readFully (byte[] b); DataOutputStream 中的方法 将上述的方法的 read 改为相应的 write 即可。 DataOutputStream dos = null try{ // 创建连接到指定文件的数据输出流对象 dos = new DataOutputStream(new FileOutputStream(&quot;destData.dat&quot;)); dos.writeUTF(&quot;我爱北京天安门&quot;); // 写 UTF 字符串 dos.writeBoolean(false); // 写入布尔值 dos.writeLong(1234567890L ); // 写入长整数 System.out.println(&quot;写文件成功&quot;) }catch (IOException e ){ e.printStackTrace(); }finally { // 关闭流对象 try{ if(dos != null){ //关闭过滤流时 会自动关闭它包装的底层节点流 dos.close() } }catch (IOException e ){ e.printStackTrace(); } } DataInputStream dis = null try{ dis = new DataInputStream( new FileInputStream(&quot;destData.dat&quot;)); String info = dis.readUTF(); boolean flag = dis.readBoolean(); long time = dis.readLong(); System.out.println(info); System.out.println(flag); System.out.println(time); }catch (Exception e ){ e.printStackTrace(); }finally{ if(dis != null){ try{ dis.close(); }catch (IOException e ){ e.printStackTrace(); } } } 对象流 ObjectInputStream和ObjectOutputStream 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java的对象写入到数据源中，也能把对象从数据源中还原回来 序列化：用ObjectOutputStream类保存基本数据类型或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 对象的序列化 对象序列化机制 允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点 。 当 其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象 序列化的好处在于可将任何实现了 Serializable 接口的对象转化为字节数据使其在保存和传输时可被还原 序列化是 RMI (Remote Method Invoke 远程方法调用) 过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出 NotSerializableException 异常：Serializable、Externalizable 凡是实现 Serializable 接口的类都有一个表示序列化版本标识符的静态变量： private static final long serialVersionUID; serialVersionUID 用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。 如果 类没有显示定义这个静态常量 ，它的值是 Java 运行时环境根据类的内部细节自动生成的 。 若类的实例变量做了修改 serialVersionUID 可能发生变化。 故建议，显式声明。 简单来说， Java 的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时， JVM 会把传来的字节流中的serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 (InvalidCastException) 若某个类实现了 Serializable 接口，该类的对象就是可序列化的： 创建一个 ObjectOutputStream 调用 ObjectOutputStream 对象的 writeObject( 对象 ) 方法输出可序列化对象 注意写出一次，操作 flush() 一次 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream (&quot;data.txt&quot;)); Person p = new Person( &quot;韩梅梅&quot;, 18, &quot;中华大街&quot;, new Pet()); oos.writeObject(p); oos.flush(); oos.close(); 反序列化 创建一个 ObjectInputStream 调用 readObject () 方法读取流中的对象 强调： 如果某个 类 的 属性 不是 基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field的类也不能序列化 随机文件存取 RandomAccessFile声明在java.io包下，但直接继承与java.lang.Object类。并且它实现了DataInput 、 DataOutput这两个接口，也就意味着这个类既可以读也可以写 RandomAccessFile类支持&quot;随机访问&quot;的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向一存在的文件后追加内容 RandomAccessFile对象包含一个记录指针，用以标记当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针 long getFilePointer()：获取文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到pos位置 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建RandomAccessfile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式 r：以只读方式打开 rw：可以读取也可以写入 rwd：可以读取和写入，同步文件内容的更新 rws：可以读取和写入，同步文件内容和原数据的更新 如果模式为只读r。则不会创建文件，而是回去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为rw。如果文件不存在则会去创建文件，如果存在则不会创建。如果写入时，文件存在则将文件内容从指针位置覆盖，而不是将文件覆盖 //读取文件内容 RandomAccessFile raf = new RandomAccessFile(“test.txt”, rw); raf.seek(5) byte [] b = new byte[1024]; int off = 0; int len = 5; raf.read(b, off, len) String str = new String(b, 0, len) System.out.println(str); raf.close(); //写入文件内容 RandomAccessFile raf = new RandomAccessFile (&quot;test.txt&quot;, rw); raf.seek(5); //先读出来 String temp = raf.readLine(); raf.seek(5); raf.write(&quot;xyz&quot;.getBytes()); raf.write(temp.getBytes); raf.close() RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;, &quot;rw&quot;); raf1.seek(5); //方式一： //StringBuilder info = new StringBuilder((int) file.length()); //byte[] buffer = new byte[10]; //int len; //while((len = raf1.read(buffer)) != -1){ //info += new String(buffer,0,len); //info.append(new String(buffer,0,len)); //} //方式二： ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[10]; int len; while((len = raf1.read(buffer)) != -1){ baos.write(buffer, 0, len); } raf1.seek(5); raf1.write(&quot;xyz&quot;.getBytes()); raf1.write(baos.toString().getBytes()); baos.close(); raf1.close(); 流的应用小结 流是用来处理数据的。 处理数据时，一定要先明确数据源 ，与数据目的地 数据源可以是文件，可以是键盘。 数据目的地可以是文件、显示器或者其他设备。 而流只是在帮助数据进行传输 并对传输的数据进行处理，比如过滤处理、转换处理等。 NIO.2中Path、Paths、Files类的使用 Java NIO (New IO Non Blocking IO) 是 从 Java 1.4 版本开始引入的一套新的IO API，可以替代标准的 Java IO API。 NIO 与原来的 IO 有同样的作用和目的，但是使用的方式完全不同， NIO 支持面向缓冲区的 (IO 是面向流的) 、基于通道的 IO 操作。NIO将以更加高效的方式进行文件的读写操作。 Java API 中提供了两套 NIO 一套是针对标准输入输出 NIO 另一套就是网络编程 NIO 。 java.nio.channels.Channel FileChannel：处理本地文件 SocketChannel：TCP网络编程的客户端的 Channel ServerSocketChannel：TCP 网络编程的服务器端的 Channel DatagramChannel：UDP 网络编程中发送端和接收端的 Channel NIO.2 随着 JDK 7 的发布， Java 对 NIO 进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2 。因为 NIO 提供的一些功能， NIO 已经成为文件处理中越来越重要的部分。 Path、Paths、Files类 早期 的 Java 只提供了一个 File 类来访问文件系统，但 File 类的功能比较有限，所提供的方法性能也不高。而且， 大多数方法在出错时仅返回失败，并不会提供异常信息。 NIO. 2 为了弥补这种不足，引入了 Path 接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。 Path 可以看成是 File 类的升级版本，实际引用的资源也可以不存在。 在以前 IO 操作都是这样写的 import java.io.File; File file = new File(&quot;index.html&quot;); 但在 Java7 中，我们可以这样写： import java.nio.file.Path; import java.nio.file.Paths; Path path = Paths.get(&quot;index.html&quot;); 同时， NIO.2 在 java.nio.file 包下还 提供了 Files 、 Paths 工具类， Files 包含了大量静态的工具方法来操作文件； Paths 则包含了两个返回 Path 的静态工厂方法。 Paths 类提供的静态 get() 方法用来获取 Path 对象： static Path get(String first, String … more) : 用于将多个字符串串连成路径 static Path get(URI uri): 返回指定 uri 对应的 Path 路径 ","link":"https://yeyuan1107.github.io/post/javaio-liu/"},{"title":"Java泛型","content":" 简介 所谓泛型，就是允许在定义类，接口时，通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型，这个类型将在使用时。例如，继承或实现这个接口，用这个类型声明变量，创建对象时确定(即传入实际的类型参数，也称为类型实参)泛型解决的问题 任何类型都可以添加到集合中导致类型不安全 读取出来的对象需要强制转换，可能导致ClassCastException 注意：泛型中类型不能是基本参数类型，编译时就会进行类型检查，保证数据安全，且避免了强转操作 在集合中使用泛型 //迭代器也可以有泛型，返回值类型为泛型类型 Iterator&lt;T&gt; iterator = xxx.iterator(); //comparable及comparator也有泛型 /* 1. 集合接口或集合类在JDK5.0时都修改为带泛型的结构 2. 在实例化集合类时可以指明具体的泛型类型，内部结构使用到类的泛型的位置都指定为实例化时的类型 3. 泛型的类必须是类，不能是基本数据类型 4. 如果实例化时未指明类型，默认为Object 5. JDK7之后构造器的泛型可以省略 */ 自定义泛型结构 泛型的声明 如interface List&lt;T&gt;，T代表类型，任何字母都可以 泛型的实例化 一定要在类名后看指定类型参数的值如List&lt;String&gt; list类型参数只能是类，不能使用基本数据类型填充 自定义泛型类、泛型接口 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内 。比如：&lt;E1,E2,E3&gt; 泛型类的构造器如下 public GenericClass(){} 。而下面是错误的public GenericClass(){} 实例化后，操作原来泛型位置的结构必须 与指定的泛型类型一致 。 泛型不同的引用不能相互赋值。尽管在编译时 ArrayList 和 ArrayList 是两种类型，但是，在运行时只有一个 ArrayList 被加载到 JVM 中 。 泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理，但不等价于 Object 。 经验： 泛型要使用一路都用。要不用，一路都不要用。 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象 。 jdk1.7，泛型的简化 操作 ArrayList flist = new ArrayList&lt;&gt;() 泛型的指定中不能使用基本数据类型，可以使用包装类替换。 在类接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型 。但在静态方法中不能使用类的泛型。 异常类不能是泛型的 不能使用 new E[] 。但是可以E[] elements = (E[])new Object[capacity];参考：ArrayList 源码中声明： Object[] elementData 而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 没有类型 擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型 class Father&lt;T1, T2&gt; { } //子类不保留父类的泛型 // 1)没有类型 擦除 class Son1 extends Father { // 等价于 class Son extends Father&lt;Object,Object&gt;{} } // 2) 具体类型 class Son2 extends Father&lt;Integer, String&gt; { } //子类保留父类的泛型 // 1)全部保留 class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; { } // 2)部分保留 class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; { } class Person&lt;T&gt; { // 使用 T 类型定义变量 private T info; //使用 T 类型定义一般方法 public T getInfo() { return info; } public void setInfo(T info ){ this.info = info } //使用 T 类型定义构造器 public Person() { } public Person(T info){ this.info = info } // static的方法中不能声明泛型 //public static void show(T t) { // //} //不能在 try catch 中使用泛型定义 //public void test() { //try { // //} catch (MyException&lt;T&gt; ex) { // //} //} } 自定义泛型方法 方法，也可以泛型化，在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系，泛型方法所属的类是不是泛型类与该方法是不是泛型方法没有关系 权限修饰符 &lt;泛型&gt; 返回类型 方法名(形参列表) 抛出的异常{} //可以是静态方法 权限修饰符 static &lt;泛型&gt; 返回类型 方法名(形参列表) 抛出的异常{} 代码示例 public static &lt;T&gt; void fromArrayToCollection(T[] a , Collection&lt;T&gt; c ) for(T o : a ){ c.add(o); } } public static void main(String[] args ){ Object[] ao = new Object[100]; Collection&lt;Object&gt; co = new ArrayList&lt;Object&gt;(); fromArrayToCollection(ao , co); String[] sa = new String[20]; Collection&lt;String&gt; cs = new ArrayList&lt;&gt;(); fromArrayToCollection(sa , cs); Collection&lt;Double&gt; cd = new ArrayList&lt;&gt;(); //下面代码中 T 是 Double 类，但 sa 是 String 类型，编译错误。 //fromArrayToCollection(sa, cd); //下面代码中 T 是 Object 类型， sa 是 String 类型，可以赋值成功。 fromArrayToCollection(sa , co); } class Creature{} class Person extends Creature{} class Man extends Person{} class PersonTest { public static &lt;T extends Person&gt; void test(T t){ System.out.println(t); } public static void main(String[] args){ test(new Person()); test(new Man()); //The method test(T) in the type PersonTest is not //applicable for the arguments (Creature) test(new Creature()); } } 泛型在继承上的体现 如果B是A的一个子类(或子接口)，而G是具有泛型声明的类或接口，但是G并不是G的子类型。但是B与A有子父类关系 通配符的使用 通配符：&quot;?&quot;类A与类B为子父类关系，G与G没有子父类关系，二者的共同父类为G&lt;?&gt; 对于G&lt;?&gt;不能向内部添加除了null之外的数据，因为null是所有类型的成员。我们不知道该对象的元素类型，add方法中有类型参数E作为集合的元素类型。我们传给add的然和参数都必须是一个未知类型的子类，因为我们不知道那是什么类型，所以我们无法传递任何东西进去。 允许读取数据，通过调用get()方法来获得返回值，读取的返回值类型为Object 通配符使用示例 public static void main(String[] args ) List&lt;?&gt; list = null; list = new ArrayList&lt;String&gt;(); list = new ArrayList&lt;Double&gt;(); //list.add(3)编译不通过 list.add(null); List&lt;String&gt; l1 = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); l1.add(&quot;尚硅谷&quot;); l2.add(15); read(l1); read(l2); } public static void read(List&lt;?&gt; list ) for(Object o : list){ System.out.println(o) } } //注意点 1 ：编译错误：不能用在泛型方法声明上，返回值类型前面不能使用 public static &lt;?&gt; void test(ArrayList&lt;?&gt; list){ } //注意点 2 ：编译错误：不能用在泛型类的声明上 class GenericTypeClass&lt;?&gt;{ } //注意点 3 ：编译错误：不能用在创建对象上，右边属于创建集合对象 ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;(); 有限制条件的通配符 &lt; ? extends Number&gt; (无穷小, Number]：只允许泛型为Number及Number子类的引用调用 &lt; ? super Number &gt;[Number, 无穷大)：只允许泛型为Number及Number父类的引用调用 可以写入数据，可以写入Number及Number的子类 &lt; ? extends Comparable&gt;：只允许泛型为实现Comparable接口的实现类引用调用 ","link":"https://yeyuan1107.github.io/post/java-fan-xing/"},{"title":"Java集合","content":" 简介 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。此时的存储，主要指的是内存层面的存储，不涉及持久化的存储 数组的特点 数组初始化以后，长度就固定了 数组声明的类型，就决定了进行元素初始化时的类型 数组存在的弊端 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。无法同时直接获取存储元素的个数 数组存储的数据是有序的、可以重复的。存储数据的特点单一，如果要求存储为无序的不可重复的，则无法满足 集合 集合可以存储数量不等的多个对象，还可用于保存具有映射关系的关联数组 集合框架概述 Java集合可分为Collection和Map两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 Set：元素无序、不可重复的集合 Map接口：双列数据，保存具有映射关系&quot;key-value对&quot;的集合 Collection接口 Collection是List、Set和Queue接口的父接口，该接口里定义的方法即可用于操作Set集合，也可用于操作List和Queue集合 JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。 Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理：从JDK5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型 Collection接口方法 方法 简介 add(Object obj) 将元素obj添加到集合中 addAll(Collection coll) 将coll集合中元素添加到当前集合中 int size() 获取添加的元素个数 void clear() 将集合清空 boolean isEmpty() 判断当前集合是否为空 boolean contains(Object obj) 判断当前集合是否包含obj，是通过元素的equals方法来判断是否是同一个对象 boolean containsAll(Collection c) 也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。判断c中的元素是否都存在于当前集合中 boolean remove(Object obj) 通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 boolean removeAll(Collection coll) 取当前集合与coll的差集 boolean retainAll(Collection c) 把交集的结果存在当前集合中，不影响c boolean equals(Object obj) 判断集合是否相同，有序无序具体情况分析 Object[] toArray() 转成对象数组 int hashCode() 获取当前集合哈希值 iterator() 返回Iterator的实例(迭代器对象)，用于集合遍历 //注意： //将数组转为集合，该方法返回的List集合，既不是ArrayList实例，也不是Vector实例，返回的是一个固定长度的List集合。 Arrays.asList(T...a); //如果传入的参数位基本数据类型的数组则会讲整个数组识别为一个元素 Arrays.asList(new int[]{xxx,xxx}); //应当传入引用数据类型的数组，才会将其识别为多个元素 Arrays.asList(new Integer[]{xxx,xxx}); Arrays.asList(xxx,xxx;) Iterator迭代器接口 Iterator 对象称为迭代器（设计模式的一种），主要用于遍历 Collection 集合中的元素。 GOF 给迭代器模式的定义为：提供一种方法访问一个容器 (container) 对象中各个元素，而又不需暴露该对象的内部细节。 迭代器模式，就是为容器而生。 类似于“公交车上的售票员”、“火车上的乘务员”。 Collection 接口继承了 java.lang.Iterable 接口，该接口有一个 iterator() 方法，那么所有实现了 Collection 接口的集合类都有一个 iterator() 方法，用以返回一个实现了Iterator 接口的对象 。 Iterator 仅用于遍历集合 Iterator 本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。 集合对象每次调用 iterator() 方法都得到一个全新的迭代器对象 ，默认游标都在集合的第一个元素之前 。 //hasNext()是否存在下一个元素 while(iterator.hasNext()){ //next()返回下一个元素 sout(iterator.next()); //remove()删除iterator返回的最后一个元素，一个next()犯法后只能接一个remove()方法，否则会报IllegalStateException异常 iterator.remove(); } Enumeration接口 Iterator迭代器的古老版本hasNext() -&gt; hasMoreElements()next() -&gt; nextElement() foreach循环遍历集合元素 JDK5.0提供了foreach循环迭代访问Collection和数组 遍历操作不需要获取Collection和数组的长度，无需使用索引访问元素 遍历集合的底层调用Iterator完成操作 foreach还可以用来遍历数组 //相当于把要遍历结构中的一个元素赋值给了自定义的元素名称，改变自定义元素名称的内容不会改变原来的集合内容 for(要遍历的元素类型 遍历后自定义元素名称 : 要遍历的结构名称){ 对遍历元素的操作; } List接口 简介 鉴于 Java 中数组用来存储数据的局限性，我们通常使用 List 替代数组 List 集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List 容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API 中 List 接口的实现类常用的有： ArrayList 、 LinkedList 和 Vector 。 都实现了List接口，存储数据特点相同，存储有序的可重复的数据 ArrayList作为List接口的主要实现类，线程不安全，效率高，底层使用Object[]存储 Vector作为List接口的古老实现类，线程安全的，效率低，底层使用Object[]存储 LinkedList底层使用双向链表存储对于频繁插入删除操作效率较ArrayList高 ArrayList源码分析 JDK7中 //底层创建长度为10的Object数组elementData ArrayList list = new ArrayList(); //elementData[0] = new Integer(123) //当此次添加导致elementData容量不够，则扩容，扩大到原来的1.5倍 list.add(123); //开发中常使用new ArrayList(int capacity);在实例化时先定义容量大小 JDK8中 //底层创建长度为0的Object数组elementData ArrayList list = new ArrayList(); //第一次添加元素时创建一个容量为10的数组 //后续添加扩容操作与JDK7 相同 list.add(123); //JDK7中创建类似于单例的饿汉式，而JDK8中类似懒汉式节省内存 LinkedList源码分析 //LinkedList内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。 //同时，定义内部类Node，作为LinkedList中保存数据的基本结构。 //Node除了保存数据，还定义了两个变量： //prev变量记录前一个元素的位置， //next变量记录下一个元素的位置 LinkedList list = new LinkedList(); //将123封装到Node中之后添加到链表尾部 list.add(123); Vector源码分析 与ArrayList类似，创建长度为10的数组，但是扩容为2倍(ArrayList为1.5倍)关系 List接口方法 List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法 。 方法 描述 void add(int index, Object ele) 在index位置插入ele元素 boolean addAll(int index, Collection eles) 从 index 位置开始将 eles 中的所有元素添加进来 Object get( int index) 获取指定 index 位置的元素 int indexOf (Object obj) 返回 obj 在集合中首次出现的位置 int lastIndexOf (Object obj) 返回 obj 在当前集合中末次出现的位置 Object remove( int index) 移除指定 index 位置的元素，并返回此元素 Object set( int index, Object ele) 设置指定 index 位置的元素为 ele List subList(int fromIndex , int toIndex) 返回从 fromIndex 到 toIndex位置的子集合左闭右开 常用方法 增：add(Object obj)删：remove(int index)/remove(Object obj)改：set(int index, Object obj)查：get(int index)插：add(int index, Object obj)长度：size()遍历：1. Iterator 2. foreach 3. 普通for循环 LinkedList特有方法 void addFirst (Object obj)void addLast (Object obj)Object getFirst()Object getLast()Object removeFirst()Object removeLast() Vector特有方法 void addElement (Object obj)void insertElementAt (Object obj,int index)void setElementAt (Object obj,int index)void removeElement (Object obj)void removeAllElements() 请问ArrayList/LinkedList/Vector 的异同谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别 ArrayList和LinkedList的异同二者都线程不安全，相对线程安全的Vector ，执行效率高。此外，ArrayList 是实现了基于动态数组的数据结构， LinkedList 基于链表的数据结构。对于随机访问 get 和 set，ArrayList 觉得优于 LinkedList，因为 LinkedList 要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为 ArrayList 要移动数据。 ArrayList 和 Vector 的区别Vector和 ArrayList 几乎是完全相同的唯一的区别在于 Vector 是同步类 ( synchronized)，属于强同步类。因此开销就比 ArrayList 要大，访问要慢。正常情况下 大多数的 Java 程序员使用ArrayList 而不是 Vector, 因为同步完全可以由程序员自己来控制。 Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 Vector 还有一个子 类 Stack。 Set接口 Set接口是Collection的子接口，set接口没有提供额外的方法 Set集合不允许包含下同的元素，如果试把两个相同的元素加入到同一个Set集合中，则添加操作失败 Set判断两个对象是否相同不是使用==运算符，而是根据equals()方法 Set接口中没有定义新的方法 HashSet：主要实现类，线程不安全，可以存储null LinkedHashSet：HashSet的子类，遍历其内部数据时可以按照添加顺序遍历 TreeSet：可以按照添加元素的指定属性进行排序 特点 无序性：不等于随机性(多次遍历的结果，顺序是相同的)，存储的数据在底层数组中并非按照数组索引顺序添加而是按照数据哈希值添加 不可重复性：保证添加的元素按照equals()判断时不能返回true，即相同的元素职能添加一个 HashSet HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 HashSet的底层为HashMap，每个entry中的key不同，但是value设定为同一个值 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能 。 HashSet 具有以下特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode () 方法比较相等，并且两个对象的 equals() 方法返回值也相等 。 对于存放在 Set 容器中的对象，对应的类一定要重写 equals() 和 hashCode(Object obj) 方法，以实现对象相等规则 。即：&quot;相等的对象必须具有相等的散列码&quot;。 向 HashSet 中添加元素的过程： 当向 HashSet 集合中存入一个元素时 HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值 然后根据 hashCode 值通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。 （这个散列函数会与底层数组的长度相计算得到在数组中的下标 并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好） 如果两个元素的 hashCode() 值相等 会再继续调用 equals() 方法 如果 equals() 方法结果为 true添加失败如果为false 那么会保存该元素 但是该数组的位置已经有元素了那么会通过链表的方式继续链接。(JDK7中新元素放在数组中并作为头节点指向旧元素，JDK8中旧元素仍放在数组中作为头节点同时链表尾部指向新元素。七上八下) 重写hashCode()方法的基本原则 在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值 当两个对象的equals()方法比较返回true时，这连个对象的hashCode()方法的返回值也应当相等 对象中用作equals()方法比较的Field，都应该用来计算hashCode值 修改equals方法时一定要同时修改hashCode方法 如果两个元素的 equals() 方法返回 true ，但它们的 hashCode () 返回值不相等， hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 底层也是数组，初始容量为16，当如果使用率超过0.75，就会扩大容量为原来的两倍 底层为HashMap LinkedHashSet LinkedHashSet时HashSet的子类 LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这是的元素看起来是以插入顺序保存的 LinkedHashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能 LinkedHashSet不允许集合元素重复 TreeSet TreeSet 是 SortedSet 接口的实现类， TreeSet 可以确保集合元素处于排序状态。 TreeSet 底层使用红黑树结构存储数据 新增的方法如下(了解) Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet (fromElement , toElement) SortedSet headSet (toElement) SortedSet tailSet (fromElement) TreeSet 两种排序方法： 自然排序 和 定制排序 。默认情况下， TreeSet 采用自然排序。 向TreeSet中添加的对象，要求是相同类的对象，且实现comparable接口 自然排序中比较两个对象是否相同的标准为compareTo()返回值，不再是equals() 定制排序TreeSet set = new TreeSet(new comparator(Object o1, Object o2){}); Map接口 Map 与 Collection 并列存在。用于保存具有映射关系的数据 key-value Map 中的key和value都可以是任何引用类型的数据 Map 中的key用Set来存放， 不允许重复 ，即同一个Map对象所对应的类，须重写 hashCode()和 equals()方法，value用Collection存放，key-value对用Set存放 常用 String 类作为 Map 的“键” key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value Map 接口的常用实现类： HashMap 、 TreeMap 、 LinkedHashMap 和Properties 。 其中， HashMap是Map接口使用频率最高的实现类 HashMap：作为Map的主要实现类，线程不安全，效率高，可以存储null的key和value Hashtable：古老的实现类，线程安全，效率低，不可以存储null的key和value LinkedHashMap：可以按照添加顺序遍历，对于频繁的遍历操作，效率高于HashMap TreeMap：按key-value排序实现排序遍历，此时考虑key的自然排序或定制排序，底层使用红黑树 常用方法 方法 描述 Object put(Object key,Object value) 将指定key-value添加到或修改当前 map 对象中，先封装为Entry再添加到Map中 void putAll(Map m) 将 m 中的所有 key-value 对存放到当前 map 中 Object remove(Object key) 移除指定 key 的 key-value 对，并返回 value void clear() 清空当前 map 中的所有数据 Object get(Object key) 获取指定 key 对应的 value boolean containsKey(Object key) 是否包含指定的 key boolean containsValue(Object value) 是否包含指定的 value int size() 返回 map 中 key-value 对的个数 boolean isEmpty() 判断当前 map 是否为空 boolean equals(Object obj) 判断当前 map 和参数对象 obj 是否相等 Set keySet() 返回所有 key 构成的 Set 集合 Collection values() 返回所有 value 构成的 Collection 集合 Set entrySet() 返回所有 key-value 对构成的 Set 集合 HashMap HashMap 是 Map 接口使用频率最高的实现类。 允许使用 null 键和 null 值，与HashSet一样，不保证映射的顺序。 所有的 key 构成的集合是 Set: 无序的、不可重复的。所以，key所在的类要重写：equals() 和 hashCode() 所有的 value 构成的集合是 Collection: 无序的、可以重复的。所以，value 所在的类要重写： equals() 一 个 key-value 构成一 个 entry 所有的 entry 构成的集合是 Set: 无序的、不可重复的 HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true、hashCode 值也相等。 HashMap 判断两个 value 相等的标准是：两个 value 通过 equals() 方法返回 true 。 JDK7及之前：底层为数组+链表结构 JDK8及以后：底层为数组+链表+红黑树实现 底层实现 JDK7及之前 底层创建了默认长度为16的一维数组Entry[] table HashMap的内部存储结构其实是 数组和链表的结合。当实例化一个 HashMap时系统会创建一个长度为 Capacity 的 Entry 数组，这个长度在哈希表中被称为容量(capacity), 在这个数组中可以存放元素的位置我们称之为 桶 (bucket), 每个bucket 都有自己的索引，系统可以根据索引快速的查找 bucket 中的元素 。 每个 bucket 中存储一个元素，即一个 Entry 对象，但每一个 Entry 对象可以带一个引用变量，用于指向下一个元素。因此，在一个桶中，就有可能生成一个 Entry 链 。而且，新添加的元素作为链表的 head 。 添加元素的过程： 向HashMap 中添加 entry1 (key, value) 需要首先计算 entry1 中 key 的哈希值(根据key 所在类的 hashCode() 计算得到，此哈希值经过处理以后，得到在底层 Entry[] 数组中要存储的位置 i 。 如果，位置 i 上没有元素，则 entry 1 直接添加成功 。 如果，位置 i 上已经存在 entry 2（或还有链表存在的 entry3， entry4）则需要通过循环的方法，依次比较 entry1中 key 和 其他的 entry。 如果彼此 hash 值不同，则直接添加成功。 如果hash值相同，继续比较二者是否 equals 。 如果，返回值为 true则使用 entry 1 的 value去替换 equals 为 true 的 entry 的 value。 如果遍历一遍以后 发现 所有的 equals 返回都为 false, 则 entry 1 仍可添加成功 。 entry 1 指向原有的 entry 元素 。 扩容：当元素个数超过，数组大小*LoadFactor(一般为0.75)时，扩容为原来2倍，并重新计算元素位置，耗费资源，所以如果开始知道元素个数，可以对容量进行设定。 JDK8及之后 从Entry数组变为Node数组 new hashMap()不会直接创建一个长度为16的数组，首次使用put时再创建默认长度的数组 HashMap 的内部存储结构其实是数组+链表+树的结合。 当实例化一个HashMap 时，会初始化 initialCapacity 和 loadFactor，在 put 第一对映射关系时，系统会创建一个长度为 initialCapacity 的 Node 数组，这个长度在哈希表中被称为容量 (capacity) 在这个数组中可以存放元素的位置我们称之为桶 (bucket)，每个 bucket 都有自己的索引，系统可以根据索引快速的查找 bucket 中的元素 每个 bucket 中存储一个元素，即一个 Node 对象，但每一个 Node 对象可以带一个引用变量 next 用于指向下一个元素。因此，在一个桶中，就有可能生成一个 Node 链。 也可能是一个一个 TreeNode 对象，每一个 TreeNode 对象可以有两个叶子结点 left 和 right 因此 在一个桶中 就有可能生成一个TreeNode 树。 而新添加的元素作为链表的 last 或树的叶子结点 。(七上八下) 当HashMap 中的元素个数超过数组大小(数组总大小 length, 不是数组中个数)sizeloadFactor 时，就会进行数组扩容 loadFactor 的默认值DEFAULT_LOAD_FACTOR 为 0.75 这是一个折中的取值 。 也就是说，默认情况下数组大小 DEFAULT_INITIAL_CAPACITY 为 16 那么当 HashMap 中元素个数超过160.75=12这个值就是代码中的 threshold 值也叫做临界值的时候，就把数组的大小扩展为 2*16=32，即扩大一倍。然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作 所以如果我们已经预知HashMap 中元素的个数 那么预设元素的个数能够有效的提高 HashMap 的性能 当HashMap 中的其中一个链的对象个数如果达到了 8 个，此时如果 capacity 没有达到 64 ，那么 HashMap 会先扩容解决，如果已经达到了 64 ，那么这个链会变成树，结点类型由 Node 变成 TreeNode 类型。当然，如果当映射关系被移除后，下次 resize 方法时判断树的结点个数低于 6 个，也会把 树再转为链表。 LinkedHashMap LinkedHashMap 是 HashMap 的 子类 在 HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的顺序 与 LinkedHashSet 类似 LinkedHashMap 可以维护 Map 的迭代。顺序：迭代顺序与 Key-Value 对的插入顺序一致 TreeMap TreeMap 存储 Key-Value对时， 需要根据 key-value 对进行排序。 TreeMap 可以保证所有的 Key-Value 对处于 有序 状态 。 TreeSet 底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序 TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序 ：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口 TreeMap 判断 两个 key 相等的标准 ：两个 key 通过 compareTo() 方法或者 compare() 方法返回 0 。 Hashtable Hashtable 是个古老的 Map 实现类， JDK1.0 就提供了。不同于 HashMap，Hashtable 是线程安全的。 Hashtable 实现原理和 HashMap 相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用 。 与 HashMap 不同， Hashtable 不允许使用 null 作为 key 和 value 与 HashMap 一样， Hashtable 也不能保证其中 Key Value 对的顺序 Hashtable 判断两个 key 相等、两个 value 相等的标准 与 HashMap 一致。 Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key 、 value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型 存取数据时，建议使用 setProperty (String key,String value) 方法和getProperty (String key)方法 Properties pros = new Properties(); pros.load(new FileInputStream(&quot;jdbc.properties)); String user = pros.getProperty(&quot;user&quot;); System.out.println(user); Collections工具类 Collections 是一个操作 Set 、 List 和 Map 等集合的工具类 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。 方法（均为 static 方法） 描述 reverse(List) 反转 List 中元素的顺序 shuffle(List) 对 List 集合元素进行随机排序 sort(List) 根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List, Comparator) 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List, int i, int j) 将指定 list 集合中的 i 处元素和 j 处元素进行交换 Object max(Collection) 根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection Comparator) 根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) 根据元素的自然顺序，返回给定集合中的最小元素 Object min(Collection Comparator) 根据 Comparator 指定的顺序，返回给定集合中的最小元素 int frequency(Collection Object) 返回指定集合中指定元素的出现次数 void copy(List dest,List src ) 将 src 中的内容复制到 dest 中，要求dest.size()大于等于src.size() boolean replaceAll (List list, Object oldVal, Object newVal) 使用新值替换List对象的所有旧值 copy中如果dest小于src的解决办法 List dest = Arrays.asList(new Object[src.size()]); copy(dest, src); Collection类中提供了同步方法，该方法可以讲指定集合包装为线程同步的集合，从而解决线程安全问题 ","link":"https://yeyuan1107.github.io/post/java-ji-he/"},{"title":"Java常用类","content":" 字符串相关的类 String类 String类：代表字符串。Java程序中的所有字符串字面值都作为此类的实例实现 String类是一个final类，代表不可变的字符序列，不能被继承 字符串是常量，用双引号引起来表示，他们的值在创建之后不能更改 String对象的字符内容是存储在一个字符数组value[]中的 String实现了Serializable接口：表示字符串事支持序列化的 String实现了comparable接口：表示字符串可以比较大小 String内部定义了final char[] value用于存储字符串数据，数组及数组内容均不可变 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSeqence{ // The value is used for character storage private final char value[]; //Cache the hash code for the String. Default to 0 private int hash; } 不可变性 不同字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有value进行赋值，即不更改原地址上的内容，重新开辟一块内存赋值，地址指向新开辟的内存 当现有的字符串进行连接操作时，也需要指定内存区域赋值，不能使用原有的value进行赋值 当调用String的修改方法replace()修改制定的字符或字符串时，也必须重新指定内存区域赋值 创建方式 String str = &quot;hello&quot;; //相当于this.value = new char[0] String str = new String(); //相当于this.value = original.value String str = new String(String original); //相当于this.value = Arrays.copyOf(value, value.length) String str = new String(char[] a); String str = new String(char[] a, int startIndex, int count); 内存解析 当String使用字面量的定义方式如：String xxx = &quot;abc&quot; (&quot;abc&quot;声明在字符串常量池)当等号右侧内容相同时，不同的String对象指向的是同一个地址，字符串敞亮池中不会存放相同内容的字符串 //在字符串常量池中创建了一个字面量为&quot;a&quot;的字符串 String s1 = &quot;a&quot;; //实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1 +&quot;b&quot;即&quot;ab&quot;。 //只要其中一个是变量，结果就在堆中，+=也是该情况。 //如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。 //如果这样的操作放到循环中，会极大影响程序的性能 s1 = s1 + &quot;b&quot;; //直接在字符串常量池中创建一个字面量为&quot;ab&quot;的字符串 String s2 = &quot;ab&quot;; //s3指向字符串常量池中已经创建的&quot;ab&quot;的字符串 String s3 = &quot;a&quot; + &quot;b&quot;; //堆空间的s1对象在调用intern()之后，会将常量池中已经存在的&quot;ab&quot;字符串赋值给s4 String s4 = s1.intern(); String常用方法 方法 作用 int length() 返回字符串的长度:return value.length char charAt(int index) 返回某索引处的字符:return value[index] boolean isEmpty() 判断是否是空字符串:return value.length==0 String toLowerCase() 使用默认语言环境,将String中的所有字符转换为小写 String toUpperCase() 使用默认语言环境,将String中的所有字符转换为大写 String trim() 返回字符串的副本忽略前导空白和尾部空白 boolean equals(Object obj) 比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString) 与 equals 方法类似忽略大小写 String concat(String str) 将指定字符串连接到此字符串的结尾，等价于用&quot;+&quot; int compareTo(String anotherString) 比较两个字符串的大小,&gt;0当前对象大，否则当前对象小 String substring(int beginIndex) 返回一个新的字符串它是此字符串的从beginIndex开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) 返回一个新字符串它是此字符串从 beginIndex开始截取到endIndex(不包含)的一个子字符串。 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int offset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s) 当且仅当此字符串包含指定的char值序列时，返回true int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 indexOf 和 lastIndexOf 方法如果未找到都是返回 1 String replace(char oldChar, char newChar) 返回一个新的字符串它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的 String replace(CharSequence target, CharSequence replacement) 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串 String replaceAll(String regex, String replacement) 使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串 String replaceFirst(String regex, String replacement) 使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串 最多不超过limit个如果超过了剩下的全部都放到最后一个元素中 包装类.parseXxx(String str) 将字符串转为基本数据类型、包装类 String.valueOf(xxx) 将包装类、基本数据类型转为字符串 new String(char[] xxx) 将字符数组转化为字符串 new String(char[] xxx, int offset, int length) 将字符数组从offset开始，长度为length，转化为字符串 str.toCharArray() 将字符串转化为字符数组 public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 提供了将指定索引范围内的字符串存放到数组中的方法 String(byte[] xxx) 通过平台默认字符集解码制定的byte数组，构造一个新的String String(byte[] xxx, int offset, int length) 从offset开始长度为length个字节构造一个字符串对象 String(byte[] xxx, charsetName 按照指定字符集解码字节数组 public byte[] getBytes() 按照平台默认字符集将String编码为byte数组 public byte[] getBytes(String charsetName) 使用指定的字符集，将此String编码到byte序列，并将结果存储到新的byte数组 StringBuffer和StringBuilder 不同点： StringBuffer：线程安全，效率偏低 StringBuilder：线程不安全，效率更高，JDK1.5中新增 相同点： 父类相同均为AbstractStringBuilder 均为可变字符串 底层均为字符数组char[] 与String区别 与String类不同，其对象必须使用构造器生成，有三个构造器 StringBuffer(), StringBuilder()：初始容量为16的字符串缓冲区 StringBuffer(int size), StringBuilder(int size)：构造指定容量的字符串缓冲区 StringBuffer(String str), StringBuilder(String str)：将内容初始化为指定字符串内容，字符数组长度为str.length + 16 构造器中 str 如果等于null那么抛出空指针异常 如果要添加的数据底层数组装不下，那就要扩容底层数组，一般扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新数组中 常用方法 方法 作用 StringBuffer append(xxx) 提供了很多的 append() 方法用于进行字符串拼接，如果xxx为null那么在字符串中增加&quot;null&quot; StringBuffer delete(int start,int end) 删除指定位置的内容，左闭右开 StringBuffer replace(int start, int end, String str) 把[start,end)位置替换为str StringBuffer insert(int offset, xxx) 在指定位置插入xxx StringBuffer reverse() 把当前字符序列逆转 public int indexOf (String str) public String substring (int start,int end) public int length() public char charAt (int n) public void setCharAt (int n ,char ch) 日期时间API JDK8.0之前日期时间API java.lang.System类System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。此方法适用于计算时间差。 java.util.Date类表示特定的瞬间，精确到毫秒 构造器 Date()：使用无参构造器创建的对象可以获取本地当前时间 Date(long date)：创建指定毫秒数的一个对象 常用方法 getTime()：返回自1970年1月1日00:00:00 GMT 以来次Date对象表示的毫秒数 toString()：把此Date对象转换为以下形式的String：dow mon dd hh:mm:ss zzz yyy其中：dow是星期，zzz是时间标准 java.sql.Date 该类为java.util.Date类的子类，对应数据库中日期变量 构造器 new Date(long date)：用指定毫秒数构建对象 方法 toString()只输出年月日 将java.util.Date类转化为java.sql.Date类 //方式一 Date date1 = new java.sql.Date(long time); java.sql.Date date2 = (java.sql.Date)date1; //方式二 Date date3 = new Date(); java.sql.Date date4 = new java.sql.Date(date3.getTime()); java.text.SimpleDateFormat类 Date类的API不易于国际化，大部分被废弃了，该类是一个不与语言环境有关的方式来格式化和解析日期的具体类 它允许进行格式化：日期 -&gt; 文本、解析：文本 -&gt; 日期 格式化： SimpleDateFormat()：默认的模式和语言环境创建对象 public SimpleDateFormat(String pattern)：该构造方法可以使用参数pattern指定的格式创建一个对象，该对象调用public String format(Date date)：方法格式化时间对象date pattern示例：yyyy(4位年份)-MM(2位月份)-dd(2位日期) hh(2位小时):mm(2位分钟):ss(2位秒) 解析： public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期 java.util.Calendar类 Calendar类是一个抽象基类，主要用于完成日期字段之间相互操作的功能获取Calendar类的方法: 使用Calendar.getInstance()方法，返回GregorianCalendar对象 调用他的子类GregorianCalendar的构造器 常用方法 public int get(int field)方法来取得想要的时间信息，比如YEAR、MONTH、DAY_OF_WEEK 、HOUR_OF_DAY、MINUTE、SECOND 获取月份时：一月是0，二月是1... 获取星期时：周日是1，周一是2... public void set(int field, int value)：更改对应field属性 public void add(int field, int amount)：在field属性上加amount public final Date getTime()：日历类 -&gt; Date类 public final void setTime(Date date)：Date类 -&gt; 日历类 JDK8中的新日期API Calendar类的缺点： 可变性：像日期和时间这样的类应该是不可变的 偏移性：Date中的年份是从1900开始的，而月份都从0开始 格式化：格式化只对Date有用，Calendar则不行 不是线程安全的不能处理闰秒 java.time API LocalDate类(本地日期) LocalTime类(本地时间) LocalDateTime类(本地日期时间) ZonedDateTime类(时区) Duration类(持续时间) java.time 包含值对象的基础包 java.time.chrono 提供对不同的日历系统的访问 java.time.format 格式化和解析时间和日期 java.time.temporal 包含底层框架和扩展类型java.time.zone 包含时区支持的类 LocalDate LocalTime LocalDateTime类 这几个类是较为重要的几个类，他们的实例是不可变的对象，分别表示用ISO-8601日历系统的日期、时间、日期和时间。 LocalDate代表ISO格式(yyyy-MM-dd)的日期，可以存储生日、纪念日等日期 LocalTime表示一个时间，而不是日期 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一 方法 描述 now() /* now(ZoneId zone) 静态方法根据当前时间创建对象/指定时区的对象 of() 静态方法根据指定日期时间创建对象 getDayOfMonth()/getDayOfYear() 获得月份天数(1-31)/获得年份天数(1-366) getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值) getMonth() 获得月份(返回一个 Month 枚举值) getMonthValue()/getYear() 获得月份(1-12)/获得年份 getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟 、秒 withDayOfMonth()/withDayOfYear()/withMonth()/withYear() 将月份天数、年份天数 、月份 、年份修改为指定的值并返回新的对象 plusDays(), plusWeeks(),plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时 minusMonths()/minusDays()/minusYears()/minusHours() 从当前对象减去几月、几周、几天、几年、几小时 Instant 在处理时间和日期的时候，我们通常会想到年月日时分秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。 在 UNIX 中，这个数从 1970 年开始，以秒为的单位；同样的，在 Java 中，也是从 1970 年开始，但以毫秒为单位。java.time 包通过值类型 Instant 提供机器视图，不提供处理人类意义上的时间单位。 Instant 表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲， 它只是简单的表示自 1970 年 1 月 1 日 0 时 0 分 0 秒（ UTC ）开始的秒数。 因为 java.time 包是基于纳秒计算的，所以 Instant 的精度可以达到纳秒级。 方法 描述 now() 静态方法返回默认 UTC 时区的 Instant 类的对象 ofEpochMilli (long epochMilli) 静态方法返回在 1970-01-01 00:00:00 基础上加上指定毫秒数之后的 Instant 类的对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime toEpochMilli() 返回1970-01-01 00:00:00 到当前时间的毫秒数即为时间戳，时间戳是指格林威治时间1970-01-01 00:00:00 北京时间 1970-01-01 08:00:00 起至现在的总秒数。 java.time.format.DateTimeFormatter 该类提供了三种格式化方法 预定义的标准格式: ISO_LOCAL_DATE_TIME ISO_LOCAL_DATE ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;) 方法 描述 ofPattern(String pattern) 静态方法返回一个指定字符串格式的DateTimeFormatter format(TemporalAccessort) 格式化一个日期、 时间返回字符串 parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间 其他API 转换 Java比较器 java.lang.Comparable与java.util.Comparator两个接口实现对象的比较 自然排序java.lang.Comparable Comparable 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序 。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小 。 如果当前对象 this 大于形参对象 obj 则返回正整数，如果当前对象 this 小于形参对象 obj 则返回负整数，如果当前对象 this 等于形参对象 obj 则返回零 。 实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort 进行自动排序(从小到大)。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器 。 对于类 C 的每一个 e1 和 e2 来说，当且仅当e1.compareTo(e2) == 0与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致 。 建议（虽然不是必需的）最好使自然排序与 equals 一致。 定制排序java.util.Comparator 当元素的类型没有实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序强行对多个对象进行整体排序的比较。 重写 compare(Object o1,Object o2) 方法，比较 o1 和 o2 的大小： 如果方法返回正整数，则表示 o1 大于 o2 ；如果返回 0 ，表示相等；返回负整数，表示o1 小于 o2 。 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）从而允许在排序顺序上实现精确控制 。 还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序 Arrays.sort(Object[] arr, new comparator{ public int compare(Object o1, Object o2){ //升序：当o1&gt;o2时返回正数 //降序：当o1&gt;o2时返回负数 方法体; } }); System类 System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包 。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的 成员变量和成员方法都是 static 的， 所以也可以很方便的进行调用 。 成员变量：System 类内部包含 in 、 out 和 err 三个成员变量，分别代表标准输入流(键盘输入) ，标准输出流(显示器)和标准错误输出流(显示器)。 成员方法 方法 描述 native long currentTimeMillis() 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和 GMT 时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status) 该方法的作用是退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。 使用该方法可以在图形界面编程中实现程序的退出功能等 。 void gc() 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key) 该方法的作用是获得系统中属性名为 key 的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： Math类 java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double 型。 方法 描述 abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow(double a,doble b) a的b次幂(2的n次幂可以通过左移n-1位完成) log 自然对数 exp e为底指数 max(double a,double b) 最大值 min(double a,double b) 最小值 random() 返回 0.0 到 1.0 的随机数 long round(double a) double型数据a转换为 long 型（四舍五入） toDegrees(double angrad) 弧度 -&gt; 角度 toRadians(double angdeg) 角度 -&gt; 弧度 BigInteger和BigDecimal BigInteger java.math 包的 BigInteger 可以表示不可变的任意精度的整数 。 BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外， BigInteger 还提供以下运算：模算术、 GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器:BigInteger(String val) 根据字符串构建 BigInteger 对象 常用方法： 方法 描述 public BigInteger abs () 返回此 BigInteger 的绝对值的 BigInteger。 BigInteger add(BigInteger val) 返回其值为 (this + val) 的 BigInteger BigInteger subtract(BigInteger val) 返回其值为 (this - val) 的 BigInteger BigInteger multiply (BigInteger val) 返回其值为 (this * val) 的 BigInteger BigInteger divide (BigInteger val) 返回其值为 (this / val) 的 BigInteger，整数相除只保留整数部分 BigInteger remainder (BigInteger val) 返回其值为 (this % val) 的 BigInteger BigInteger [] divideAndRemainder (BigInteger val) 返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组 BigInteger pow (int exponent) 返回其值为 (this^exponent ) 的 BigInteger BigDecimal类 一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类 。BigDecimal 类支持**不可变的、任意精度的有符号十进制定点数 **。 构造器: public BigDecimal(double val) public BigDecimal (String val) 常用方法: 方法 描述 public BigDecimal add (BigDecimal augend) 相加 public BigDecimal subtract (BigDecimal subtrahend) 相减 public BigDecimal multiply (BigDecimal multiplicand) 乘法 public BigDecimal divide (BigDecimal divisor, int scale, int roundingMode) 除法 枚举类 枚举类的使用 类的对象只能有有限个，例如星期、性别、季节等，当需要定义一组常量时，强烈建议使用枚举类 枚举类定义 JDK1.5之前需要自定义枚举类 声明对象的属性，private final修饰 私有化类的构造器，并给属性初始化 提供当前枚举类的多个对象，public static final修饰public static final xxx = new Xxx() 其他需求：获取对象属性的getter()和toString()方法 JDK1.5及之后Enum关键字来定义枚举类 提供当前枚举类对象，用&quot;,&quot;隔开对象，最后一个对象用&quot;;&quot;结尾，系统自动添加public static final修饰，必须在枚举类的第一行声明枚举类对象 声明属性 私有化构造器 默认toString()打印对象名枚举类只有一个对象，则可以作为一种单例模式的实现方式 enum默认继承于java.lang.Enum所以不能再继承其他类，JDK1.5中可以在switch表达式中使用Enum定义的枚举类对象作为表达式，case子句可以直接使用枚举值的名字，无需添加枚举类作为限定 枚举类主要方法 方法 描述 toString 得到当前枚举常量的名称 valueOf(String str) 返回枚举类中对象名是str的对象 values() 返回枚举类的对象数组 equals() 在枚举类中可以直接使用&quot;&quot;来比较两个枚举类是否相同，Enum提供这个equals方法，也是直接用&quot;&quot;实现的，它的存在是为了在Set、List和Map中使用，equals()是不可变的 hashCode Enum()实现了hashCode()来与equals()保持一致，也不可变 getDeclaringClass 得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型 name 得到当前枚举常量的名称，建议优先使用toString() ordinal 得到当前枚举常量的次序 compareTo 枚举类型实现了comparable接口，这样可以比较两个枚举常量的大小 clone 枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone() 枚举类实现接口 Enum 类名 implements 接口名 接着实现对应方法 让枚举类中的对象分别实现抽象方法 对象名(){ 重写方法; } interface info{ void show(); } //枚举类 enum Season1 implements info{ SPRING(&quot;春天&quot;, &quot;春暖花开&quot;){ public void show() { System.out.println(&quot;春天在哪里？&quot;); } }, SUMMER(&quot;夏天&quot;, &quot;夏日炎炎&quot;) { public void show() { System.out.println(&quot;生如夏花&quot;); } } , AUTUTO(&quot;秋天&quot;, &quot;硕果累累&quot;) { public void show() { System.out.println(&quot;秋天是用来分手的季节&quot;); } }, WINTER(&quot;冬天&quot;, &quot;白雪皑皑&quot;) { public void show() { System.out.println(&quot;冬天里的一把火&quot;); } }; //1.提供类的属性，声明为private final private final String seasonName; private final String seasonDesc; //2.声明为final的属性，在构造器中初始化 private Season1(String seasonName,String seasonDesc) { this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //3.通过公共的方法来调用属性 public final String getSeasonName() { return seasonName; } public final String getSeasonDesc() { return seasonDesc; } @Override public String toString() { return &quot;Season [seasonName=&quot; + seasonName + &quot;, seasonDesc=&quot; + seasonDesc + &quot;]&quot;; } } 注解 简介 JDK1.5开始支持 注解(Annotation)：其实就是代码里的特殊标记，这些标记可以在编译，类加载运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在原文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署 注解可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的&quot;name = value&quot;对中 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的Bean和切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等 框架 = 注解 + 反射 + 设计模式 常见Annotation实例 实例一：生成文档的相关注解 @author：标明开发该类模块的作者 多个作者之间使用分割@version：标明该类模块的版本@see：参考转向也就是相关主题@since：从哪个版本开始增加的@param：对方法中某参数的说明 如果没有参数就不能写@return：对方法返回值的说明 如果方法的返回值类型是 void 就不能写@exception：对方法可能抛出的异常进行说明 如果方法没有用 throws 显式抛出的异常就不能写其中：@param @return 和 @exception 这三个标记都是只用于方法的 。@param的格式要求：@param 形参名 形参类型 形参说明@return的格式要求：@return 返回值类型 返回值说明@exception的格式要求：@exception 异常类型 异常说明@param和 @exception 可以并列多个 实例二：在编译时进行格式检查 @Override: 限定重写父类方法 , 该注解只能 用于方法@Deprecated : 用于表示所修饰的元素类 , 方法等已过时。通常是因为所修饰的结构危险或存在更好的选择@SuppressWarnings : 抑制编译器警告 实例三：跟踪代码依赖性，实现替代配置文件功能 Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中部署 @WebServlet(&quot;/login&quot;) public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L； protected void doGet(HttpServletRequest request , HttpServletResponse response) throws ServletException, IOException{} protected void doPost(HttpServletRequest request , HttpServletResponse response) throws ServletException, IOException { doGet(request , response); } } 旧版web.xml文件 &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern &gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 自定义Annotation 定义新的 Annotation类型使用@interface关键字 自定义注解自动继承了java.lang.annotation.Annotation接口 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。 我们称为配置参数。类型只能是八种基本数据类型、String 类型、Class 类型、enum 类型、Annotation 类型以上所有类型的数组 。 可以在定义 Annotation 的成员变量时为其指定初始值 指定成员变量的初始值可使用 default 关键字 如果只有一个参数成员建议使用参数名为value 如果定义的注解含有配置参数那么使用时必须指定参数值除非它有默认值。格式是&quot;参数名=参数值&quot;如果只有一个参数成员且名称为value可以省略&quot;value=&quot; 没有成员定义的 Annotation 称为标记包含成员变量的 Annotation 称为元数据 Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义 。 @MyAnnotation(value=&quot;尚硅谷&quot;) public class MyAnnotationTest { public static void main(String[] args ){ Class clazz = MyAnnotationTest.class Annotation a = clazz.getAnnotation(MyAnnotation.class); MyAnnotation m = (MyAnnotation) a; String info = m.value(); System.out.println(info); } } @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.PARAMETER}) @interface MyAnnotation{ String value() default &quot;&quot;; } JDK中的元注解 JDK的元Annotation用于修饰其他Annotation定义JDK5.0提供了4个标准的meta-annotation类型，分别为： Retention:只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期@Retention包含一个RetentionPolicy类型的成员变量，使用时必须为该value成员变量指定值 RetentionPolicy.SOURCE：在源文件中有效(即源文件保留)，编译器直接丢弃这种策略的注解 RetentionPolicy.CLASS：在class文件中有效(即class保留)，当运行Java程序时，JVM不会保留注解，这是默认值 RetentionPolicy.RUNTIME：：在运行时有效(即运行时保留)，当运行Java程序时，JVM会保留住时，程序可以通过反射获取该注解 Target：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量 ElementType.CONSTRUCTOR：用于描述构造器 ElementType.FIELD：用于描述域 ElementType.LOCAL_VARIABLE：用于描述局部变量 ElementType.METHOD：用于描述方法 ElementType.PACKAGE：用于描述包 ElementType.PARAMETER：用于描述参数 ElementType.TYPE：用于描述类、接口(包括注解类型)或enum声明 Documented：用于指定被该元Annotation修饰的Annotation类将被Javadoc工具提取成文档。默认情况下，javadoc是不包括注解的 定义为Documented的注解必须设置Retention值位RUNTIME Inherited：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解 比如把标有@Inherited注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解 实际应用中使用较少 通过反射获取注解信息 JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口 , 该接口代表程序中可以接受注解的程序元素 当一个 Annotation 类型被定义为运行时 Annotation后 , 该注解才是运行时可见 , 当class文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取 程序可以调用 AnnotatedElement 对象的如下方法来访问 Annotation 信息 JDK8.0中新特性 JDK8.0之前 JDK8.0及之后 类型注解 JDK1.8 之后，关于元注解 @Target 的参数类型ElementType枚举值多了两个：TYPE_PARAMETER, TYPE_USE。 在 Java 8 之前 注解只能是在声明的地方所使用 Java 8 开始 注解可以应用在任何地方 ElementType TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中如泛型声明 。 ElementType TYPE_USE 表示该注解能写在使用类型的任何语句中 。 TYPE_PARAMETER public class TestTypeDefine&lt;@TypeDefine() U&gt;{ private U u; public &lt;@TypeDefine() T&gt; void test(T t){ } } @Target({ElementType.TYPE_PARAMETER}) @interface TypeDefine{ } TYPE_USE @MyAnnotation public class AnnotationTest&lt;U&gt; { @MyAnnotation private String name; public static void main(String[] args){ AnnotationTest&lt;@MyAnnotation String&gt; t = null; int a = (@MyAnnotation int) 2L; @MyAnnotation int b = 10; } public static &lt;@MyAnnotation T&gt; void method(T t){ } public static void test(@MyAnnotation String arg) throws @MyAnnotation Exception{ } } @Target(ElementType.TYPE_USE) @interface MyAnnotation{ } ","link":"https://yeyuan1107.github.io/post/java-chang-yong-lei/"},{"title":"Java多线程","content":" 简介 程序：为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有自身的产生、存在和消亡的过程。 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个线程分配不同的内存区域(方法区和堆) 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个进程同一时间并行执行多个线程，就是支持多线程的 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(PC)，线程切换的开销小 一个进程的多个线程共享相同的内存单元/内存地址空间 -&gt; 他们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患 一个Java应用程序至少有三个线程：main()主线程、gc()垃圾回收线程、异常处理线程 优点 提高程序响应对图形化界面意义重大，增强用户体验 提高计算机CPU利用率 改善程序结构，将既长又复杂的进程分为多个线程，独立运行利于理解和修改 缺点 资源安全问题 线程间切换有开销，如果只使用单个线程先后完成多个任务(调用多个方法)，肯定比用多个线程来完成用的时间更短 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等 需要一些后台运行的程序时 线程的创建和使用 JVM允许程序运行多个线程，它通过java.lang.Thread类来体现Thread类的特性 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 通过该Thread对象的start()方法来启动这个线程，而非直接调用run() Thread类 构造器 Thread()：创建新的Thread对象 Thread(String threadname)：创建线程并指定线程实例名 Thread(Tunnable target)：指定创建线程的目标对象，它实现了Runable接口中的run方法 Thread(Runnable target, String name)：创建新的Thread对象 方法 void start()：启动线程，并执行run()方法 run()：线程在被调度时执行的操作 String getName()：返回线程的名称 void setName(String name)：设置线程的名称 static Thread currentThread()：返回当前线程 static void yield()：释放当前CPU执行权，在下一刻可能又被分配到执行权 join()：在线程A中调用线程B的join()方法，线程A进入阻塞状态，知道线程B完全执行完毕后线程A结束阻塞状态 stop()：强制线程生命周期结束，不推荐使用 isAlive()：判断线程是否还存活 static void sleep(long milltime)：让当前线程睡眠制定的毫秒数，在指定时间内该线程为阻塞状态，时间结束后等CPU分配资源再继续执行 属性 线程优先级Priority 从10 -&gt; 1(高 -&gt; 低) MAX_PRIORITY -&gt; NORM_PRIORITY -&gt; MIN_PRIORITYgetPriority()setPriority()优先级越高只代表被CPU分配资源概率高，不一定是他执行完才执行优先级低的 创建线程的方法 JDK1.5之前 开发中优先选择实现Runnable方式区别： 继承Thread类：线程代码存放Thread子类run()方法中实现Runnable：线程代码存在接口的子类的run()方法 联系： Thread也实现了Runnable两种方式都要重写run()方法 继承Thread类 注意 不能直接调用run()方法来创建线程，如果直接调用就只是普通方法，并没有启动多线程模式run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定想要启动多线程，必须调用start方法不能让已经start()的线程再次start()，如果多次启动抛出异常IllegalThreadStateException //1.定义子类继承Thread类 class MyThread extends Thread{ public MyThread(){ super(); } //2.子类中重写run()方法，该线程要进行的操作写在run()方法中 @override public void run(){ 方法体; } } public class TestThread{ public static void main(String[] args){ //3.创建Thread类的子类的对象 MyThread mt = new MyThread(); //4.通过对象调用start()方法，该方法作用为 //4.1 启动当前线程 //4.2 调用当前线程的run() mt.start(); } } 实现Runnable接口 优点： 避免了但继承的局限性多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源 //1. 创建一个实现了Runnable接口的类 class MyThread implements Runnable{ //2. 实现run()方法 public void run(){ 方法体; } } public class TestThread{ public static void main(String[] args){ //3. 创建实现类对象 //4. 将此对象作为参数传递到Thread类的有参构造器中，创建Thread类对象 //4.1 在Thread类中有一个构造器为Thread(Runnable target)当target!=null时run()中执行target.run() Thread mt = new Thread(new MyThread()); //5. 通过Thread类的对象调用start()方法 mt.start(); } } JDK1.5及之后 实现Callabel接口 与Runnable相比Callable功能更强大些： 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future接口：可以对具体Runnable、Callable任务的执行结果进行取消、查询时否完成、获取结果等。 FutureTask是Future接口的唯一实现类 FutureTask同时实现了Runnable，Future接口。他既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值：futuretask.get() //1. 创建一个实现Callable的实现类 class CallableExample implements Callable { //2. 实现call()方法将此线程需要执行的操作是现在call()方法中 public Object call() throws Exception { Random generator = new Random(); Integer randomNumber = generator.nextInt(5); Thread.sleep(randomNumber * 1000); return randomNumber; } } public class CallableFutureTest { public static void main(String[] args) throws Exception { FutureTask[] randomNumberTasks = new FutureTask[5]; for (int i = 0; i &lt; 5; i++) { //3. 创建Callable接口实现类对象 Callable callable = new CallableExample(); //4. 将Callable接口实现类对象作为FutureTask构造器参数来创建FutureTask对象 randomNumberTasks[i] = new FutureTask(callable); //5. 将FutureTask对象最为Thread构造器参数来创建Thread对象 Thread t = new Thread(randomNumberTasks[i]); //6. 启动线程 t.start(); } for (int i = 0; i &lt; 5; i++){ //7. 通过get()的到Callable中call()方法的返回值 System.out.println(randomNumberTasks[i].get()); } } } 使用线程池 背景：经常创建和销毁、使用量特别大的资源，比如兵法情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。就可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具 优点： 提高响应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中的线程，不需要每次都创建) 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务是最多保持多长时间会终止 线程池的相关API：ExecutorService和ExecutorsExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable &lt;T&gt; Future &lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般用来执行Callable void shutdown()：关闭线程池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 public void poolTest(){ //1. 创建线程池，返回类型为ThreadPoolExecutor //ThreadPoolExecutor是线程池的类，可以通过强转来设置线程池属性 ExecutorService es = Executors.newCachedThreadPool(); //2. 设置线程池参数，例如corePoolSize等 //3. 线程执行 //适用于Runnbale es.execute(Runnable xx); //适用于Callable es.submit(Callable&lt;T&gt; xx); //关闭线程池 es.shutdown(); } 线程的调度 常见的策略为：时间片、抢占式 Java的调度方法： 同优先级线程组成先进先出队列(先到先服务)，使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的分类 Java中线程分为两类 守护线程：用来服务用户线程，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程，Java垃圾回收就是一个典型的守护线程 用户线程他们在几乎每个方面都是相同的，唯一区别就是判断JVM何时离开若JVM中都是守护线程，当前JVM将退出 线程的生命周期 新建： 当 一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪： 处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行 的条件 ，只是没分配到 CPU 资源 运行： 当就绪的线程被调度并获得 CPU 资源时便进入运行状态， run() 方法定义了线程的操作和功能 阻塞： 在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡： 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程的同步 多个线程的不确定性引起执行结果的不稳定，多个线程对资源共享，会造成操作的不完整性，会破坏数据。同步解决了线程安全问题，但操作同步代码时只能有一个线程参与，其他线程等待，相当于一个单线程过程。 同步代码块 //同步监视器相当于一把锁，任何一个类的对象都可以充当锁，要求要同步的多个线程共用一把锁 //在实现Runnable接口方法中同步监视器可以考虑写this即可 //在继承Thread类方法中同步监视器可以考虑写xx.class(可以为当前类)，慎用this synchronized(同步监视器){ //操作共享数据的代码 //共享数据：多个线程共同操作的变量 需要同步的代码; } 同步方法 如果操作共享数据的代码完整的生命在一个方法中，我们不妨将此方法声明为同步方法 JDK1.5之前 实现Runable方法的同步方法 //该方法中也有同步监视器为this 权限修饰符 synchronized 返回值类型 方法名(形参列表){ 需要同步的代码; } 继承Thread类方法的同步方法 //该方法中同步监视器为 当前类.class 权限修饰符 static synchronized 返回值类型 方法名(形参列表){ 需要同步的代码; } 注意 同步方法中仍需要同步监视器，只不过不需要我们显式声明非静态的同步方法，同步监视器：this静态的同步方法，同步监视器：当前类本身 JDK1.5及之后 Lock锁 class A{ //1. 实例化ReentrantLock类，该类实现了java.util.concurrent.locks.lock接口 private final ReentrantLock lock = new ReenTrantLock(); public void m(){ //3. 调用lock()方法，也可以放在try中 lock.lock(); //2. 将需要同步的代码用try-finally包围 try{ 需要同步的代码块; }finally{ //4. finlly中调用unlock()方法 lock.unlock(); } } } synchronized与Lock的对比 Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了作用域自动释放 Lock 只有代码块锁， synchronized有代码块锁和方法锁 使用Lock锁， JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）优先使用顺序：Lock -&gt; 同步代码块(已经进入了方法体，分配了相应资源 ) -&gt;同步方法(在方法体之外) 同步锁 释放锁的几种操作 当前线程的同步方法、同步代码块执行结束。 当前线程在同步代码块、同步方法中遇到 break、 return 终止了该代码块、该方法的继续执行。 当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception 导致异常结束。 当前线程在同步代码块、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁。 不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用 Thread.sleep 、Thread.yield 方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁（同步监视器）。应尽量避免使用 suspend() 和 resume() 来控制线程 死锁 死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 线程的通信 wait()notify()和notifyAll() wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()和notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。 notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll()：唤醒正在排队等待资源的所有线程结束等待 注意 这三种方法只能在同步方法或同步代码块中才能使用，不能使用Lock锁，否则会报java.lang.IllegalMonitorStateException异常因为这三个方法必须有锁对象调用，而任何对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明 ","link":"https://yeyuan1107.github.io/post/java-duo-xian-cheng/"},{"title":"Java异常处理","content":" 简介 异常：在Java语言中，将程序执行时发生的不正常情况称为异常，开发中的语法错误和逻辑错误不是异常。 异常事件的分类 Error：Java虚拟机无法解决的严重问题。例如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OutofMemoryError(OOM堆溢出)。一般不变写针对性的代码进行处理。 Exception：其他因变成错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针异常、试图读取不存在的文件、网络连接中断、数组角标越界等。 异常事件的处理 遇到错误就终止程序的运行 由程序员在编写程序时，就考虑到错误的检测、错误消息的提示、以及错误的处理。 Exception分类 编译时异常(受检异常，除RuntimeException外的异常) IOException FileNotFoundException ClassNotFoundException 运行时异常(非受检异常，RuntimeException) NullPointerException(空指针异常) ArrayIndexOutOfBoundsException(角标越界) ClassCastException(类型转换异常) NumberFormatException InputMismatchException ArithmaticException(除零异常) 异常处理 抓抛模型： 抛：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出，一旦抛出对象后，其后的代码就不再执行。 抓：异常的处理方式： try-catch-finally throws try-catch-finally try{ 代码块; }catch(Exception e){ 异常的处理方法; }finally{ 一定会执行的代码; } 使用 finally是可选的，可以不写，不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行 数据库连接 输入输出流 网络编程中Socket等资源 这些资源不会被JVM自动回收需要我们手动进行释放，此时资源的释放应当防在finally中 try将可能出现异常的代码包装起来，一旦出现异常就生成一个对应异常类的对象，根据该对象类型去catch中进行匹配 一旦try的异常对象匹配某一个catch时，就进入catch中进行异常的处理，一旦处理完成，就跳出当前的try-catch结构(在没有写finally的情况)，继续执行其后的代码 catch中的异常，如果没有子父类关系，则顺序没有关系，如果存在子父类关系，则子类应该声明在父类之上，否则报错 常用异常处理方法 getMessage()返回String，异常信息 printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的位置，返回值为空，方法内自带输出 try结构中声明的变量，在try结构外无法调用 try-catch-finally结构可以互相嵌套 体会 在使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但运行时仍可能报错相当于我们讲一个编译时异常延迟到运行时出现了 throws 如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。 public void 方法名() throws FileNotFoundException, Exception{ 方法体; } 使用 一旦方法体执行时，出现异常仍会在异常代码处生成一个异常对象，此对象满足throws后的异常类型时就被抛出，异常代码后续的代码不再执行。 重写方法不能抛出比被重写方法范围更大的异常类型 父类没有抛出异常子类也不能抛出异常 执行的方法中，先后调用了另外的几个方法，这几个方法是递进关系执行的我们建议这几个方法使用throws的方式进行处理，最外层方法使用try-catch-finally处理 体会 try-catch-finally真正的将异常处理掉了throws只是把异常抛给了方法的调用者，没有将异常真正处理掉 手动抛出异常 Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出 //1.生成异常类对象，然后通过throw语句实现抛出操作 //2.可以抛出的异常必须是Throwable或其子类的实例 throw new Exception(&quot;message&quot;); 用户自定义异常类 一般用户定义异常类都是RuntimeException的子类 自定义异常类通常需要编写几个重载的构造器 自定义异常需要提供serialVersionUID 自定义的异常通过throw抛出 自定义异常类最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型 //可以继承Exception或RuntimeException class MyException extends Exception{ //单独标识该类 static final long serialVersionUID = 32453426235L; 属性; 方法; } throws与throw的区别 throw：作用为生成异常对象，声明在方法体内 throws：处理异常，声明在方法声明处 ","link":"https://yeyuan1107.github.io/post/java-yi-chang-chu-li/"},{"title":"Java面向对象","content":" 面向对象内容的三条主线 Java类及类的成员 属性 方法 构造器 代码块 内部类 面向对象的三大特性 封装性 继承性 多态性 其他类关键字 this super static final abstract interface package import 类和对象 类：是对一类事物的描述，是抽象的、概念上的定义对象：是实际存在的该类食物的每个个体，因而也称为实例 对象的功能取决于类的设计设计类相当于设计类的成员 类： 属性：成员变量 field(域，字段) 方法：函数 mehod(成员函数) JavaBean：是一种Java语言写成的可重用组建所谓JavaBean是指符合如下标准的Java类 类是公共的 有一个无参的公共构造器 有属性且有对应的get/set方法 属性vs局部变量不同点：声明位置不同，属性直接定义在类的一对大括号内，局部变量声明在方法内以及方法形参中修饰符，属性可以使用修饰符，局部变量不能使用除final外的修饰符默认初始化，类的属性在类实例化时根据其类型有初始化值，局部变量无初始化值内存位置不同，属性在堆中或静态域中，局部变量在栈中相同点：定义变量的格式相同都需要先声明后使用都有其对应的作用域 Object类的使用 Object类是所有Java类的根父类，如果在类的声明中未使用extends指明其父类，则默认父类为java.lang.Object类数组可以看作一个特殊的Object类 Object类中的主要结构 No 方法名称 类型 描述 1 public Object() 构造 构造器 2 public boolean equals(Object obj) 普通 对象比较 3 public int hashCode() 普通 取得Hash码 4 public String toString() 普通 对象打印时调用 ==与equals()区别 ==运算符 可以使用在基本数据类型变量和引用数据类型变量，基本数据类型可以自动提升类型来进行比较 如果为基本数据类型变量是比较两个变量数据是否相等(不一定类型相同) 如果为引用数据类型变量比较两个对象的地址值是否相同 equals()方法 是一个方法而不是运算符，基本数据类型变量无法使用 Object类中equals定义：return this == obj 与==运算符相同，同为比较两个引用数据类型变量的地址 像String，Date，File，等包装类比较的不是两个引用的地址是否相同，而是比较两个对象的实体内容是否相同。具体为先判断地址是否相同，再看是否为同一类，最后看比较关注的属性即实体内容。 当自定义使用equals()时，可以重写。用于比较两个对象的内容是否都相等。 toString()方法 当输出一个对象的引用时，实际上就是调用当前对象的toString()方法 String与其他类型数据连接时，调用该类型的toString()方法 Object类中的toString()方法为return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); String Date File包装类都重写了toString()方法，使得在调用对象的toString()方法时返回实体内容的信息 包装类 Java提供了8种基本数据类型对应的包装类，使得基本数据类型变量具有类的特征JDK5后有自动装箱和拆箱 int num2 = 10; Integer int1 = num2; int num1 = int1; 注意 Integer中有Cache数组从-128 - 127，如果为该范围内的数，则直接指向数组位置，如果超过则用new来构造一个新对象 对于形参是Object obj的函数，JDK5之后可以用基本数据类型数据通过自动装箱来作为实参传入。 类的语法格式 //创建一个类 修饰符 class 类名 { 修饰符 属性类型 属性名 = (是否显式初始化); 修饰符 返回值类型 方法名(形参列表) { 方法体; } } //实例化一个类 类名 对象名 = new 类名(); //匿名对象：创建的对象没有显示符给一个变量名 //匿名对象特征：只能调用一次 new 类名(); //常用在方法的参数之中 修饰符 权限修饰符：在封装性中详细讲解 private 缺省 protected public 其他修饰符：在其他关键字中讲解 static final 方法 方法的重载 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可 与返回值类型无关，只看参数列表，且参数列表必须不同。调用时，根据方法参数列表的不同来区别 总结：两同一不同，同类同方法名，参数不同(参数顺序不同也可以)。改变返回值且参数也改变也算重载 可变个数形参 JDK5之前：采用数组形参来定义方法，传入多个同一类型变量变量类型[] 变量名 JDK5及之后：采用可变个数形参来定义方法，传入多个同一类型变量变量类型...变量名 注意： 可变个数形参的参数个数可以为0个，1个，2个...可变形参的方法与本类中方法名相同，形参不同的方法构成重载，优先使用固定参数匹配的可变个数的形参与对应数组冲突如方法名(String[] args) 与 方法名(String...args)冲突访问可变参数形参时将其看作一个数组即可可变个数形参在方法的形参列表中，必须声明在末尾，且只能有一个可变个数形参 方法参数的传递机制 Java中只有值传递：即将实际参数值的副本传入方法内，而参数本身不受影响 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参 方法的重写(Override/Overwrite) 在子类中可以根据需要从父类中继承来的方法进行改造，也成为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 要求 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 父类为void，子类必须也为void 父类为A类型，子类返回值可以为A类或者A的子类 父类为基本数据类型，子类返回值要求与父类相同 子类重写的方法使用的访问权限不能小于父类被重写方法的访问权限 子类不能重写父类中声明为private权限的方法 子类与父类中同名同参数的方法必须同时声明为非static的，或者同时声明为static的(但是不是重写)，因为static方法是属于类的，子类无法覆盖父类的方法 子类方法抛出的异常不能大于父类被重写方法的异常 在多态情况下，对方法的调用和异常的捕获按父类声明的异常处理，如果大于父类的异常则出错 父类没有抛异常子类也不能抛出异常 重写和重载的区别 概念 具体规则 重载不表现为多态，重写表现为多态 构造器 创建类的方法：new + 构造器; 特征： 它具有与类相同的名称 他不声明返回值类型 不能被static, final, synchronized, abstrat, native修饰，不能有return语句返回值 作用： 创建对象，给对象进行初始化 构造器语法格式： 修饰符 类名(形参列表) { 初始化语句; } 属性赋值顺序 默认初始化 显式初始化或代码块，看位置先后 构造器中赋值 通过对象.方法或对象.属性的方法赋值 注意：如果无显式声明构造器，系统提供一个无参构造器使用，如果存在显式构造器，则不会提供默认构造器的修饰符与所述类的修饰符一致一个类可以创建多个重载的构造器父类的构造器不可被子类继承 代码块 简介 代码块的作用：对Java类或对象进行初始化，只能用static修饰代码块的分类： 被static修饰，称为静态代码块：通常用于初始化static的属性 没有使用static修饰的，称为非静态代码块 静态代码块 可以有输出语句。 可以对类的属性、类的声明进行初始化操作。 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。 若有多个静态的代码块，那么按照从上到下的顺序依次执行。 静态代码块的执行要先于非静态代码块。 静态代码块随着类的加载而加载，且只执行一次。 非静态代码块 可以有输出语句 。 可以对类的属性 、 类的声明进行初始化操作 。 除了调用非静态的结构外 还可以调用静态的变量或方法 。 若有多个非静态的代码块 那么按照从上到下的顺序依次执行 。 每次创建对象的时候都会执行一次 。且先于构造器执行 内部类 简介 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。 分类 成员内部类(static成员内部类和非static成员内部类) 一方面作为外部类的成员 调用外部类的结构外部类名.this.外部类结构 可以被static修饰，外部类不可以 可以修饰为public或者protected 另一方面作为一个类 内部类可以声明属性、方法、构造器等结构 可以声明为abstract类，因此可以被其他内部类继承 可以声明为final的 注意 非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员 外部类访问成员内部类的成员需要通过内部类.成员或者内部类对象.成员的方式 成员内部类可以使用外部类的所有成员，包括私有的数据 当想要在外部类的静态成员部分使用内部类时，可以考虑将内部类声明为静态的 局部内部类(方法内、代码块内、构造器内) 使用 只能在声明他的方法或代码块中使用，且为先声明后使用。除此之外任何地方都不能使用该类 但是他的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父类接口类型 特点 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的 .class 文件，但是前面冠以外部类的类名和符号，以及数字编号。 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。 局部内部类可以使用外部类的成员，包括私有的 。 局部内部类可以使用外部方法的局部变量，但是必须是 final 的。 由局部内部类和局部变量的声明周期不同所致。 局部内部类和局部变量地位类似，不能使用 public,protected, 缺省 ,private 局部内部类不能使用 static 修饰，因此也不能包含静态成员 匿名内部类 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。 格式 new 父类构造器(实参列表)|实现接口(){ //匿名内部类的类体部分 } 特点 匿名内部类必须继承父类或实现接口 匿名内部类只能有一个对象 匿名内部类对象只能使用多态形式引用 内部类的使用 实例化成员内部类对象 静态内部类 外部类名.内部类名 内部对象名 = new 外部类名.内部类名(); 非静态 外部类名 外部类对象 = new 外部类名(); 外部类名.内部类名 内部对象名 = 外部对象名.new 内部类名() 在成员内部类中区分调用外部类结构，当变量名及形参重名时内部类 this.变量名 外部类 外部类名.this.变量名 开发中局部内部类的使用：常见于返回值类型为接口的情况 程序中成员变量赋值的执行顺序 声明变量的默认初始化 显式初始化、多个代码化块依次被执行(同级别下按先后顺序执行) 构造器再对成员进行初始化操作 通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，可多次给属性赋值 创建子类(子类的实例化) 先从Object开始加载，然后加载到子类 由父及子，静态先行 父的静态代码块 --&gt; 子的静态代码块 --&gt; 父的非静态 --&gt; 父的构造器 --&gt; 子的非静态 --&gt; 子的构造器 在此创建对象时不再执行静态代码块 main函数开始前先执行所属类的静态代码块 简单的内存解析 编译完源码之后，生成一个或多个字节码文件，我们使用JVM中的类加载器对生成的字节码文件进行解释运行，意味着需要将字节码中的对应的类加载到内存中。虚拟机栈：即栈，局部变量存放在栈中堆：new出来的结构，对象的非static属性也放在堆中方法区：类的加载信息，常量池，静态域 万事万物皆对象的理解 Java中，我们将功能结构封装到类中，通过类的实例化来调用具体的功能 涉及到Java与前端Html后端的数据库交互式都体现为类对象，比如数据库中一个表可以看作一个类，表的字段可以看作为类的属性，表的每一行数据可以看作一个对象。 instanceof操作符 //检查x是否为类A的对象，返回值为boolean类型。 //如果x属于类A的子类B那么也返回true x instanceof A; 对象类型转换 从子类到父类的类型转换可以自动进行 从父类到子类的类型转换必须通过强制类型转换实现 无继承关系的引用类型间的转换是非法的 在强制类型转换前可以使用instanceof操作符测试一个对象的类型 面向对象的三大特征 封装和隐藏(封装性) 为什么要封装和隐藏设计追求：高内聚，低耦合隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性 封装性需要有权限修饰符来配合，面向对象的主要体现在： 属性私有化(提供相对应的Getter/Setter方法) 方法私有化(仅类内部使用) 单例模式(设计模式中的一种，恶汉式/懒汉式) 四种权限修饰符，可以修饰类的内部结构：属性，方法，内部类，构造器。其中只有public和缺省可以修饰类 权限修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes No No No 缺省 Yes Yes No No protected Yes Yes Yes No public Yes Yes Yes Yes 继承性 class A extends B{ 子类特有的属性 子类特有的方法 } 多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。一旦子类继承了父类之后，子类就获得了父类中声明的所有结构，属性，方法。子类可以获得private权限的属性，方法，只不过因为封装性影响不能直接调用而已，子类继承父类后可以声明自己特有的属性和方法，实现功能的拓展。 好处: 减少代码冗余提高复用性 便于功能的扩展 为之后多态性提供了前提 注意： 单继承性：一个父类可以有多个子类，一个子类只能有一个父类 子父类是相对的概念：子类 ==&gt; 直接父类 ==&gt; 间接父类 ==&gt; 间接父类 所有的Java类(除Java.lang.Object类之外)都直接或间接的继承于Java.lang.Object类 父类中的方法如果使用了this关键字，子类继承后该this指代子类的对象 寻找一个属性或方法是，先查看子类，如果没有则看直接父类，如果依旧没有查看间接父类，以此类推 多态性 简介 多态性可以理解为一种事物的多种形态对象的多态性：父类的引用纸箱子类的对象实例 父类名 C1 = new 子类名(); Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋予该变量的对象决定。简单来说：编译时，看左边；运行时，看右边。 使用 当调用子父类中同名同参数的方法时，实际执行的是子类重写父类的方法，即虚拟方法调用，不能调用子类特有的方法(即父类中没有的方法)虚拟方法调用(动态绑定)：在编译器只能调用父类中声明的方法，但在运行时我们实际执行子类的方法。父类的方法我们称为虚拟方法，动态调用子类的方法。 存在的前提 有类的继承关系 方法的重写 多态的意义 代码复用，可以在定义方法时写父类。 注意 属性无多态性，属性的编译和运行都看等号左边。 多态是运行时行为。 一个引用类型变量如果生命为父类的类型，但实际引用的是子类的对象，那么该变量就不能再访问子类中添加的属性和方法。如果需要调用子类特有的属性或方法，则需要使用强制类型转换。 在使用类强制转换时可能出现ClassCastException 关键字 this关键字 this理解为当前的对象 什么时候使用this关键字： 在类的方法或者构造器中可以使用this.属性或this.方法的方式。 调用当前对象的属性或方法，但在通常情况下我们都选择省略this。 特殊情况下当方法形参予属性重名，我们必须显式的使用this，表明为属性而不是形参。 使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。 this可以作为一个类中构造器相互调用的特殊格式 一个类中有n个构造器最多有n-1个构造器中使用了this(xxx)规定this调用构造器时，必须放在构造器的首行，且只能有一个this(xxx)构造器不能通过this(xxx)调用自身 super关键字 super可用于访问父类中定义的属性 super可用于调用父类中定义的成员方法 super可用于在子类构造器中调用父类的构造器 子类中所有的构造器默认都会访问父类中空参数的构造器 可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的制定的构造器 super(形参列表)的使用必须声明在子类构造器的首行 this(形参列表)和super(形参列表)只能二选一 在构造器首行没有显式的声明this(形参列表)或super(形参列表)则默认使用父类的空参构造器 在类的构造器中至少有一个构造器使用了super 注意尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员super的追溯不仅限于直接父类super和this的用法很像，this代表本类对象的引用，super代表父类的内存空间的标识当子类重写了父类中的方法以后，我们想在子类中调用父类中被重写的方法时用super调用，如果直接父类重写了间接父类的方法super调用的是直接父类的方法 子类对象实例化全过程 从结果上看子类继承父类后就获得了父类中声明的属性或方法，创建该子类对象，在堆空间中就会加载父类中的所有属性 从过程上看当通过子类的构造器创建类类对象时，我们一定会直接或间接调用父类的构造器，进而调用父类的父类的构造器，直到调用了Object类中的构造器位置。正因为加载过所有的父类的结构，所以才可以看到内存中有父类的结构，子类对象才可以考虑进行调用。 this和super的对比 No 区别点 this super 1 访问属性 访问本类中的属性，如果本类没有此属性则从父类中继续查找 直接访问父类中的属性 2 调用方法 访问本类中的方法，如果本类没有此方法则从父类中继续查找 直接访问父类中的方法 3 调用构造器 调用本类构造器，必须放在构造器的首行 调用父类构造器，必须放在子类构造器的首行 static关键字 简介 无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。 静态的 可以用来修饰：属性、方法、代码块、内部类 被修饰后的成员具有如下特点： 随着类的加载而加载 优先于对象存在 修饰的成员，被所有对象所共享 访问权限允许事，可不创建对象，直接被类调用。 类属性、类方法的设计思路 类属性作为该类各个对象之间共享的变量。在设计类时，分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法 如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。 静态变量与实例变量 属性是否使用static修饰可以分为：静态属性(类变量)，非静态属性(实例变量) 实例变量：我们创建多个对象，每个对象都独立拥有一台类中的非静态属性，当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态属性：多个对象共享同一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时时修改过了的。 静态变量随着类的加载而加载，非静态变量随着对象的创建而加载 静态变量的加载早于对象的创建 可以通过类名.静态变量名的方式而调用 类只会加载一次，静态变量也只会加载一次，存在方法区的静态域中 类变量 实例变量 类 YES NO 对象 YES YES 静态变量的内存解析 静态方法 随着类的加载而加载，可通过类名.静态方法名()的方式调用 静态方法中只能调用静态的方法或属性 非静态方法中既可以调用非静态的方法和属性，也可以调用静态的方法与属性 静态方法 非静态方法 类 YES NO 对象 YES YES 注意 在静态方法中不能使用this关键字、super关键字(因为不需要实例就可以访问static方法) static修饰的方法不能被重写 何时使用static关键字 属性 属性不随对象不同而不同，是多个对象共享的 常量一般也常声明为static 方法 操作静态属性的方法 工具类的方法 理解main()方法的语法 由于 Java 虚拟机需要调用类的 main() 方法，所以该方法的访问权限必须是 public 又因为 Java 虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数 又因为 main () 方法是静态的 ，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。 参数用法java XXX &quot;参数一&quot; &quot;参数二&quot; &quot;参数三&quot; main函数开始前先执行所属类的静态代码块 final关键字 final关键字可以修饰类、方法、变量表示最终的 作用 final标记的类不能被继承。提高安全性，提高程序的可能性 final修饰的类对应的实例中的属性可以改变。 String类、System类、StringBuffer类 final标记的方法不能被子类重写 如Object类中的getClass() final标记的变量(成员变量或局部变量)即称为常量 final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用 final double MY_PI = 3.14 static 与 final 一起使用可以修饰方法和属性表示全局常量 abstract关键字 用abstract关键字可以用来修饰抽象类和抽象方法 abstract不能修饰属性、构造器、代码块等 不能修饰私有方法、静态方法、final的方法 可以多态 抽象类的匿名子类 //抽象类的匿名子类 new 抽象类名(){ 重写方法； } 抽象类 抽象类：随着继承层次中一个个新子类的定义，类编的越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计的非常抽象，以至于他没有具体的实例，这样的类叫抽象类。 抽象类特征 此类不能实例化 类中仍然有构造器便于子类实例化时使用 开发中都会提供抽象类的子类，让子类实例化完成相关的操作 抽象类应用 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类 抽象方法 权限修饰符+abstract+返回值类型+方法名(形参列表); 抽象方法只有方法声明无方法体 包含抽象方法的类一定是一个抽象类，但是抽象类可以没有抽象方法 若子类重写了父类中所有抽象方法后，此子类可实例化 若子类没有重写所有抽象方法，那该子类也应当为抽象类 interface关键字(接口) 接口：抽象方法和常量定义的集合。接口不存在is-a关系，但是具有相同的行为特征。继承是一个是不是的关系，接口实现则是能不能的关系。接口的本质是契约，标准，规范。 接口的使用 接口使用interface来定义 Java中接口和类是两个并列结构 接口中的成员变量都是默认由public static final修饰的(修饰可以省略) 接口中的抽象方法都是默认由public abstract修饰的(修饰可以省略) 接口中没有构造器 JDK7及之前只能包含常量和方法的定义，JDK8及之后还可以定义静态方法和默认方法 接口不能实例化 Java开发中通过让类去实现接口来使用，如果实现了所有抽象方法则可以实例化，否则仍为抽象类 接口可以多继承 接口与接口间也可以继承，且可以多继承 接口也有多态性 接口实际上可以看作一种特殊的类，也可以看作一种规范 接口可以作为形参，但传入的实参应当实现抽象方法 如果一个接口中定义了一个默认方法，另一个接口中也定义了同名同参的方法，在实现类中同时实现这两个接口时会出现接口冲突，实现类必须覆盖接口中同名同参的方法，来解决冲突 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参的非抽象方法，则不会出现冲突问题。此时遵守类优先原则接口中具有同名同参的默认方法会被忽略。 接口中定义的静态方法只能通过接口名.方法名()使用 默认方法重写时不需要带default修饰符 如果实现类重写了默认方法，则使用重写后的方法 实现类中调用接口中的默认方法接口名.super.方法名() 代码示例 interface name{ 返回类型 方法名();//省略了public abstract 数据类型 变量名;//省略了public static final //public可以省略 public default 返回类型 方法名();//默认方法 public static 返回类型 方法名();//静态方法 } 接口与抽象类的对比 No. 区别点 抽象类 接口 1 定义 包含抽象方法的类 主要是抽象方法和全局常量的集合 2 组成 构造方法、抽象方法、普通方法、常量、变量 常量、抽象方法、(JDK8默认方法、静态方法) 3 使用 子类继承抽象类extends 子类实现接口implents 4 关系 抽象类可以实现多个接口 接口不能继承抽象类，但允许继承多个接口 5 常见设计模式 模板方法 简单工厂、工厂方法、代理模式 6 对象 都通过对象的多态性产生实例化对象 7 局限 抽象类有单继承的局限 接口没有此局限 8 实际 作为一个模板 是作为一个标准或是表示一种能力 9 选择 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 package关键字 ackage语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包 语法格式为package 顶层包名.子包名 包的作用： 包帮助管理大型软件系统：将功能相近的类划分到同一个包中(比如MVC的设计模式) 包可以包含类和子包，划分项目层次，便于管理 解决类命名冲突问题 控制访问权限 MVC设计模式 M：数据模型层 model 数据对象封装 model.bran\\domain 数据库操作类 model.dao 数据库 model.db V：视图模型层 view 相关工具类 view.utils 自定义view view.ui C：控制器层 control 应用界面相关 contrloler.activity 存放fragment controller.fragment 显示列表的适配器 controller.adapter 服务相关的 controller.service 抽取的基类 controller.base import关键字 为使用定义在不同包中的Java类，需用import语句来引入指定包层次瞎所需要的类或全部类。import语句告诉编译器到哪里去寻找类。import 包名.类名 注意声明在包的声明与类的声明之间如果导入多个，并列写出即可可以使用包名.*的方式表示导入该包名下的所有结构核心包不需要导入(java.lang.*)如果使用的类或结构在当前包中则不需要导入如果源文件中使用了不同包下的同名的类，则必须至少有一个类使用带包名的全类名如果使用包名.*的方式表明可以调用该包下的所有结构(类或接口)但使用的如果是该包的子包中的结构则仍然需要显示的调用才可以import static 包名.类名 导入指定类或接口中的静态属性或方法 ","link":"https://yeyuan1107.github.io/post/java-mian-xiang-dui-xiang/"},{"title":"Java数组","content":" 数组的概述 数组是多个相同类型的数据按照一定顺序排列的集合，并使用一个名字命名，并通过变好的方式对这些数据进行统一管理 常见概念：数组名下表(索引)元素数组的长度 数组属于引用数据类型变量数组中的元素及可以为基本数据类型也可以为引用数据类型数组占用内存中一块连续的空间数组长度一旦确定就不能修改 数组的声明 动态初始化数据类型 数组名[] = new 数据类型[数组长度]; 静态初始化数据类型 数组名[] = new 数据类型[]{数组内容};数据类型 数组名[] = {数组内容}; 数组属性数组名.length 返回数组长度 数组一经分配空间，其中每个元素也被按照成员变量同样的方式被隐式初始化对于基本数据类型而言，初始化即为对应类型的初始化值对于引用数据类型而言，默认初始化值为null Arrays工具类 Xxxxxs一般为操作搞结构的工具类 返回类型 方法名 作用 备注 boolean equals[int[] a, int[] b] 判断两个数组是否相同 源码线比较地址再看是否有null再看长度最后再一一对比 String toString() 输出数组信息 会在数组元素间添加空格 void fill(int[] a, int val) 将指定值填充到数组之中 void sort(int[] a) 对数组进行排序 快速排序 int binarySearch(int[] a, int key) 对排序后的数组进行二分法检索指定的值 数组中的常见异常 ArrayIndexOutOfBoundsException 数组角标越界异常 NullPointerException 空指针异常 出现异常且未处理异常时，程序停止执行 ","link":"https://yeyuan1107.github.io/post/java-shu-zu/"},{"title":"Java基本语法","content":" 关键字 定义：被Java语言赋予了特殊含义，用作专门用途的字符串特点：关键字中所有字母都为小写 用于定义数据类型的关键字：class, interface, enum, byte, short, int, long, float, double, char, boolean, void 用于定义流程控制的关键字：if, else, switch, case, default, while, do, for, break, continue, return 用于定义访问权限修饰符的关键字：private, protected, public 用于定义类，函数，变量修饰符的关键字：abstract, final, static, synchronized 用于定义类与类之间关系的关键字：extends, implements 用于定义建立实例及引用实例：new, this, super, instanceof 用于异常处理的关键字：try, catch, finally, throws, throw, throws 用于包的关键字：package, import 其他修饰符关键字：native, strictfp, transient, volatile, assert 用于定义数据类型值的字面值：true, false, null 保留字：goto, const 标识符 Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符凡事自己可以起名字的地方都叫标识符 标识符规则 由26个英文字母大小写，0-9，_或$组成数字不可以开头不可以使用关键字和保留字，但可以包含关键字和保留字Java中严格区分大小写，长度无限制标识符不能包含空格 标识符规范 包名：多单词组成时所有字母都小写：xxxyyyzzz类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz常量名：所有字幕都大写，多单词时每个单词用下划线链接：XXX_YYY_ZZZ 变量的分类 变量的分类-按数据类型分类 基本数据类型 数值型 整数类型(byte, short, int, long) 浮点类型(float, double) 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组(*[]) 变量的分类-按声明的位置 成员变量 实例变量(不以static修饰) 类变量(以static修饰) 局部变量 形参(方法、构造器中定义的变量) 方法局部变量(在方法内定义) 代码块局部变量(在代码块内定义) 二者异同 同：都有生命周期 异：局部变量除形参外，需显式初始化 基本数据类型转换 byte, short, char -&gt; int -&gt; long -&gt; float -&gt; double 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算 byte, shor, char间不会相互转换，他们三者在计算时首先转换为int类型 boolean类型不能与其他数据类型计算 当任何基本数据类型的值和字符串(String)进行连接运算时，基本数据类型的值自动转化为字符串类型 运算符 算数运算符 运算符 运算 备注 + 正号 - 负号 + 加 short, byte类型 + 常数转换为int型 - 减 * 乘 / 除 % 取余 余数符号取决于被模数 ++ 自增 short, byte类型与+1不同，不会改变为int型 -- 自减 自增与自减不会改变原变量数据类型 + 连接 赋值运算符 运算符 运算 备注 = 赋值 两侧数据不一致时，可以使用自动/强制类型转换 +=, -=, *=, /=, %= 不会改变变量类型，不会自动类型转换 比较运算符 运算符 运算 备注 == 相等于 在除了数值类型变量间使用时，比较的是地址 != 不等于 在除了数值类型变量间使用时，比较的是地址 &lt; 小于 只能在数值类型变量间使用 &gt; 大于 只能在数值类型变量间使用 &lt;= 小于等于 只能在数值类型变量间使用 &gt;= 大于等于 只能在数值类型变量间使用 instanceof 检查是否是类的对象 逻辑运算符 运算符 运算 &amp; 逻辑与 | 逻辑或 &amp;&amp; 短路与 || 短路或 ! 逻辑非 ^ 逻辑异或 短路与与短路或可以用来编写递归条件 开发过程中一般使用短路逻辑运算符 位运算符 运算符 运算 &lt;&lt; 左移 &gt;&gt; 右移 &gt;&gt;&gt; 无符号右移不管符号位，直接补0 &amp; 与运算 ^ 异或运算 | 或运算 ~ 取反运算 //交换变量值 方式一： temp = num1; num1 = num2; num2 = temp; 方式二： num1 = num1 + num2; num2 = num1 - num2; num1 = num1 - num2; 方式三： num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; 三元运算符 条件表达式 ? 表达式1 : 表达式2其中表达式1与表达式2为同种类型三元运算符可以转化为if-else，但if-else不一定能转化为三元运算符如果可以使用三元运算符，则优先使用三元运算符 在控制台从键盘输入 import java.util.Scanner; Scanner in = new scanner(System.in); xxx num = in.nextXxx(); String类型用next()或nextLine(); Java产生随机数 Math.random() =&gt; [0,1) 求[a, b] =&gt; (int) (Math.random()\\*(b-a+1)+a) 流程结构 顺序结构 分支结构 循环结构 分支结构 if语句 if if-else if-elseif-else switch语句 语法格式switch(表达式){ case 1: case 2:} 表达式的值必须为 byte, short, char, int, 枚举, String case子句中的值必须为常量 优先使用switch，switch效率更高 循环结构 for while do-while break以及continue可以跳出到固定label, 且之后不能写执行语句 label的声明为 label:{} ","link":"https://yeyuan1107.github.io/post/java-ji-ben-yu-fa/"},{"title":"Java基础概述","content":" 常用DOS命令 dir：列出当前目录下的文件以及文件夹 md：创建目录 rd：删除目录 cd：进入制定目录 cd\\：退回到跟目录 cd..：退回到上一级目录 del：删除文件 exit：推出DOS命令行 Java语言特点 面向对象 两个基本概念：类、对象 三大特性：封装性、继承性、多态性 健壮性 吸收了C/C++语言的有点，但去掉了影响程序健壮性的部分(如指针、内存的申请与释放等)，提供了一个相对安全的内存管理和访问机制 跨平台性 通过Java编写的应用程序在不同的系统平台上都可以运行 原理：只需要在运行Java应用程序的操作系统上，先安装一个Java虚拟机即可。由JVM来负责Java程序在该系统的运行。 Java的两种核心机制 Java虚拟机 垃圾回收机制GC 虽然有垃圾回收机制但是仍然会出现内存泄漏和内存溢出 JDK、JRE和JVM关系 JDK(Java Development Kit)：Java开发工具包 JRE(Java Runtime Environment)：Java运行环境 JVM(Java Virtual Machine)：Java虚拟机 JDK = JRE + 开发工具集 (如Javac编译工具等) JRE = JVM + JavaSE标准类库 Java源文件 一个源文件可以有多个类，但只有一个类可以是public，且public类的类名与文件名要相同源文件中有多个class，编译后生成多个.class文件运行时执行包含main方法的类 Java应用程序 *.java文件经过 javac.exe 编译生成 *.class 文件 再通过 java.exe 运行 *.class 文件 API API(Application Programing Interface)：应用编程接口，是Java提供的基本编程接口 ","link":"https://yeyuan1107.github.io/post/java-ji-chu-gai-shu/"}]}